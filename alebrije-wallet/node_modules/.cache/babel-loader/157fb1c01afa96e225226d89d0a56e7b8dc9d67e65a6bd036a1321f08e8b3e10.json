{"ast":null,"code":"import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\nexport var TransferHookInstruction;\n(function (TransferHookInstruction) {\n  TransferHookInstruction[TransferHookInstruction[\"Initialize\"] = 0] = \"Initialize\";\n  TransferHookInstruction[TransferHookInstruction[\"Update\"] = 1] = \"Update\";\n})(TransferHookInstruction || (TransferHookInstruction = {}));\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct([u8('instruction'), u8('transferHookInstruction'), publicKey('authority'), publicKey('transferHookProgramId')]);\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n  initializeTransferHookInstructionData.encode({\n    instruction: TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Initialize,\n    authority,\n    transferHookProgramId\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct([u8('instruction'), u8('transferHookInstruction'), publicKey('transferHookProgramId')]);\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId) {\n  let multiSigners = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let programId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TOKEN_2022_PROGRAM_ID;\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }], authority, multiSigners);\n  const data = Buffer.alloc(updateTransferHookInstructionData.span);\n  updateTransferHookInstructionData.encode({\n    instruction: TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Update,\n    transferHookProgramId\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\nfunction deEscalateAccountMeta(accountMeta, accountMetas) {\n  const maybeHighestPrivileges = accountMetas.filter(x => x.pubkey === accountMeta.pubkey).reduce((acc, x) => {\n    if (!acc) return {\n      isSigner: x.isSigner,\n      isWritable: x.isWritable\n    };\n    return {\n      isSigner: acc.isSigner || x.isSigner,\n      isWritable: acc.isWritable || x.isWritable\n    };\n  }, undefined);\n  if (maybeHighestPrivileges) {\n    const {\n      isSigner,\n      isWritable\n    } = maybeHighestPrivileges;\n    if (!isSigner && isSigner !== accountMeta.isSigner) {\n      accountMeta.isSigner = false;\n    }\n    if (!isWritable && isWritable !== accountMeta.isWritable) {\n      accountMeta.isWritable = false;\n    }\n  }\n  return accountMeta;\n}\n/**\n * Add extra accounts needed for transfer hook to an instruction\n *\n * @param connection      Connection to use\n * @param instruction     The transferChecked instruction to add accounts to\n * @param commitment      Commitment to use\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function addExtraAccountsToInstruction(connection, instruction, mint, commitment) {\n  let programId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TOKEN_PROGRAM_ID;\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const mintInfo = await getMint(connection, mint, commitment, programId);\n  const transferHook = getTransferHook(mintInfo);\n  if (transferHook == null) {\n    return instruction;\n  }\n  const extraAccountsAccount = getExtraAccountMetaAddress(mint, transferHook.programId);\n  const extraAccountsInfo = await connection.getAccountInfo(extraAccountsAccount, commitment);\n  if (extraAccountsInfo == null) {\n    return instruction;\n  }\n  const extraAccountMetas = getExtraAccountMetas(extraAccountsInfo);\n  const accountMetas = instruction.keys;\n  for (const extraAccountMeta of extraAccountMetas) {\n    const accountMetaUnchecked = await resolveExtraAccountMeta(connection, extraAccountMeta, accountMetas, instruction.data, transferHook.programId);\n    const accountMeta = deEscalateAccountMeta(accountMetaUnchecked, accountMetas);\n    accountMetas.push(accountMeta);\n  }\n  accountMetas.push({\n    pubkey: transferHook.programId,\n    isSigner: false,\n    isWritable: false\n  });\n  accountMetas.push({\n    pubkey: extraAccountsAccount,\n    isSigner: false,\n    isWritable: false\n  });\n  return new TransactionInstruction({\n    keys: accountMetas,\n    programId,\n    data: instruction.data\n  });\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals) {\n  let multiSigners = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];\n  let commitment = arguments.length > 8 ? arguments[8] : undefined;\n  let programId = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : TOKEN_PROGRAM_ID;\n  const rawInstruction = createTransferCheckedInstruction(source, mint, destination, authority, amount, decimals, multiSigners, programId);\n  const hydratedInstruction = await addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);\n  return hydratedInstruction;\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, fee) {\n  let multiSigners = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n  let commitment = arguments.length > 9 ? arguments[9] : undefined;\n  let programId = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : TOKEN_PROGRAM_ID;\n  const rawInstruction = createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners, programId);\n  const hydratedInstruction = await addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);\n  return hydratedInstruction;\n}","map":{"version":3,"names":["struct","u8","TransactionInstruction","programSupportsExtensions","TOKEN_2022_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenUnsupportedInstructionError","addSigners","TokenInstruction","publicKey","createTransferCheckedInstruction","createTransferCheckedWithFeeInstruction","getMint","getExtraAccountMetaAddress","getExtraAccountMetas","getTransferHook","resolveExtraAccountMeta","TransferHookInstruction","initializeTransferHookInstructionData","createInitializeTransferHookInstruction","mint","authority","transferHookProgramId","programId","keys","pubkey","isSigner","isWritable","data","Buffer","alloc","span","encode","instruction","TransferHookExtension","transferHookInstruction","Initialize","updateTransferHookInstructionData","createUpdateTransferHookInstruction","multiSigners","arguments","length","undefined","Update","deEscalateAccountMeta","accountMeta","accountMetas","maybeHighestPrivileges","filter","x","reduce","acc","addExtraAccountsToInstruction","connection","commitment","mintInfo","transferHook","extraAccountsAccount","extraAccountsInfo","getAccountInfo","extraAccountMetas","extraAccountMeta","accountMetaUnchecked","push","createTransferCheckedWithTransferHookInstruction","source","destination","amount","decimals","rawInstruction","hydratedInstruction","createTransferCheckedWithFeeAndTransferHookInstruction","fee"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/spl-token/src/extensions/transferHook/instructions.ts"],"sourcesContent":["import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, Commitment, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\n\nexport enum TransferHookInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface InitializeTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Initialize;\n    authority: PublicKey;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct<InitializeTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('authority'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    programId: PublicKey\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n    initializeTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Initialize,\n            authority,\n            transferHookProgramId,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface UpdateTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Update;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct<UpdateTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateTransferHookInstructionData.span);\n    updateTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Update,\n            transferHookProgramId,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\nfunction deEscalateAccountMeta(accountMeta: AccountMeta, accountMetas: AccountMeta[]): AccountMeta {\n    const maybeHighestPrivileges = accountMetas\n        .filter((x) => x.pubkey === accountMeta.pubkey)\n        .reduce<{ isSigner: boolean; isWritable: boolean } | undefined>((acc, x) => {\n            if (!acc) return { isSigner: x.isSigner, isWritable: x.isWritable };\n            return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };\n        }, undefined);\n    if (maybeHighestPrivileges) {\n        const { isSigner, isWritable } = maybeHighestPrivileges;\n        if (!isSigner && isSigner !== accountMeta.isSigner) {\n            accountMeta.isSigner = false;\n        }\n        if (!isWritable && isWritable !== accountMeta.isWritable) {\n            accountMeta.isWritable = false;\n        }\n    }\n    return accountMeta;\n}\n\n/**\n * Add extra accounts needed for transfer hook to an instruction\n *\n * @param connection      Connection to use\n * @param instruction     The transferChecked instruction to add accounts to\n * @param commitment      Commitment to use\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function addExtraAccountsToInstruction(\n    connection: Connection,\n    instruction: TransactionInstruction,\n    mint: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionInstruction> {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n    if (transferHook == null) {\n        return instruction;\n    }\n\n    const extraAccountsAccount = getExtraAccountMetaAddress(mint, transferHook.programId);\n    const extraAccountsInfo = await connection.getAccountInfo(extraAccountsAccount, commitment);\n    if (extraAccountsInfo == null) {\n        return instruction;\n    }\n\n    const extraAccountMetas = getExtraAccountMetas(extraAccountsInfo);\n\n    const accountMetas = instruction.keys;\n\n    for (const extraAccountMeta of extraAccountMetas) {\n        const accountMetaUnchecked = await resolveExtraAccountMeta(\n            connection,\n            extraAccountMeta,\n            accountMetas,\n            instruction.data,\n            transferHook.programId\n        );\n        const accountMeta = deEscalateAccountMeta(accountMetaUnchecked, accountMetas);\n        accountMetas.push(accountMeta);\n    }\n    accountMetas.push({ pubkey: transferHook.programId, isSigner: false, isWritable: false });\n    accountMetas.push({ pubkey: extraAccountsAccount, isSigner: false, isWritable: false });\n\n    return new TransactionInstruction({ keys: accountMetas, programId, data: instruction.data });\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n) {\n    const rawInstruction = createTransferCheckedInstruction(\n        source,\n        mint,\n        destination,\n        authority,\n        amount,\n        decimals,\n        multiSigners,\n        programId\n    );\n\n    const hydratedInstruction = await addExtraAccountsToInstruction(\n        connection,\n        rawInstruction,\n        mint,\n        commitment,\n        programId\n    );\n\n    return hydratedInstruction;\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n) {\n    const rawInstruction = createTransferCheckedWithFeeInstruction(\n        source,\n        mint,\n        destination,\n        authority,\n        amount,\n        decimals,\n        fee,\n        multiSigners,\n        programId\n    );\n\n    const hydratedInstruction = await addExtraAccountsToInstruction(\n        connection,\n        rawInstruction,\n        mint,\n        commitment,\n        programId\n    );\n\n    return hydratedInstruction;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}