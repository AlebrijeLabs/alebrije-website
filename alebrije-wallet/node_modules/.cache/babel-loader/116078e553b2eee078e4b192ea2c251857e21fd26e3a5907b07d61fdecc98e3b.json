{"ast":null,"code":"import { SocketClosedError, WebSocketRequestError } from '../../errors/request.js';\nimport { getSocketRpcClient } from './socket.js';\nexport async function getWebSocketRpcClient(url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    keepAlive,\n    reconnect\n  } = options;\n  return getSocketRpcClient({\n    async getSocket(_ref) {\n      let {\n        onClose,\n        onError,\n        onOpen,\n        onResponse\n      } = _ref;\n      const WebSocket = await import('isows').then(module => module.WebSocket);\n      const socket = new WebSocket(url);\n      function onClose_() {\n        socket.removeEventListener('close', onClose_);\n        socket.removeEventListener('message', onMessage);\n        socket.removeEventListener('error', onError);\n        socket.removeEventListener('open', onOpen);\n        onClose();\n      }\n      function onMessage(_ref2) {\n        let {\n          data\n        } = _ref2;\n        try {\n          const _data = JSON.parse(data);\n          onResponse(_data);\n        } catch (error) {\n          onError(error);\n        }\n      }\n      // Setup event listeners for RPC & subscription responses.\n      socket.addEventListener('close', onClose_);\n      socket.addEventListener('message', onMessage);\n      socket.addEventListener('error', onError);\n      socket.addEventListener('open', onOpen);\n      // Wait for the socket to open.\n      if (socket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!socket) return;\n          socket.onopen = resolve;\n          socket.onerror = reject;\n        });\n      }\n      const {\n        close: close_\n      } = socket;\n      return Object.assign(socket, {\n        close() {\n          close_.bind(socket)();\n          onClose_();\n        },\n        ping() {\n          try {\n            if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new WebSocketRequestError({\n              url: socket.url,\n              cause: new SocketClosedError({\n                url: socket.url\n              })\n            });\n            const body = {\n              jsonrpc: '2.0',\n              method: 'net_version',\n              params: []\n            };\n            socket.send(JSON.stringify(body));\n          } catch (error) {\n            onError(error);\n          }\n        },\n        request(_ref3) {\n          let {\n            body\n          } = _ref3;\n          if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new WebSocketRequestError({\n            body,\n            url: socket.url,\n            cause: new SocketClosedError({\n              url: socket.url\n            })\n          });\n          return socket.send(JSON.stringify(body));\n        }\n      });\n    },\n    keepAlive,\n    reconnect,\n    url\n  });\n}","map":{"version":3,"names":["SocketClosedError","WebSocketRequestError","getSocketRpcClient","getWebSocketRpcClient","url","options","arguments","length","undefined","keepAlive","reconnect","getSocket","_ref","onClose","onError","onOpen","onResponse","WebSocket","then","module","socket","onClose_","removeEventListener","onMessage","_ref2","data","_data","JSON","parse","error","addEventListener","readyState","CONNECTING","Promise","resolve","reject","onopen","onerror","close","close_","Object","assign","bind","ping","CLOSED","CLOSING","cause","body","jsonrpc","method","params","send","stringify","request","_ref3"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/viem/utils/rpc/webSocket.ts"],"sourcesContent":["import type { MessageEvent } from 'isows'\n\nimport {\n  SocketClosedError,\n  WebSocketRequestError,\n} from '../../errors/request.js'\nimport type { RpcRequest } from '../../types/rpc.js'\nimport {\n  type GetSocketRpcClientParameters,\n  type Socket,\n  type SocketRpcClient,\n  getSocketRpcClient,\n} from './socket.js'\n\nexport type GetWebSocketRpcClientOptions = Pick<\n  GetSocketRpcClientParameters,\n  'keepAlive' | 'reconnect'\n>\n\nexport async function getWebSocketRpcClient(\n  url: string,\n  options: GetWebSocketRpcClientOptions | undefined = {},\n): Promise<SocketRpcClient<WebSocket>> {\n  const { keepAlive, reconnect } = options\n\n  return getSocketRpcClient({\n    async getSocket({ onClose, onError, onOpen, onResponse }) {\n      const WebSocket = await import('isows').then((module) => module.WebSocket)\n      const socket = new WebSocket(url)\n\n      function onClose_() {\n        socket.removeEventListener('close', onClose_)\n        socket.removeEventListener('message', onMessage)\n        socket.removeEventListener('error', onError)\n        socket.removeEventListener('open', onOpen)\n        onClose()\n      }\n      function onMessage({ data }: MessageEvent) {\n        try {\n          const _data = JSON.parse(data)\n          onResponse(_data)\n        } catch (error) {\n          onError(error as Error)\n        }\n      }\n\n      // Setup event listeners for RPC & subscription responses.\n      socket.addEventListener('close', onClose_)\n      socket.addEventListener('message', onMessage)\n      socket.addEventListener('error', onError)\n      socket.addEventListener('open', onOpen)\n\n      // Wait for the socket to open.\n      if (socket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!socket) return\n          socket.onopen = resolve\n          socket.onerror = reject\n        })\n      }\n\n      const { close: close_ } = socket\n\n      return Object.assign(socket, {\n        close() {\n          close_.bind(socket)()\n          onClose_()\n        },\n        ping() {\n          try {\n            if (\n              socket.readyState === socket.CLOSED ||\n              socket.readyState === socket.CLOSING\n            )\n              throw new WebSocketRequestError({\n                url: socket.url,\n                cause: new SocketClosedError({ url: socket.url }),\n              })\n\n            const body: RpcRequest = {\n              jsonrpc: '2.0',\n              method: 'net_version',\n              params: [],\n            }\n            socket.send(JSON.stringify(body))\n          } catch (error) {\n            onError(error as Error)\n          }\n        },\n        request({ body }) {\n          if (\n            socket.readyState === socket.CLOSED ||\n            socket.readyState === socket.CLOSING\n          )\n            throw new WebSocketRequestError({\n              body,\n              url: socket.url,\n              cause: new SocketClosedError({ url: socket.url }),\n            })\n\n          return socket.send(JSON.stringify(body))\n        },\n      } as Socket<WebSocket>)\n    },\n    keepAlive,\n    reconnect,\n    url,\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}