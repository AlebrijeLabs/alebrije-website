{"ast":null,"code":"import WalletService from'./wallet-service';import{Connection,PublicKey,Transaction,SystemProgram,LAMPORTS_PER_SOL}from'@solana/web3.js';import{createTransferInstruction,TOKEN_PROGRAM_ID,createBurnInstruction}from'@solana/spl-token';import{useWallet}from'../contexts/WalletContext';import{clusterApiUrl}from'@solana/web3.js';import{getAssociatedTokenAddress,getMint,getOrCreateAssociatedTokenAccount}from'@solana/spl-token';import MetricsService from'./metrics-service';// Add TokenAccountCache for efficient token account lookups\n/**\n * Simple token account cache to reduce network queries\n */const TokenAccountCache={_cache:{},_defaultTTL:5*60*1000,// 5 minutes\n/**\n   * Get a cached token account info\n   * @param {string} key Cache key in format: mintAddress:ownerAddress\n   * @returns {Object|null} Cached account info or null\n   */get(key){const entry=this._cache[key];if(!entry)return null;// Check if the entry is expired\nif(Date.now()-entry.lastChecked>entry.ttl){delete this._cache[key];return null;}return entry;},/**\n   * Set token account info in cache\n   * @param {string} key Cache key\n   * @param {Object} value Value to cache\n   * @param {number} ttl Time to live in ms\n   */set(key,value){let ttl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this._defaultTTL;this._cache[key]={...value,ttl};},/**\n   * Clear the entire cache or a specific entry\n   * @param {string} key Optional key to clear\n   */clear(key){if(key){delete this._cache[key];}else{this._cache={};}}};class TokenService{constructor(){this.connection=null;this.tokenInfo={};// Default user settings\nthis.settings={autoCreateTokenAccounts:true,// Default to enabled\nshouldShowNotifications:true};}initialize(endpoint){this.connection=new Connection(endpoint,'confirmed');}/**\n   * Update user settings\n   * @param {Object} newSettings Settings to update\n   */updateSettings(newSettings){this.settings={...this.settings,...newSettings};// Track settings changes\nif(newSettings.autoCreateTokenAccounts!==undefined){MetricsService.trackSettingChange('autoCreateTokenAccounts',newSettings.autoCreateTokenAccounts);}if(newSettings.shouldShowNotifications!==undefined){MetricsService.trackSettingChange('shouldShowNotifications',newSettings.shouldShowNotifications);}}// Get user settings\ngetSettings(){return this.settings;}async getTokenBalance(tokenAddress,walletAddress){if(!this.connection)throw new Error('Token service not initialized');if(!walletAddress)throw new Error('Wallet address is required');try{const tokenPublicKey=new PublicKey(tokenAddress);const walletPublicKey=new PublicKey(walletAddress);// Get token account info\nconst tokenAccounts=await this.connection.getParsedTokenAccountsByOwner(walletPublicKey,{mint:tokenPublicKey});// If no token accounts found, balance is 0\nif(tokenAccounts.value.length===0)return 0;// Get balance from the first token account\nconst balance=tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;return balance;}catch(error){console.error('Error getting token balance:',error);throw error;}}async transferToken(tokenAddress,fromWallet,toAddress,amount){if(!this.connection)throw new Error('Token service not initialized');try{var _this$tokenInfo$token,_window$solana;const tokenPublicKey=new PublicKey(tokenAddress);const toPublicKey=new PublicKey(toAddress);const fromPublicKey=new PublicKey(fromWallet);// Calculate tax amounts (5% total)\nconst liquidityTax=amount*0.03;// 3% for liquidity\nconst marketingTax=amount*0.01;// 1% for marketing\nconst charityTax=amount*0.01;// 1% for charity\nconst burnTax=amount*0.01;// 1% for burn\n// Calculate amount after tax\nconst amountAfterTax=amount-(liquidityTax+marketingTax+charityTax+burnTax);// Get token decimals\nconst decimals=((_this$tokenInfo$token=this.tokenInfo[tokenAddress])===null||_this$tokenInfo$token===void 0?void 0:_this$tokenInfo$token.decimals)||(await this.getTokenInfo(tokenAddress)).decimals;// Create transaction\nconst transaction=new Transaction();// Get the token account of the fromWallet address for the token\nconst fromTokenAccounts=await this.connection.getParsedTokenAccountsByOwner(fromPublicKey,{mint:tokenPublicKey});// If no token account found, throw error\nif(fromTokenAccounts.value.length===0){throw new Error('No token account found for the sender');}const fromTokenAccount=fromTokenAccounts.value[0].pubkey;// Check if recipient has a token account for this token\nlet toTokenAccount;let didCreateAccount=false;// Use cache to check if recipient has a token account\nconst cacheKey=`${tokenAddress}:${toAddress}`;const cachedAccountInfo=TokenAccountCache.get(cacheKey);if(cachedAccountInfo&&cachedAccountInfo.exists){// Use cached token account\ntoTokenAccount=new PublicKey(cachedAccountInfo.address);}else{// Try to find or create the token account\ntry{// First, check if account already exists\nconst recipientTokenAccount=await getAssociatedTokenAddress(tokenPublicKey,toPublicKey);try{// Try to get the account info (will throw if doesn't exist)\nawait this.connection.getAccountInfo(recipientTokenAccount);toTokenAccount=recipientTokenAccount;// Cache the result\nTokenAccountCache.set(cacheKey,{exists:true,address:toTokenAccount.toString(),lastChecked:Date.now()});}catch(accountError){// Account doesn't exist, check if auto-creation is enabled\nif(this.settings.autoCreateTokenAccounts){var _createAccountIx$inst;// Create the associated token account for the recipient\nconst createAccountIx=await getOrCreateAssociatedTokenAccount(this.connection,fromPublicKey,// fee payer is the sender\ntokenPublicKey,toPublicKey,false// allowOwnerOffCurve = false (standard wallet)\n);// Extract account address if created or found\nif(((_createAccountIx$inst=createAccountIx.instructions)===null||_createAccountIx$inst===void 0?void 0:_createAccountIx$inst.length)>0){// Account needed to be created\ndidCreateAccount=true;toTokenAccount=createAccountIx.address;// Add account creation instructions to transaction\ntransaction.add(...createAccountIx.instructions);}else{// Account already exists (shouldn't happen given our checks above)\ntoTokenAccount=createAccountIx.address;}// Cache the new account\nTokenAccountCache.set(cacheKey,{exists:true,address:toTokenAccount.toString(),lastChecked:Date.now()});}else{// Auto-creation is disabled, throw error\nthrow new Error('Recipient does not have a token account for this token, and automatic account creation is disabled.');}}}catch(error){if(!this.settings.autoCreateTokenAccounts){throw new Error('Recipient does not have a token account for this token. Enable automatic token account creation in settings to fix this.');}throw error;// Rethrow other errors\n}}// Create transfer instruction\nconst transferInstruction=createTransferInstruction(fromTokenAccount,toTokenAccount,fromPublicKey,Number(Math.floor(amountAfterTax*Math.pow(10,decimals))),// Convert to number for amounts\n[],TOKEN_PROGRAM_ID);// Add transfer instruction to transaction\ntransaction.add(transferInstruction);// Add burn instruction for the burn tax\nif(burnTax>0){// Create burn instruction\nconst burnInstruction=createBurnInstruction(fromTokenAccount,tokenPublicKey,fromPublicKey,Number(Math.floor(burnTax*Math.pow(10,decimals))));// Add burn instruction to transaction\ntransaction.add(burnInstruction);}// Set recent blockhash and fee payer\ntransaction.recentBlockhash=(await this.connection.getRecentBlockhash()).blockhash;transaction.feePayer=fromPublicKey;// Sign transaction using the wallet adapter\nlet signedTransaction;// For Phantom\nif((_window$solana=window.solana)!==null&&_window$solana!==void 0&&_window$solana.isPhantom){signedTransaction=await window.solana.signTransaction(transaction);}// For Solflare\nelse if(window.solflare){signedTransaction=await window.solflare.signTransaction(transaction);}else{throw new Error('No compatible wallet found');}const signature=await this.connection.sendRawTransaction(signedTransaction.serialize());// Wait for confirmation\nawait this.connection.confirmTransaction(signature);// Track successful token transfer with metrics\nMetricsService.trackTokenTransfer({tokenMint:tokenAddress,success:true,accountCreated:didCreateAccount});// If an account was created, track that specifically\nif(didCreateAccount){MetricsService.trackTokenAccountCreation({tokenMint:tokenAddress,success:true});}return{signature,status:'confirmed',amountBurned:burnTax,accountCreated:didCreateAccount};}catch(error){console.error('Error transferring token:',error);// Track failed token transfer\nMetricsService.trackTokenTransfer({tokenMint:tokenAddress,success:false,error:error.message});throw error;}}async getTokenInfo(tokenAddress){if(!this.connection)throw new Error('Token service not initialized');try{// If we already have the info cached, return it\nif(this.tokenInfo[tokenAddress]){return this.tokenInfo[tokenAddress];}const tokenPublicKey=new PublicKey(tokenAddress);const tokenInfo=await this.connection.getParsedAccountInfo(tokenPublicKey);if(!tokenInfo.value){throw new Error('Token not found');}// Parse token info\nconst parsedInfo={address:tokenAddress,decimals:tokenInfo.value.data.parsed.info.decimals,supply:tokenInfo.value.data.parsed.info.supply,name:tokenInfo.value.data.parsed.info.name||'Unknown Token',symbol:tokenInfo.value.data.parsed.info.symbol||'UNKNOWN'};// Cache the info\nthis.tokenInfo[tokenAddress]=parsedInfo;return parsedInfo;}catch(error){console.error('Error getting token info:',error);throw error;}}async getAccountTransactions(walletAddress){let limit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:10;if(!this.connection)throw new Error('Token service not initialized');if(!walletAddress)throw new Error('Wallet address is required');try{const walletPublicKey=new PublicKey(walletAddress);// Get recent transactions for the account\nconst signatures=await this.connection.getSignaturesForAddress(walletPublicKey,{limit});// Return simplified transaction data\nreturn signatures.map(sig=>({signature:sig.signature,timestamp:sig.blockTime||Date.now()/1000,status:sig.confirmationStatus||'confirmed',type:'unknown',symbol:'SOL',decimals:9,amount:0// We don't parse the amount here for simplicity\n}));}catch(error){console.error('Error getting account transactions:',error);return[];// Return empty array instead of throwing\n}}async getTokenTransactions(tokenAddress,walletAddress){let limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:10;if(!this.connection)throw new Error('Token service not initialized');if(!tokenAddress)throw new Error('Token address is required');if(!walletAddress)throw new Error('Wallet address is required');try{// Just return empty array for now to avoid errors\nreturn[];}catch(error){console.error('Error getting token transactions:',error);return[];// Return empty array instead of throwing\n}}async getNativeBalance(walletAddress){if(!this.connection)throw new Error('Token service not initialized');if(!walletAddress)throw new Error('Wallet address is required');try{const walletPublicKey=new PublicKey(walletAddress);const balance=await this.connection.getBalance(walletPublicKey);return balance/1000000000;// Convert lamports to SOL\n}catch(error){console.error('Error getting native balance:',error);throw error;}}async transferNativeSOL(fromWallet,toAddress,amount){if(!this.connection)throw new Error('Token service not initialized');try{var _window$solana2;const toPublicKey=new PublicKey(toAddress);const fromPublicKey=new PublicKey(fromWallet);// Create a simple transfer instruction\nconst transaction=new Transaction().add(SystemProgram.transfer({fromPubkey:fromPublicKey,toPubkey:toPublicKey,lamports:amount*1000000000// Convert SOL to lamports\n}));// Set recent blockhash and fee payer\ntransaction.recentBlockhash=(await this.connection.getRecentBlockhash()).blockhash;transaction.feePayer=fromPublicKey;// Sign transaction using the wallet adapter\nlet signedTransaction;// For Phantom\nif((_window$solana2=window.solana)!==null&&_window$solana2!==void 0&&_window$solana2.isPhantom){signedTransaction=await window.solana.signTransaction(transaction);}// For Solflare\nelse if(window.solflare){signedTransaction=await window.solflare.signTransaction(transaction);}else{throw new Error('No compatible wallet found');}const signature=await this.connection.sendRawTransaction(signedTransaction.serialize());// Wait for confirmation\nawait this.connection.confirmTransaction(signature);return{signature,status:'confirmed'};}catch(error){console.error('Error transferring SOL:',error);throw error;}}async burnToken(tokenAddress,ownerAddress,amount){if(!this.connection)throw new Error('Token service not initialized');try{var _this$tokenInfo$token2,_window$solana3;const tokenPublicKey=new PublicKey(tokenAddress);const ownerPublicKey=new PublicKey(ownerAddress);// Get the token account of the owner\nconst tokenAccounts=await this.connection.getParsedTokenAccountsByOwner(ownerPublicKey,{mint:tokenPublicKey});if(tokenAccounts.value.length===0){throw new Error('No token account found for the owner');}const tokenAccount=tokenAccounts.value[0].pubkey;// Get token decimals\nconst decimals=((_this$tokenInfo$token2=this.tokenInfo[tokenAddress])===null||_this$tokenInfo$token2===void 0?void 0:_this$tokenInfo$token2.decimals)||(await this.getTokenInfo(tokenAddress)).decimals;// Create burn instruction\nconst burnInstruction=createBurnInstruction(tokenAccount,tokenPublicKey,ownerPublicKey,amount*Math.pow(10,decimals));// Create transaction and add the burn instruction\nconst transaction=new Transaction().add(burnInstruction);// Set recent blockhash and fee payer\ntransaction.recentBlockhash=(await this.connection.getRecentBlockhash()).blockhash;transaction.feePayer=ownerPublicKey;// Sign transaction using the wallet adapter\nlet signedTransaction;// For Phantom\nif((_window$solana3=window.solana)!==null&&_window$solana3!==void 0&&_window$solana3.isPhantom){signedTransaction=await window.solana.signTransaction(transaction);}// For Solflare\nelse if(window.solflare){signedTransaction=await window.solflare.signTransaction(transaction);}else{throw new Error('No compatible wallet found');}const signature=await this.connection.sendRawTransaction(signedTransaction.serialize());// Wait for confirmation\nawait this.connection.confirmTransaction(signature);return{signature,status:'confirmed'};}catch(error){console.error('Error burning token:',error);throw error;}}}export default new TokenService();export const burnTokens=async(wallet,tokenAddress,amount)=>{if(!wallet.publicKey){throw new Error('Wallet not connected');}const connection=new Connection(clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK||'devnet'),'confirmed');// For SOL burning (send to a dead address)\nif(tokenAddress==='native'){// Burn address (a known unusable address)\nconst burnAddress=new PublicKey('1111111111111111111111111111111111111111111');const transaction=new Transaction().add(SystemProgram.transfer({fromPubkey:wallet.publicKey,toPubkey:burnAddress,lamports:amount*LAMPORTS_PER_SOL}));const signature=await wallet.sendTransaction(transaction,connection);await connection.confirmTransaction(signature,'confirmed');return signature;}else{// For SPL tokens\nconst mint=new PublicKey(tokenAddress);const associatedTokenAddress=await getAssociatedTokenAddress(mint,wallet.publicKey);// Get mint info to get decimals\nconst mintInfo=await getMint(connection,mint);const burnInstruction=createBurnInstruction(associatedTokenAddress,mint,wallet.publicKey,amount*Math.pow(10,mintInfo.decimals));const transaction=new Transaction().add(burnInstruction);const signature=await wallet.sendTransaction(transaction,connection);await connection.confirmTransaction(signature,'confirmed');return signature;}};","map":{"version":3,"names":["WalletService","Connection","PublicKey","Transaction","SystemProgram","LAMPORTS_PER_SOL","createTransferInstruction","TOKEN_PROGRAM_ID","createBurnInstruction","useWallet","clusterApiUrl","getAssociatedTokenAddress","getMint","getOrCreateAssociatedTokenAccount","MetricsService","TokenAccountCache","_cache","_defaultTTL","get","key","entry","Date","now","lastChecked","ttl","set","value","arguments","length","undefined","clear","TokenService","constructor","connection","tokenInfo","settings","autoCreateTokenAccounts","shouldShowNotifications","initialize","endpoint","updateSettings","newSettings","trackSettingChange","getSettings","getTokenBalance","tokenAddress","walletAddress","Error","tokenPublicKey","walletPublicKey","tokenAccounts","getParsedTokenAccountsByOwner","mint","balance","account","data","parsed","info","tokenAmount","uiAmount","error","console","transferToken","fromWallet","toAddress","amount","_this$tokenInfo$token","_window$solana","toPublicKey","fromPublicKey","liquidityTax","marketingTax","charityTax","burnTax","amountAfterTax","decimals","getTokenInfo","transaction","fromTokenAccounts","fromTokenAccount","pubkey","toTokenAccount","didCreateAccount","cacheKey","cachedAccountInfo","exists","address","recipientTokenAccount","getAccountInfo","toString","accountError","_createAccountIx$inst","createAccountIx","instructions","add","transferInstruction","Number","Math","floor","pow","burnInstruction","recentBlockhash","getRecentBlockhash","blockhash","feePayer","signedTransaction","window","solana","isPhantom","signTransaction","solflare","signature","sendRawTransaction","serialize","confirmTransaction","trackTokenTransfer","tokenMint","success","accountCreated","trackTokenAccountCreation","status","amountBurned","message","getParsedAccountInfo","parsedInfo","supply","name","symbol","getAccountTransactions","limit","signatures","getSignaturesForAddress","map","sig","timestamp","blockTime","confirmationStatus","type","getTokenTransactions","getNativeBalance","getBalance","transferNativeSOL","_window$solana2","transfer","fromPubkey","toPubkey","lamports","burnToken","ownerAddress","_this$tokenInfo$token2","_window$solana3","ownerPublicKey","tokenAccount","burnTokens","wallet","publicKey","process","env","REACT_APP_SOLANA_NETWORK","burnAddress","sendTransaction","associatedTokenAddress","mintInfo"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/token-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction } from '@solana/spl-token';\nimport { useWallet } from '../contexts/WalletContext';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { getAssociatedTokenAddress, getMint, getOrCreateAssociatedTokenAccount } from '@solana/spl-token';\nimport MetricsService from './metrics-service';\n\n// Add TokenAccountCache for efficient token account lookups\n/**\n * Simple token account cache to reduce network queries\n */\nconst TokenAccountCache = {\n  _cache: {},\n  _defaultTTL: 5 * 60 * 1000, // 5 minutes\n  \n  /**\n   * Get a cached token account info\n   * @param {string} key Cache key in format: mintAddress:ownerAddress\n   * @returns {Object|null} Cached account info or null\n   */\n  get(key) {\n    const entry = this._cache[key];\n    if (!entry) return null;\n    \n    // Check if the entry is expired\n    if (Date.now() - entry.lastChecked > entry.ttl) {\n      delete this._cache[key];\n      return null;\n    }\n    \n    return entry;\n  },\n  \n  /**\n   * Set token account info in cache\n   * @param {string} key Cache key\n   * @param {Object} value Value to cache\n   * @param {number} ttl Time to live in ms\n   */\n  set(key, value, ttl = this._defaultTTL) {\n    this._cache[key] = {\n      ...value,\n      ttl\n    };\n  },\n  \n  /**\n   * Clear the entire cache or a specific entry\n   * @param {string} key Optional key to clear\n   */\n  clear(key) {\n    if (key) {\n      delete this._cache[key];\n    } else {\n      this._cache = {};\n    }\n  }\n};\n\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n    // Default user settings\n    this.settings = {\n      autoCreateTokenAccounts: true, // Default to enabled\n      shouldShowNotifications: true\n    };\n  }\n\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint, 'confirmed');\n  }\n\n  /**\n   * Update user settings\n   * @param {Object} newSettings Settings to update\n   */\n  updateSettings(newSettings) {\n    this.settings = {\n      ...this.settings,\n      ...newSettings\n    };\n    \n    // Track settings changes\n    if (newSettings.autoCreateTokenAccounts !== undefined) {\n      MetricsService.trackSettingChange('autoCreateTokenAccounts', newSettings.autoCreateTokenAccounts);\n    }\n    \n    if (newSettings.shouldShowNotifications !== undefined) {\n      MetricsService.trackSettingChange('shouldShowNotifications', newSettings.shouldShowNotifications);\n    }\n  }\n\n  // Get user settings\n  getSettings() {\n    return this.settings;\n  }\n\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get token account info\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        walletPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      // If no token accounts found, balance is 0\n      if (tokenAccounts.value.length === 0) return 0;\n      \n      // Get balance from the first token account\n      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;\n      return balance;\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw error;\n    }\n  }\n\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Calculate tax amounts (5% total)\n      const liquidityTax = amount * 0.03; // 3% for liquidity\n      const marketingTax = amount * 0.01; // 1% for marketing\n      const charityTax = amount * 0.01; // 1% for charity\n      const burnTax = amount * 0.01; // 1% for burn\n      \n      // Calculate amount after tax\n      const amountAfterTax = amount - (liquidityTax + marketingTax + charityTax + burnTax);\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create transaction\n      const transaction = new Transaction();\n      \n      // Get the token account of the fromWallet address for the token\n      const fromTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        fromPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      // If no token account found, throw error\n      if (fromTokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the sender');\n      }\n      \n      const fromTokenAccount = fromTokenAccounts.value[0].pubkey;\n      \n      // Check if recipient has a token account for this token\n      let toTokenAccount;\n      let didCreateAccount = false;\n      \n      // Use cache to check if recipient has a token account\n      const cacheKey = `${tokenAddress}:${toAddress}`;\n      const cachedAccountInfo = TokenAccountCache.get(cacheKey);\n      \n      if (cachedAccountInfo && cachedAccountInfo.exists) {\n        // Use cached token account\n        toTokenAccount = new PublicKey(cachedAccountInfo.address);\n      } else {\n        // Try to find or create the token account\n        try {\n          // First, check if account already exists\n          const recipientTokenAccount = await getAssociatedTokenAddress(\n            tokenPublicKey,\n            toPublicKey\n          );\n          \n          try {\n            // Try to get the account info (will throw if doesn't exist)\n            await this.connection.getAccountInfo(recipientTokenAccount);\n            toTokenAccount = recipientTokenAccount;\n            \n            // Cache the result\n            TokenAccountCache.set(cacheKey, {\n              exists: true,\n              address: toTokenAccount.toString(),\n              lastChecked: Date.now()\n            });\n          } catch (accountError) {\n            // Account doesn't exist, check if auto-creation is enabled\n            if (this.settings.autoCreateTokenAccounts) {\n              // Create the associated token account for the recipient\n              const createAccountIx = await getOrCreateAssociatedTokenAccount(\n                this.connection,\n                fromPublicKey, // fee payer is the sender\n                tokenPublicKey,\n                toPublicKey,\n                false // allowOwnerOffCurve = false (standard wallet)\n              );\n              \n              // Extract account address if created or found\n              if (createAccountIx.instructions?.length > 0) {\n                // Account needed to be created\n                didCreateAccount = true;\n                toTokenAccount = createAccountIx.address;\n                \n                // Add account creation instructions to transaction\n                transaction.add(...createAccountIx.instructions);\n              } else {\n                // Account already exists (shouldn't happen given our checks above)\n                toTokenAccount = createAccountIx.address;\n              }\n              \n              // Cache the new account\n              TokenAccountCache.set(cacheKey, {\n                exists: true,\n                address: toTokenAccount.toString(),\n                lastChecked: Date.now()\n              });\n            } else {\n              // Auto-creation is disabled, throw error\n              throw new Error('Recipient does not have a token account for this token, and automatic account creation is disabled.');\n            }\n          }\n        } catch (error) {\n          if (!this.settings.autoCreateTokenAccounts) {\n            throw new Error('Recipient does not have a token account for this token. Enable automatic token account creation in settings to fix this.');\n          }\n          throw error; // Rethrow other errors\n        }\n      }\n      \n      // Create transfer instruction\n      const transferInstruction = createTransferInstruction(\n        fromTokenAccount,\n        toTokenAccount,\n        fromPublicKey,\n        Number(Math.floor(amountAfterTax * Math.pow(10, decimals))), // Convert to number for amounts\n        [],\n        TOKEN_PROGRAM_ID\n      );\n      \n      // Add transfer instruction to transaction\n      transaction.add(transferInstruction);\n      \n      // Add burn instruction for the burn tax\n      if (burnTax > 0) {\n        // Create burn instruction\n        const burnInstruction = createBurnInstruction(\n          fromTokenAccount,\n          tokenPublicKey,\n          fromPublicKey,\n          Number(Math.floor(burnTax * Math.pow(10, decimals)))\n        );\n        \n        // Add burn instruction to transaction\n        transaction.add(burnInstruction);\n      }\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      // Track successful token transfer with metrics\n      MetricsService.trackTokenTransfer({\n        tokenMint: tokenAddress,\n        success: true,\n        accountCreated: didCreateAccount\n      });\n      \n      // If an account was created, track that specifically\n      if (didCreateAccount) {\n        MetricsService.trackTokenAccountCreation({\n          tokenMint: tokenAddress,\n          success: true\n        });\n      }\n      \n      return {\n        signature,\n        status: 'confirmed',\n        amountBurned: burnTax,\n        accountCreated: didCreateAccount\n      };\n    } catch (error) {\n      console.error('Error transferring token:', error);\n      \n      // Track failed token transfer\n      MetricsService.trackTokenTransfer({\n        tokenMint: tokenAddress,\n        success: false,\n        error: error.message\n      });\n      \n      throw error;\n    }\n  }\n\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      \n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      \n      if (!tokenInfo.value) {\n        throw new Error('Token not found');\n      }\n      \n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: tokenInfo.value.data.parsed.info.decimals,\n        supply: tokenInfo.value.data.parsed.info.supply,\n        name: tokenInfo.value.data.parsed.info.name || 'Unknown Token',\n        symbol: tokenInfo.value.data.parsed.info.symbol || 'UNKNOWN'\n      };\n      \n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      \n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw error;\n    }\n  }\n\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(\n        walletPublicKey,\n        { limit }\n      );\n      \n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n\n  async transferNativeSOL(fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Create a simple transfer instruction\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: fromPublicKey,\n          toPubkey: toPublicKey,\n          lamports: amount * 1000000000 // Convert SOL to lamports\n        })\n      );\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error transferring SOL:', error);\n      throw error;\n    }\n  }\n\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n      \n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        ownerPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      \n      const tokenAccount = tokenAccounts.value[0].pubkey;\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(\n        tokenAccount,\n        tokenPublicKey,\n        ownerPublicKey,\n        amount * Math.pow(10, decimals)\n      );\n      \n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new TokenService();\n\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n\n  const connection = new Connection(\n    clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'),\n    'confirmed'\n  );\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    \n    const transaction = new Transaction().add(\n      SystemProgram.transfer({\n        fromPubkey: wallet.publicKey,\n        toPubkey: burnAddress,\n        lamports: amount * LAMPORTS_PER_SOL,\n      })\n    );\n\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(\n      mint,\n      wallet.publicKey\n    );\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    \n    const burnInstruction = createBurnInstruction(\n      associatedTokenAddress,\n      mint,\n      wallet.publicKey,\n      amount * Math.pow(10, mintInfo.decimals)\n    );\n\n    const transaction = new Transaction().add(burnInstruction);\n    \n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}