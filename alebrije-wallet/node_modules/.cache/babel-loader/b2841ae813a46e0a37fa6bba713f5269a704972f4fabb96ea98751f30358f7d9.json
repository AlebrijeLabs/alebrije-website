{"ast":null,"code":"import { RLP } from '@ethereumjs/rlp';\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1.js';\nimport { bigIntToUnpaddedBytes, bytesToBigInt, bytesToHex, bytesToInt, concatBytes, equalsBytes, hexToBytes, intToUnpaddedBytes, toBytes, utf8ToBytes, zeros } from './bytes.js';\nimport { BIGINT_0, KECCAK256_NULL, KECCAK256_RLP } from './constants.js';\nimport { assertIsBytes, assertIsHexString, assertIsString } from './helpers.js';\nimport { stripHexPrefix } from './internal.js';\n/**\n * Account class to load and maintain the  basic account objects.\n * Supports partial loading and access required for verkle with null\n * as the placeholder.\n *\n * Note: passing undefined in constructor is different from null\n * While undefined leads to default assignment, null is retained\n * to track the information not available/loaded because of partial\n * witness access\n */\nexport class Account {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   * undefined get assigned with the defaults present, but null args are retained as is\n   */\n  constructor() {\n    let nonce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BIGINT_0;\n    let balance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIGINT_0;\n    let storageRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : KECCAK256_RLP;\n    let codeHash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KECCAK256_NULL;\n    let codeSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let version = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    this._nonce = null;\n    this._balance = null;\n    this._storageRoot = null;\n    this._codeHash = null;\n    // codeSize and version is separately stored in VKT\n    this._codeSize = null;\n    this._version = null;\n    this._nonce = nonce;\n    this._balance = balance;\n    this._storageRoot = storageRoot;\n    this._codeHash = codeHash;\n    if (codeSize === null && codeHash !== null && !this.isContract()) {\n      codeSize = 0;\n    }\n    this._codeSize = codeSize;\n    this._version = version;\n    this._validate();\n  }\n  get version() {\n    if (this._version !== null) {\n      return this._version;\n    } else {\n      throw Error(`version=${this._version} not loaded`);\n    }\n  }\n  set version(_version) {\n    this._version = _version;\n  }\n  get nonce() {\n    if (this._nonce !== null) {\n      return this._nonce;\n    } else {\n      throw Error(`nonce=${this._nonce} not loaded`);\n    }\n  }\n  set nonce(_nonce) {\n    this._nonce = _nonce;\n  }\n  get balance() {\n    if (this._balance !== null) {\n      return this._balance;\n    } else {\n      throw Error(`balance=${this._balance} not loaded`);\n    }\n  }\n  set balance(_balance) {\n    this._balance = _balance;\n  }\n  get storageRoot() {\n    if (this._storageRoot !== null) {\n      return this._storageRoot;\n    } else {\n      throw Error(`storageRoot=${this._storageRoot} not loaded`);\n    }\n  }\n  set storageRoot(_storageRoot) {\n    this._storageRoot = _storageRoot;\n  }\n  get codeHash() {\n    if (this._codeHash !== null) {\n      return this._codeHash;\n    } else {\n      throw Error(`codeHash=${this._codeHash} not loaded`);\n    }\n  }\n  set codeHash(_codeHash) {\n    this._codeHash = _codeHash;\n  }\n  get codeSize() {\n    if (this._codeSize !== null) {\n      return this._codeSize;\n    } else {\n      throw Error(`codeHash=${this._codeSize} not loaded`);\n    }\n  }\n  set codeSize(_codeSize) {\n    this._codeSize = _codeSize;\n  }\n  static fromAccountData(accountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash\n    } = accountData;\n    if (nonce === null || balance === null || storageRoot === null || codeHash === null) {\n      throw Error(`Partial fields not supported in fromAccountData`);\n    }\n    return new Account(nonce !== undefined ? bytesToBigInt(toBytes(nonce)) : undefined, balance !== undefined ? bytesToBigInt(toBytes(balance)) : undefined, storageRoot !== undefined ? toBytes(storageRoot) : undefined, codeHash !== undefined ? toBytes(codeHash) : undefined);\n  }\n  static fromPartialAccountData(partialAccountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash,\n      codeSize,\n      version\n    } = partialAccountData;\n    if (nonce === null && balance === null && storageRoot === null && codeHash === null && codeSize === null && version === null) {\n      throw Error(`All partial fields null`);\n    }\n    return new Account(nonce !== undefined && nonce !== null ? bytesToBigInt(toBytes(nonce)) : nonce, balance !== undefined && balance !== null ? bytesToBigInt(toBytes(balance)) : balance, storageRoot !== undefined && storageRoot !== null ? toBytes(storageRoot) : storageRoot, codeHash !== undefined && codeHash !== null ? toBytes(codeHash) : codeHash, codeSize !== undefined && codeSize !== null ? bytesToInt(toBytes(codeSize)) : codeSize, version !== undefined && version !== null ? bytesToInt(toBytes(version)) : version);\n  }\n  static fromRlpSerializedAccount(serialized) {\n    const values = RLP.decode(serialized);\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    return this.fromValuesArray(values);\n  }\n  static fromRlpSerializedPartialAccount(serialized) {\n    const values = RLP.decode(serialized);\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    let nonce = null;\n    if (!Array.isArray(values[0])) {\n      throw new Error('Invalid partial nonce encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[0][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for nonce`);\n      }\n      if (isNotNullIndicator === 1) {\n        nonce = bytesToBigInt(values[0][1]);\n      }\n    }\n    let balance = null;\n    if (!Array.isArray(values[1])) {\n      throw new Error('Invalid partial balance encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[1][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for balance`);\n      }\n      if (isNotNullIndicator === 1) {\n        balance = bytesToBigInt(values[1][1]);\n      }\n    }\n    let storageRoot = null;\n    if (!Array.isArray(values[2])) {\n      throw new Error('Invalid partial storageRoot encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[2][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for storageRoot`);\n      }\n      if (isNotNullIndicator === 1) {\n        storageRoot = values[2][1];\n      }\n    }\n    let codeHash = null;\n    if (!Array.isArray(values[3])) {\n      throw new Error('Invalid partial codeHash encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[3][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for codeHash`);\n      }\n      if (isNotNullIndicator === 1) {\n        codeHash = values[3][1];\n      }\n    }\n    let codeSize = null;\n    if (!Array.isArray(values[4])) {\n      throw new Error('Invalid partial codeSize encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[4][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for codeSize`);\n      }\n      if (isNotNullIndicator === 1) {\n        codeSize = bytesToInt(values[4][1]);\n      }\n    }\n    let version = null;\n    if (!Array.isArray(values[5])) {\n      throw new Error('Invalid partial version encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[5][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for version`);\n      }\n      if (isNotNullIndicator === 1) {\n        version = bytesToInt(values[5][1]);\n      }\n    }\n    return this.fromPartialAccountData({\n      balance,\n      nonce,\n      storageRoot,\n      codeHash,\n      codeSize,\n      version\n    });\n  }\n  static fromValuesArray(values) {\n    const [nonce, balance, storageRoot, codeHash] = values;\n    return new Account(bytesToBigInt(nonce), bytesToBigInt(balance), storageRoot, codeHash);\n  }\n  _validate() {\n    if (this._nonce !== null && this._nonce < BIGINT_0) {\n      throw new Error('nonce must be greater than zero');\n    }\n    if (this._balance !== null && this._balance < BIGINT_0) {\n      throw new Error('balance must be greater than zero');\n    }\n    if (this._storageRoot !== null && this._storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32');\n    }\n    if (this._codeHash !== null && this._codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n    if (this._codeSize !== null && this._codeSize < BIGINT_0) {\n      throw new Error('codeSize must be greater than zero');\n    }\n  }\n  /**\n   * Returns an array of Uint8Arrays of the raw bytes for the account, in order.\n   */\n  raw() {\n    return [bigIntToUnpaddedBytes(this.nonce), bigIntToUnpaddedBytes(this.balance), this.storageRoot, this.codeHash];\n  }\n  /**\n   * Returns the RLP serialization of the account as a `Uint8Array`.\n   */\n  serialize() {\n    return RLP.encode(this.raw());\n  }\n  serializeWithPartialInfo() {\n    const partialData = [];\n    const zeroEncoded = intToUnpaddedBytes(0);\n    const oneEncoded = intToUnpaddedBytes(1);\n    if (this._nonce !== null) {\n      partialData.push([oneEncoded, bigIntToUnpaddedBytes(this._nonce)]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._balance !== null) {\n      partialData.push([oneEncoded, bigIntToUnpaddedBytes(this._balance)]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._storageRoot !== null) {\n      partialData.push([oneEncoded, this._storageRoot]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._codeHash !== null) {\n      partialData.push([oneEncoded, this._codeHash]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._codeSize !== null) {\n      partialData.push([oneEncoded, intToUnpaddedBytes(this._codeSize)]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._version !== null) {\n      partialData.push([oneEncoded, intToUnpaddedBytes(this._version)]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    return RLP.encode(partialData);\n  }\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract() {\n    if (this._codeHash === null && this._codeSize === null) {\n      throw Error(`Insufficient data as codeHash=null and codeSize=null`);\n    }\n    return this._codeHash !== null && !equalsBytes(this._codeHash, KECCAK256_NULL) || this._codeSize !== null && this._codeSize !== 0;\n  }\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty() {\n    // helpful for determination in partial accounts\n    if (this._balance !== null && this.balance !== BIGINT_0 || this._nonce === null && this.nonce !== BIGINT_0 || this._codeHash !== null && !equalsBytes(this.codeHash, KECCAK256_NULL)) {\n      return false;\n    }\n    return this.balance === BIGINT_0 && this.nonce === BIGINT_0 && equalsBytes(this.codeHash, KECCAK256_NULL);\n  }\n}\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress) {\n  try {\n    assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  assertIsHexString(hexAddress);\n  const address = stripHexPrefix(hexAddress).toLowerCase();\n  let prefix = '';\n  if (eip1191ChainId !== undefined) {\n    const chainId = bytesToBigInt(toBytes(eip1191ChainId));\n    prefix = chainId.toString() + '0x';\n  }\n  const bytes = utf8ToBytes(prefix + address);\n  const hash = bytesToHex(keccak256(bytes)).slice(2);\n  let ret = '';\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return `0x${ret}`;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from, nonce) {\n  assertIsBytes(from);\n  assertIsBytes(nonce);\n  if (bytesToBigInt(nonce) === BIGINT_0) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return keccak256(RLP.encode([from, Uint8Array.from([])])).subarray(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return keccak256(RLP.encode([from, nonce])).subarray(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (from, salt, initCode) {\n  assertIsBytes(from);\n  assertIsBytes(salt);\n  assertIsBytes(initCode);\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20');\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32');\n  }\n  const address = keccak256(concatBytes(hexToBytes('0xff'), from, salt, keccak256(initCode)));\n  return address.subarray(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey) {\n  return secp256k1.utils.isValidPrivateKey(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey) {\n  let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assertIsBytes(publicKey);\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    // Automatically checks whether point is on curve\n    try {\n      secp256k1.ProjectivePoint.fromHex(concatBytes(Uint8Array.from([4]), publicKey));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  if (!sanitize) {\n    return false;\n  }\n  try {\n    secp256k1.ProjectivePoint.fromHex(publicKey);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey) {\n  let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assertIsBytes(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64');\n  }\n  // Only take the lower 160bits of the hash\n  return keccak256(pubKey).subarray(-20);\n};\nexport const publicToAddress = pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey) {\n  assertIsBytes(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1);\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey) {\n  return publicToAddress(privateToPublic(privateKey));\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey) {\n  assertIsBytes(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1);\n  }\n  return publicKey;\n};\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function () {\n  const addressLength = 20;\n  const addr = zeros(addressLength);\n  return bytesToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress) {\n  try {\n    assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  const zeroAddr = zeroAddress();\n  return zeroAddr === hexAddress;\n};\nexport function accountBodyFromSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, storageRoot.length === 0 ? KECCAK256_RLP : storageRoot, codeHash.length === 0 ? KECCAK256_NULL : codeHash];\n}\nconst emptyUint8Arr = new Uint8Array(0);\nexport function accountBodyToSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, equalsBytes(storageRoot, KECCAK256_RLP) ? emptyUint8Arr : storageRoot, equalsBytes(codeHash, KECCAK256_NULL) ? emptyUint8Arr : codeHash];\n}\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Uint8Array-like items to represent the account\n * @returns RLP encoded version of the account\n */\nexport function accountBodyToRLP(body) {\n  let couldBeSlim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n  return RLP.encode(accountBody);\n}","map":{"version":3,"names":["RLP","keccak256","secp256k1","bigIntToUnpaddedBytes","bytesToBigInt","bytesToHex","bytesToInt","concatBytes","equalsBytes","hexToBytes","intToUnpaddedBytes","toBytes","utf8ToBytes","zeros","BIGINT_0","KECCAK256_NULL","KECCAK256_RLP","assertIsBytes","assertIsHexString","assertIsString","stripHexPrefix","Account","constructor","nonce","arguments","length","undefined","balance","storageRoot","codeHash","codeSize","version","_nonce","_balance","_storageRoot","_codeHash","_codeSize","_version","isContract","_validate","Error","fromAccountData","accountData","fromPartialAccountData","partialAccountData","fromRlpSerializedAccount","serialized","values","decode","Array","isArray","fromValuesArray","fromRlpSerializedPartialAccount","isNotNullIndicator","raw","serialize","encode","serializeWithPartialInfo","partialData","zeroEncoded","oneEncoded","push","isEmpty","isValidAddress","hexAddress","e","test","toChecksumAddress","eip1191ChainId","address","toLowerCase","prefix","chainId","toString","bytes","hash","slice","ret","i","parseInt","toUpperCase","isValidChecksumAddress","generateAddress","from","Uint8Array","subarray","generateAddress2","salt","initCode","isValidPrivate","privateKey","utils","isValidPrivateKey","isValidPublic","publicKey","sanitize","ProjectivePoint","fromHex","pubToAddress","pubKey","toRawBytes","publicToAddress","privateToPublic","fromPrivateKey","privateToAddress","importPublic","zeroAddress","addressLength","addr","isZeroAddress","zeroAddr","accountBodyFromSlim","body","emptyUint8Arr","accountBodyToSlim","accountBodyToRLP","couldBeSlim","accountBody"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@ethereumjs/util/src/account.ts"],"sourcesContent":["import { RLP } from '@ethereumjs/rlp'\nimport { keccak256 } from 'ethereum-cryptography/keccak.js'\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1.js'\n\nimport {\n  bigIntToUnpaddedBytes,\n  bytesToBigInt,\n  bytesToHex,\n  bytesToInt,\n  concatBytes,\n  equalsBytes,\n  hexToBytes,\n  intToUnpaddedBytes,\n  toBytes,\n  utf8ToBytes,\n  zeros,\n} from './bytes.js'\nimport { BIGINT_0, KECCAK256_NULL, KECCAK256_RLP } from './constants.js'\nimport { assertIsBytes, assertIsHexString, assertIsString } from './helpers.js'\nimport { stripHexPrefix } from './internal.js'\n\nimport type { BigIntLike, BytesLike, PrefixedHexString } from './types.js'\n\nexport interface AccountData {\n  nonce?: BigIntLike\n  balance?: BigIntLike\n  storageRoot?: BytesLike\n  codeHash?: BytesLike\n}\n\nexport interface PartialAccountData {\n  nonce?: BigIntLike | null\n  balance?: BigIntLike | null\n  storageRoot?: BytesLike | null\n  codeHash?: BytesLike | null\n  codeSize?: BigIntLike | null\n  version?: BigIntLike | null\n}\n\nexport type AccountBodyBytes = [Uint8Array, Uint8Array, Uint8Array, Uint8Array]\n\n/**\n * Account class to load and maintain the  basic account objects.\n * Supports partial loading and access required for verkle with null\n * as the placeholder.\n *\n * Note: passing undefined in constructor is different from null\n * While undefined leads to default assignment, null is retained\n * to track the information not available/loaded because of partial\n * witness access\n */\nexport class Account {\n  _nonce: bigint | null = null\n  _balance: bigint | null = null\n  _storageRoot: Uint8Array | null = null\n  _codeHash: Uint8Array | null = null\n  // codeSize and version is separately stored in VKT\n  _codeSize: number | null = null\n  _version: number | null = null\n\n  get version() {\n    if (this._version !== null) {\n      return this._version\n    } else {\n      throw Error(`version=${this._version} not loaded`)\n    }\n  }\n  set version(_version: number) {\n    this._version = _version\n  }\n\n  get nonce() {\n    if (this._nonce !== null) {\n      return this._nonce\n    } else {\n      throw Error(`nonce=${this._nonce} not loaded`)\n    }\n  }\n  set nonce(_nonce: bigint) {\n    this._nonce = _nonce\n  }\n\n  get balance() {\n    if (this._balance !== null) {\n      return this._balance\n    } else {\n      throw Error(`balance=${this._balance} not loaded`)\n    }\n  }\n  set balance(_balance: bigint) {\n    this._balance = _balance\n  }\n\n  get storageRoot() {\n    if (this._storageRoot !== null) {\n      return this._storageRoot\n    } else {\n      throw Error(`storageRoot=${this._storageRoot} not loaded`)\n    }\n  }\n  set storageRoot(_storageRoot: Uint8Array) {\n    this._storageRoot = _storageRoot\n  }\n\n  get codeHash() {\n    if (this._codeHash !== null) {\n      return this._codeHash\n    } else {\n      throw Error(`codeHash=${this._codeHash} not loaded`)\n    }\n  }\n  set codeHash(_codeHash: Uint8Array) {\n    this._codeHash = _codeHash\n  }\n\n  get codeSize() {\n    if (this._codeSize !== null) {\n      return this._codeSize\n    } else {\n      throw Error(`codeHash=${this._codeSize} not loaded`)\n    }\n  }\n  set codeSize(_codeSize: number) {\n    this._codeSize = _codeSize\n  }\n\n  static fromAccountData(accountData: AccountData) {\n    const { nonce, balance, storageRoot, codeHash } = accountData\n    if (nonce === null || balance === null || storageRoot === null || codeHash === null) {\n      throw Error(`Partial fields not supported in fromAccountData`)\n    }\n\n    return new Account(\n      nonce !== undefined ? bytesToBigInt(toBytes(nonce)) : undefined,\n      balance !== undefined ? bytesToBigInt(toBytes(balance)) : undefined,\n      storageRoot !== undefined ? toBytes(storageRoot) : undefined,\n      codeHash !== undefined ? toBytes(codeHash) : undefined\n    )\n  }\n\n  static fromPartialAccountData(partialAccountData: PartialAccountData) {\n    const { nonce, balance, storageRoot, codeHash, codeSize, version } = partialAccountData\n\n    if (\n      nonce === null &&\n      balance === null &&\n      storageRoot === null &&\n      codeHash === null &&\n      codeSize === null &&\n      version === null\n    ) {\n      throw Error(`All partial fields null`)\n    }\n\n    return new Account(\n      nonce !== undefined && nonce !== null ? bytesToBigInt(toBytes(nonce)) : nonce,\n      balance !== undefined && balance !== null ? bytesToBigInt(toBytes(balance)) : balance,\n      storageRoot !== undefined && storageRoot !== null ? toBytes(storageRoot) : storageRoot,\n      codeHash !== undefined && codeHash !== null ? toBytes(codeHash) : codeHash,\n      codeSize !== undefined && codeSize !== null ? bytesToInt(toBytes(codeSize)) : codeSize,\n      version !== undefined && version !== null ? bytesToInt(toBytes(version)) : version\n    )\n  }\n\n  public static fromRlpSerializedAccount(serialized: Uint8Array) {\n    const values = RLP.decode(serialized) as Uint8Array[]\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array')\n    }\n\n    return this.fromValuesArray(values)\n  }\n\n  public static fromRlpSerializedPartialAccount(serialized: Uint8Array) {\n    const values = RLP.decode(serialized) as Uint8Array[][]\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array')\n    }\n\n    let nonce = null\n    if (!Array.isArray(values[0])) {\n      throw new Error('Invalid partial nonce encoding. Must be array')\n    } else {\n      const isNotNullIndicator = bytesToInt(values[0][0])\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for nonce`)\n      }\n      if (isNotNullIndicator === 1) {\n        nonce = bytesToBigInt(values[0][1])\n      }\n    }\n\n    let balance = null\n    if (!Array.isArray(values[1])) {\n      throw new Error('Invalid partial balance encoding. Must be array')\n    } else {\n      const isNotNullIndicator = bytesToInt(values[1][0])\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for balance`)\n      }\n      if (isNotNullIndicator === 1) {\n        balance = bytesToBigInt(values[1][1])\n      }\n    }\n\n    let storageRoot = null\n    if (!Array.isArray(values[2])) {\n      throw new Error('Invalid partial storageRoot encoding. Must be array')\n    } else {\n      const isNotNullIndicator = bytesToInt(values[2][0])\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for storageRoot`)\n      }\n      if (isNotNullIndicator === 1) {\n        storageRoot = values[2][1]\n      }\n    }\n\n    let codeHash = null\n    if (!Array.isArray(values[3])) {\n      throw new Error('Invalid partial codeHash encoding. Must be array')\n    } else {\n      const isNotNullIndicator = bytesToInt(values[3][0])\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for codeHash`)\n      }\n      if (isNotNullIndicator === 1) {\n        codeHash = values[3][1]\n      }\n    }\n\n    let codeSize = null\n    if (!Array.isArray(values[4])) {\n      throw new Error('Invalid partial codeSize encoding. Must be array')\n    } else {\n      const isNotNullIndicator = bytesToInt(values[4][0])\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for codeSize`)\n      }\n      if (isNotNullIndicator === 1) {\n        codeSize = bytesToInt(values[4][1])\n      }\n    }\n\n    let version = null\n    if (!Array.isArray(values[5])) {\n      throw new Error('Invalid partial version encoding. Must be array')\n    } else {\n      const isNotNullIndicator = bytesToInt(values[5][0])\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for version`)\n      }\n      if (isNotNullIndicator === 1) {\n        version = bytesToInt(values[5][1])\n      }\n    }\n\n    return this.fromPartialAccountData({ balance, nonce, storageRoot, codeHash, codeSize, version })\n  }\n\n  public static fromValuesArray(values: Uint8Array[]) {\n    const [nonce, balance, storageRoot, codeHash] = values\n\n    return new Account(bytesToBigInt(nonce), bytesToBigInt(balance), storageRoot, codeHash)\n  }\n\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   * undefined get assigned with the defaults present, but null args are retained as is\n   */\n  constructor(\n    nonce: bigint | null = BIGINT_0,\n    balance: bigint | null = BIGINT_0,\n    storageRoot: Uint8Array | null = KECCAK256_RLP,\n    codeHash: Uint8Array | null = KECCAK256_NULL,\n    codeSize: number | null = null,\n    version: number | null = 0\n  ) {\n    this._nonce = nonce\n    this._balance = balance\n    this._storageRoot = storageRoot\n    this._codeHash = codeHash\n\n    if (codeSize === null && codeHash !== null && !this.isContract()) {\n      codeSize = 0\n    }\n    this._codeSize = codeSize\n    this._version = version\n\n    this._validate()\n  }\n\n  private _validate() {\n    if (this._nonce !== null && this._nonce < BIGINT_0) {\n      throw new Error('nonce must be greater than zero')\n    }\n    if (this._balance !== null && this._balance < BIGINT_0) {\n      throw new Error('balance must be greater than zero')\n    }\n    if (this._storageRoot !== null && this._storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32')\n    }\n    if (this._codeHash !== null && this._codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32')\n    }\n    if (this._codeSize !== null && this._codeSize < BIGINT_0) {\n      throw new Error('codeSize must be greater than zero')\n    }\n  }\n\n  /**\n   * Returns an array of Uint8Arrays of the raw bytes for the account, in order.\n   */\n  raw(): Uint8Array[] {\n    return [\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.balance),\n      this.storageRoot,\n      this.codeHash,\n    ]\n  }\n\n  /**\n   * Returns the RLP serialization of the account as a `Uint8Array`.\n   */\n  serialize(): Uint8Array {\n    return RLP.encode(this.raw())\n  }\n\n  serializeWithPartialInfo(): Uint8Array {\n    const partialData = []\n    const zeroEncoded = intToUnpaddedBytes(0)\n    const oneEncoded = intToUnpaddedBytes(1)\n\n    if (this._nonce !== null) {\n      partialData.push([oneEncoded, bigIntToUnpaddedBytes(this._nonce)])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._balance !== null) {\n      partialData.push([oneEncoded, bigIntToUnpaddedBytes(this._balance)])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._storageRoot !== null) {\n      partialData.push([oneEncoded, this._storageRoot])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._codeHash !== null) {\n      partialData.push([oneEncoded, this._codeHash])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._codeSize !== null) {\n      partialData.push([oneEncoded, intToUnpaddedBytes(this._codeSize)])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._version !== null) {\n      partialData.push([oneEncoded, intToUnpaddedBytes(this._version)])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    return RLP.encode(partialData)\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract(): boolean {\n    if (this._codeHash === null && this._codeSize === null) {\n      throw Error(`Insufficient data as codeHash=null and codeSize=null`)\n    }\n    return (\n      (this._codeHash !== null && !equalsBytes(this._codeHash, KECCAK256_NULL)) ||\n      (this._codeSize !== null && this._codeSize !== 0)\n    )\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty(): boolean {\n    // helpful for determination in partial accounts\n    if (\n      (this._balance !== null && this.balance !== BIGINT_0) ||\n      (this._nonce === null && this.nonce !== BIGINT_0) ||\n      (this._codeHash !== null && !equalsBytes(this.codeHash, KECCAK256_NULL))\n    ) {\n      return false\n    }\n\n    return (\n      this.balance === BIGINT_0 &&\n      this.nonce === BIGINT_0 &&\n      equalsBytes(this.codeHash, KECCAK256_NULL)\n    )\n  }\n}\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress: string): hexAddress is PrefixedHexString {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress)\n}\n\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike\n): PrefixedHexString {\n  assertIsHexString(hexAddress)\n  const address = stripHexPrefix(hexAddress).toLowerCase()\n\n  let prefix = ''\n  if (eip1191ChainId !== undefined) {\n    const chainId = bytesToBigInt(toBytes(eip1191ChainId))\n    prefix = chainId.toString() + '0x'\n  }\n\n  const bytes = utf8ToBytes(prefix + address)\n  const hash = bytesToHex(keccak256(bytes)).slice(2)\n  let ret = ''\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase()\n    } else {\n      ret += address[i]\n    }\n  }\n\n  return `0x${ret}`\n}\n\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike\n): boolean {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress\n}\n\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from: Uint8Array, nonce: Uint8Array): Uint8Array {\n  assertIsBytes(from)\n  assertIsBytes(nonce)\n\n  if (bytesToBigInt(nonce) === BIGINT_0) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return keccak256(RLP.encode([from, Uint8Array.from([])])).subarray(-20)\n  }\n\n  // Only take the lower 160bits of the hash\n  return keccak256(RLP.encode([from, nonce])).subarray(-20)\n}\n\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (\n  from: Uint8Array,\n  salt: Uint8Array,\n  initCode: Uint8Array\n): Uint8Array {\n  assertIsBytes(from)\n  assertIsBytes(salt)\n  assertIsBytes(initCode)\n\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20')\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32')\n  }\n\n  const address = keccak256(concatBytes(hexToBytes('0xff'), from, salt, keccak256(initCode)))\n\n  return address.subarray(-20)\n}\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey: Uint8Array): boolean {\n  return secp256k1.utils.isValidPrivateKey(privateKey)\n}\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey: Uint8Array, sanitize: boolean = false): boolean {\n  assertIsBytes(publicKey)\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    // Automatically checks whether point is on curve\n    try {\n      secp256k1.ProjectivePoint.fromHex(concatBytes(Uint8Array.from([4]), publicKey))\n      return true\n    } catch (e) {\n      return false\n    }\n  }\n\n  if (!sanitize) {\n    return false\n  }\n\n  try {\n    secp256k1.ProjectivePoint.fromHex(publicKey)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey: Uint8Array, sanitize: boolean = false): Uint8Array {\n  assertIsBytes(pubKey)\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1)\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64')\n  }\n  // Only take the lower 160bits of the hash\n  return keccak256(pubKey).subarray(-20)\n}\nexport const publicToAddress = pubToAddress\n\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey: Uint8Array): Uint8Array {\n  assertIsBytes(privateKey)\n  // skip the type flag and use the X, Y points\n  return secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1)\n}\n\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey: Uint8Array): Uint8Array {\n  return publicToAddress(privateToPublic(privateKey))\n}\n\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey: Uint8Array): Uint8Array {\n  assertIsBytes(publicKey)\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1)\n  }\n  return publicKey\n}\n\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function (): string {\n  const addressLength = 20\n  const addr = zeros(addressLength)\n  return bytesToHex(addr)\n}\n\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  const zeroAddr = zeroAddress()\n  return zeroAddr === hexAddress\n}\n\nexport function accountBodyFromSlim(body: AccountBodyBytes) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    storageRoot.length === 0 ? KECCAK256_RLP : storageRoot,\n    codeHash.length === 0 ? KECCAK256_NULL : codeHash,\n  ]\n}\n\nconst emptyUint8Arr = new Uint8Array(0)\nexport function accountBodyToSlim(body: AccountBodyBytes) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    equalsBytes(storageRoot, KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n    equalsBytes(codeHash, KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n  ]\n}\n\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Uint8Array-like items to represent the account\n * @returns RLP encoded version of the account\n */\nexport function accountBodyToRLP(body: AccountBodyBytes, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body\n  return RLP.encode(accountBody)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}