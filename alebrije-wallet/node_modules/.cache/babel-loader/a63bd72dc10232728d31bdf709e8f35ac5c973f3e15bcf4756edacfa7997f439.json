{"ast":null,"code":"\"use strict\";\n\nfunction e(e) {\n  return e && \"object\" == typeof e && \"default\" in e ? e.default : e;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar t = require(\"@keystonehq/bc-ur-registry-sol\"),\n  r = require(\"@keystonehq/sdk\"),\n  s = e(r),\n  n = require(\"@keystonehq/bc-ur-registry\"),\n  i = e(require(\"bs58\")),\n  a = require(\"uuid\"),\n  o = require(\"@solana/web3.js\");\nclass c {\n  constructor() {\n    if (this.keystoneSDK = void 0, this.readCryptoMultiAccounts = async () => {\n      const e = await this.keystoneSDK.read([r.SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS], {\n        title: \"Sync Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n        renderInitial: {\n          walletMode: \"Solflare\",\n          link: \"https://keyst.one/defi\"\n        },\n        URTypeErrorMessage: \"The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again\"\n      });\n      if (e.status === r.ReadStatus.success) {\n        const {\n          result: t\n        } = e;\n        return n.CryptoMultiAccounts.fromCBOR(t.cbor);\n      }\n      throw new Error(\"Reading canceled\");\n    }, this.requestSignature = async (e, s, n) => {\n      if ((await this.keystoneSDK.play(e.toUR(), {\n        hasNext: !0,\n        title: s,\n        description: n,\n        maxFragmentLength: 400\n      })) === r.PlayStatus.canceled) throw new Error(\"#ktek_error[play-cancel]: play canceled\");\n      const i = await this.keystoneSDK.read([r.SupportedResult.UR_SOL_SIGNATURE], {\n        title: \"Scan Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\"\n      });\n      if (i.status === r.ReadStatus.canceled) throw new Error(\"#ktek_error[read-cancel]: read signature canceled\");\n      return t.SolSignature.fromCBOR(i.result.cbor);\n    }, c.instance) return c.instance;\n    s.bootstrap(), this.keystoneSDK = s.getSdk(), c.instance = this;\n  }\n}\nclass u {\n  constructor() {\n    this.getInteraction = () => {\n      throw new Error(\"KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.\");\n    }, this.type = \"QR Hardware Wallet Device\", this.requestSignature = async (e, t, r, s) => {\n      const n = await this.getInteraction().requestSignature(t, r, s),\n        i = n.getRequestId(),\n        o = n.getSignature();\n      if (i && a.stringify(i) !== e) throw new Error(\"KeystoneError#invalid_data: read signature error: mismatched requestId\");\n      return o;\n    }, this.getName = () => this.name, this.keys = [], this.name = \"QR Hardware\", this.initialized = !1, this.device = \"\", this.xfp = \"\";\n  }\n  async readKeyring() {\n    const e = await this.getInteraction().readCryptoMultiAccounts();\n    this.syncKeyring(e);\n  }\n  syncKeyring(e) {\n    var t;\n    const r = e.getKeys();\n    this.device = e.getDevice(), this.xfp = null === (t = e.getKeys()[0].getOrigin().getSourceFingerprint()) || void 0 === t ? void 0 : t.toString(\"hex\"), this.name = e.getKeys()[0].getName(), this.keys = r.map((e, t) => ({\n      hdPath: e.getOrigin().getPath(),\n      pubKey: i.encode(e.getKey()),\n      index: t\n    })), this.initialized = !0;\n  }\n  syncKeyringData(_ref) {\n    let {\n      xfp: e,\n      keys: t,\n      name: r = \"QR Hardware\",\n      device: s\n    } = _ref;\n    this.xfp = e, this.name = r, this.keys = t, this.device = s, this.initialized = !0;\n  }\n  getAccounts() {\n    return this.initialized ? this.keys : [];\n  }\n  async signTransaction(e, r) {\n    return await this._getSignature(e, Buffer.from(r), t.SignType.Transaction);\n  }\n  async signMessage(e, r) {\n    return await this._getSignature(e, Buffer.from(r), t.SignType.Message);\n  }\n  async createSignature(e, r) {\n    try {\n      const s = o.Message.from(r);\n      if (o.Transaction.populate(s, [])) return this._getSignature(e, Buffer.from(r), t.SignType.Transaction);\n    } catch (e) {\n      console.error(e);\n    }\n    return this.signMessage(e, r);\n  }\n  async _getSignature(e, r, s) {\n    const n = a.v4(),\n      i = this.getAccounts().find(t => t.pubKey == e),\n      o = t.SolSignRequest.constructSOLRequest(r, i.hdPath, this.xfp, s, n);\n    return this.requestSignature(n, o, \"Scan with your Keystone\", 'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature');\n  }\n}\nu.type = \"QR Hardware Wallet Device\";\nclass y extends u {\n  constructor() {\n    super(), this.getInteraction = () => new c();\n  }\n  static getEmptyKeyring() {\n    return new y();\n  }\n}\ny.type = u.type, exports.BaseKeyring = u, exports.DefaultKeyring = y;","map":{"version":3,"names":["c","constructor","keystoneSDK","readCryptoMultiAccounts","e","read","r","SupportedResult","UR_CRYPTO_MULTI_ACCOUNTS","title","description","renderInitial","walletMode","link","URTypeErrorMessage","status","ReadStatus","success","result","t","n","CryptoMultiAccounts","fromCBOR","cbor","Error","requestSignature","s","play","toUR","hasNext","maxFragmentLength","PlayStatus","canceled","i","UR_SOL_SIGNATURE","SolSignature","instance","bootstrap","getSdk","u","getInteraction","type","getRequestId","o","getSignature","a","stringify","getName","name","keys","initialized","device","xfp","readKeyring","syncKeyring","getKeys","getDevice","getOrigin","getSourceFingerprint","toString","map","hdPath","getPath","pubKey","encode","getKey","index","syncKeyringData","_ref","getAccounts","signTransaction","_getSignature","Buffer","from","SignType","Transaction","signMessage","Message","createSignature","populate","console","error","v4","find","SolSignRequest","constructSOLRequest","y","getEmptyKeyring","exports","BaseKeyring","DefaultKeyring"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@keystonehq/sol-keyring/src/DefaultInteractionProvider.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@keystonehq/sol-keyring/src/BaseKeyring.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@keystonehq/sol-keyring/src/DefaultKeyring.ts"],"sourcesContent":["import { SolSignature, SolSignRequest } from \"@keystonehq/bc-ur-registry-sol\";\nimport { InteractionProvider } from \"./InteractionProvider\";\nimport sdk, { PlayStatus, ReadStatus, SupportedResult } from \"@keystonehq/sdk\";\nimport { CryptoMultiAccounts } from \"@keystonehq/bc-ur-registry\";\n\nexport class DefaultInteractionProvider implements InteractionProvider {\n  private static instance;\n  private keystoneSDK = undefined;\n\n  constructor() {\n    if (DefaultInteractionProvider.instance) {\n      return DefaultInteractionProvider.instance;\n    }\n    sdk.bootstrap();\n    this.keystoneSDK = sdk.getSdk();\n    DefaultInteractionProvider.instance = this;\n  }\n\n  public readCryptoMultiAccounts = async () => {\n    const decodedResult = await this.keystoneSDK.read(\n      [SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS],\n      {\n        title: \"Sync Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n        renderInitial: {\n          walletMode: \"Solflare\",\n          link: \"https://keyst.one/defi\",\n        },\n        URTypeErrorMessage:\n          \"The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again\",\n      }\n    );\n    if (decodedResult.status === ReadStatus.success) {\n      const { result } = decodedResult;\n      return CryptoMultiAccounts.fromCBOR(result.cbor);\n    } else {\n      throw new Error(\"Reading canceled\");\n    }\n  };\n\n  public requestSignature = async (\n    solSignRequest: SolSignRequest,\n    requestTitle?: string,\n    requestDescription?: string\n  ) => {\n    const status = await this.keystoneSDK.play(solSignRequest.toUR(), {\n      hasNext: true,\n      title: requestTitle,\n      description: requestDescription,\n      maxFragmentLength: 400,\n    });\n    if (status === PlayStatus.canceled)\n      throw new Error(\"#ktek_error[play-cancel]: play canceled\");\n    const result = await this.keystoneSDK.read(\n      [SupportedResult.UR_SOL_SIGNATURE],\n      {\n        title: \"Scan Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n      }\n    );\n    if (result.status === ReadStatus.canceled) {\n      throw new Error(\"#ktek_error[read-cancel]: read signature canceled\");\n    } else {\n      return SolSignature.fromCBOR(result.result.cbor);\n    }\n  };\n}\n","import bs58 from \"bs58\";\nimport * as uuid from \"uuid\";\nimport { Message, Transaction } from \"@solana/web3.js\";\nimport { InteractionProvider } from \"./InteractionProvider\";\nimport { CryptoMultiAccounts } from \"@keystonehq/bc-ur-registry\";\nimport { SolSignRequest, SignType } from \"@keystonehq/bc-ur-registry-sol\";\n\nconst keyringType = \"QR Hardware Wallet Device\";\n\nexport interface HDKey {\n  hdPath: string;\n  pubKey: string;\n  index: number;\n}\n\ninterface KeyringInitData {\n  xfp: string;\n  keys: HDKey[];\n  name?: string;\n  device?: string;\n}\n\nexport class BaseKeyring {\n  getInteraction = (): InteractionProvider => {\n    throw new Error(\n      \"KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.\"\n    );\n  };\n  static type = keyringType;\n  protected xfp: string;\n  protected type = keyringType;\n  protected initialized: boolean;\n  protected keys: HDKey[];\n  protected name: string;\n  protected device: string;\n\n  constructor() {\n    //common props\n    this.keys = [];\n    this.name = \"QR Hardware\";\n    this.initialized = false;\n    this.device = \"\";\n    this.xfp = \"\";\n  }\n\n  protected requestSignature = async (\n    _requestId: string,\n    signRequest: SolSignRequest,\n    requestTitle?: string,\n    requestDescription?: string\n  ): Promise<Buffer> => {\n    const solSignature = await this.getInteraction().requestSignature(\n      signRequest,\n      requestTitle,\n      requestDescription\n    );\n    const requestIdBuffer = solSignature.getRequestId();\n    const signature = solSignature.getSignature();\n    if (requestIdBuffer) {\n      const requestId = uuid.stringify(requestIdBuffer);\n      if (requestId !== _requestId) {\n        throw new Error(\n          \"KeystoneError#invalid_data: read signature error: mismatched requestId\"\n        );\n      }\n    }\n    return signature;\n  };\n\n  //initial read\n  async readKeyring(): Promise<void> {\n    const result = await this.getInteraction().readCryptoMultiAccounts();\n    this.syncKeyring(result);\n  }\n\n  public syncKeyring(data: CryptoMultiAccounts): void {\n    const keys = data.getKeys();\n    this.device = data.getDevice();\n    this.xfp = data\n      .getKeys()[0]\n      .getOrigin()\n      .getSourceFingerprint()\n      ?.toString(\"hex\");\n    this.name = data.getKeys()[0].getName();\n    this.keys = keys.map((each, index) => ({\n      hdPath: each.getOrigin().getPath(),\n      pubKey: bs58.encode(each.getKey()),\n      index,\n    }));\n    this.initialized = true;\n  }\n\n  public syncKeyringData({\n    xfp,\n    keys,\n    name = \"QR Hardware\",\n    device,\n  }: KeyringInitData): void {\n    this.xfp = xfp;\n    this.name = name;\n    this.keys = keys;\n    this.device = device;\n    this.initialized = true;\n  }\n\n  public getName = (): string => {\n    return this.name;\n  };\n\n  getAccounts() {\n    if (!this.initialized) {\n      return [];\n    }\n    return this.keys;\n  }\n\n  async signTransaction(pubKey: string, txHex: Uint8Array): Promise<Uint8Array> {\n    const signature = await this._getSignature(\n      pubKey,\n      Buffer.from(txHex),\n      SignType.Transaction\n    );\n    return signature;\n  }\n\n  async signMessage(\n    pubKey: string,\n    messageHex: Uint8Array\n  ): Promise<Uint8Array> {\n    return await this._getSignature(\n      pubKey,\n      Buffer.from(messageHex),\n      SignType.Message\n    );\n  }\n\n  async createSignature(\n    pubKey: string,\n    messageHex: Uint8Array\n  ): Promise<Uint8Array> {\n    try {\n      const messageInstance = Message.from(messageHex);\n      const transaction = Transaction.populate(messageInstance, []);\n      if (transaction) {\n        return this._getSignature(\n          pubKey,\n          Buffer.from(messageHex),\n          SignType.Transaction\n        );\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return this.signMessage(pubKey, messageHex);\n  }\n\n  async _getSignature(\n    pubKey: string,\n    messageHex: Buffer,\n    signType\n  ): Promise<Buffer> {\n    const requestId = uuid.v4();\n    const account = this.getAccounts().find(\n      (account) => account.pubKey == pubKey\n    );\n    const solSignRequest = SolSignRequest.constructSOLRequest(\n      messageHex,\n      account.hdPath,\n      this.xfp,\n      signType,\n      requestId\n    );\n    return this.requestSignature(\n      requestId,\n      solSignRequest,\n      \"Scan with your Keystone\",\n      'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature'\n    );\n  }\n}\n","import { DefaultInteractionProvider } from \"./DefaultInteractionProvider\";\nimport { BaseKeyring } from \"./BaseKeyring\";\n\nexport class DefaultKeyring extends BaseKeyring {\n  static type = BaseKeyring.type;\n\n  static getEmptyKeyring(): DefaultKeyring {\n    return new DefaultKeyring();\n  }\n\n  constructor() {\n    super();\n  }\n\n  getInteraction = () => {\n    return new DefaultInteractionProvider();\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;MAKaA,CAAA;EAIXC,YAAA;IACE,IAHM,KAAAC,WAAA,QAAc,GAWf,KAAAC,uBAAA,GAA0B;MAC/B,MAAMC,CAAA,SAAsB,KAAKF,WAAA,CAAYG,IAAA,CAC3C,CAACC,CAAA,CAAAC,eAAA,CAAgBC,wBAAA,GACjB;QACEC,KAAA,EAAO;QACPC,WAAA,EAAa;QACbC,aAAA,EAAe;UACbC,UAAA,EAAY;UACZC,IAAA,EAAM;QAAA;QAERC,kBAAA,EACE;MAAA;MAGN,IAAIV,CAAA,CAAcW,MAAA,KAAWT,CAAA,CAAAU,UAAA,CAAWC,OAAA,EAAS;QAC/C;UAAMC,MAAA,EAAEC;QAAA,IAAWf,CAAA;QACnB,OAAOgB,CAAA,CAAAC,mBAAA,CAAoBC,QAAA,CAASH,CAAA,CAAOI,IAAA;MAAA;MAE3C,MAAM,IAAIC,KAAA,CAAM;IAAA,GAIb,KAAAC,gBAAA,GAAmB,OACxBrB,CAAA,EACAsB,CAAA,EACAN,CAAA;MAQA,WANqB,KAAKlB,WAAA,CAAYyB,IAAA,CAAKvB,CAAA,CAAewB,IAAA,IAAQ;QAChEC,OAAA,GAAS;QACTpB,KAAA,EAAOiB,CAAA;QACPhB,WAAA,EAAaU,CAAA;QACbU,iBAAA,EAAmB;MAAA,QAENxB,CAAA,CAAAyB,UAAA,CAAWC,QAAA,EACxB,MAAM,IAAIR,KAAA,CAAM;MAClB,MAAMS,CAAA,SAAe,KAAK/B,WAAA,CAAYG,IAAA,CACpC,CAACC,CAAA,CAAAC,eAAA,CAAgB2B,gBAAA,GACjB;QACEzB,KAAA,EAAO;QACPC,WAAA,EAAa;MAAA;MAGjB,IAAIuB,CAAA,CAAOlB,MAAA,KAAWT,CAAA,CAAAU,UAAA,CAAWgB,QAAA,EAC/B,MAAM,IAAIR,KAAA,CAAM;MAEhB,OAAOL,CAAA,CAAAgB,YAAA,CAAab,QAAA,CAASW,CAAA,CAAOf,MAAA,CAAOK,IAAA;IAAA,GArDzCvB,CAAA,CAA2BoC,QAAA,EAC7B,OAAOpC,CAAA,CAA2BoC,QAAA;IAEpCV,CAAA,CAAIW,SAAA,IACJ,KAAKnC,WAAA,GAAcwB,CAAA,CAAIY,MAAA,IACvBtC,CAAA,CAA2BoC,QAAA,GAAW;EAAA;AAAA;ACO1C,MAAaG,CAAA;EAcXtC,YAAA;IAbA,KAAAuC,cAAA,GAAiB;MACf,MAAM,IAAIhB,KAAA,CACR;IAAA,GAKM,KAAAiB,IAAA,GAvBQ,6BAsCR,KAAAhB,gBAAA,GAAmB,OAC3BrB,CAAA,EACAe,CAAA,EACAb,CAAA,EACAoB,CAAA;MAEA,MAAMN,CAAA,SAAqB,KAAKoB,cAAA,GAAiBf,gBAAA,CAC/CN,CAAA,EACAb,CAAA,EACAoB,CAAA;QAEIO,CAAA,GAAkBb,CAAA,CAAasB,YAAA;QAC/BC,CAAA,GAAYvB,CAAA,CAAawB,YAAA;MAC/B,IAAIX,CAAA,IACgBY,CAAA,CAAAC,SAAA,CAAeb,CAAA,MACf7B,CAAA,EAChB,MAAM,IAAIoB,KAAA,CACR;MAIN,OAAOmB,CAAA;IAAA,GAuCF,KAAAI,OAAA,GAAU,MACR,KAAKC,IAAA,EApEZ,KAAKC,IAAA,GAAO,IACZ,KAAKD,IAAA,GAAO,eACZ,KAAKE,WAAA,IAAc,GACnB,KAAKC,MAAA,GAAS,IACd,KAAKC,GAAA,GAAM;EAAA;EA4Bb,MAAAC,YAAA;IACE,MAAMjD,CAAA,SAAe,KAAKoC,cAAA,GAAiBrC,uBAAA;IAC3C,KAAKmD,WAAA,CAAYlD,CAAA;EAAA;EAGZkD,YAAYlD,CAAA;IAAA,IAAAe,CAAA;IACjB,MAAMb,CAAA,GAAOF,CAAA,CAAKmD,OAAA;IAClB,KAAKJ,MAAA,GAAS/C,CAAA,CAAKoD,SAAA,IACnB,KAAKJ,GAAA,aAAGjC,CAAA,GAAGf,CAAA,CACRmD,OAAA,GAAU,GACVE,SAAA,GACAC,oBAAA,kBAAsBvC,CAAA,YAHdA,CAAA,CAIPwC,QAAA,CAAS,QACb,KAAKX,IAAA,GAAO5C,CAAA,CAAKmD,OAAA,GAAU,GAAGR,OAAA,IAC9B,KAAKE,IAAA,GAAO3C,CAAA,CAAKsD,GAAA,CAAI,CAACxD,CAAA,EAAMe,CAAA;MAC1B0C,MAAA,EAAQzD,CAAA,CAAKqD,SAAA,GAAYK,OAAA;MACzBC,MAAA,EAAQ9B,CAAA,CAAK+B,MAAA,CAAO5D,CAAA,CAAK6D,MAAA;MACzBC,KAAA,EAAA/C;IAAA,KAEF,KAAK+B,WAAA,IAAc;EAAA;EAGdiB,gBAAAC,IAAA,EAIL;IAAA,IAJK;MAAgBhB,GAAA,EACrBhD,CAAA;MAAG6C,IAAA,EACH9B,CAAA;MAAI6B,IAAA,EACJ1C,CAAA,GAAO;MAAa6C,MAAA,EACpBzB;IAAA,IAAA0C,IAAA;IAEA,KAAKhB,GAAA,GAAMhD,CAAA,EACX,KAAK4C,IAAA,GAAO1C,CAAA,EACZ,KAAK2C,IAAA,GAAO9B,CAAA,EACZ,KAAKgC,MAAA,GAASzB,CAAA,EACd,KAAKwB,WAAA,IAAc;EAAA;EAOrBmB,YAAA;IACE,OAAK,KAAKnB,WAAA,GAGH,KAAKD,IAAA,GAFH;EAAA;EAKX,MAAAqB,gBAAsBlE,CAAA,EAAgBE,CAAA;IAMpC,aALwB,KAAKiE,aAAA,CAC3BnE,CAAA,EACAoE,MAAA,CAAOC,IAAA,CAAKnE,CAAA,GACZa,CAAA,CAAAuD,QAAA,CAASC,WAAA;EAAA;EAKb,MAAAC,YACExE,CAAA,EACAE,CAAA;IAEA,aAAa,KAAKiE,aAAA,CAChBnE,CAAA,EACAoE,MAAA,CAAOC,IAAA,CAAKnE,CAAA,GACZa,CAAA,CAAAuD,QAAA,CAASG,OAAA;EAAA;EAIb,MAAAC,gBACE1E,CAAA,EACAE,CAAA;IAEA;MACE,MAAMoB,CAAA,GAAkBiB,CAAA,CAAAkC,OAAA,CAAQJ,IAAA,CAAKnE,CAAA;MAErC,IADoBqC,CAAA,CAAAgC,WAAA,CAAYI,QAAA,CAASrD,CAAA,EAAiB,KAExD,OAAO,KAAK6C,aAAA,CACVnE,CAAA,EACAoE,MAAA,CAAOC,IAAA,CAAKnE,CAAA,GACZa,CAAA,CAAAuD,QAAA,CAASC,WAAA;IAAA,CAGb,QAAOvE,CAAA;MACP4E,OAAA,CAAQC,KAAA,CAAM7E,CAAA;IAAA;IAEhB,OAAO,KAAKwE,WAAA,CAAYxE,CAAA,EAAQE,CAAA;EAAA;EAGlC,MAAAiE,cACEnE,CAAA,EACAE,CAAA,EACAoB,CAAA;IAEA,MAAMN,CAAA,GAAYyB,CAAA,CAAAqC,EAAA;MACZjD,CAAA,GAAU,KAAKoC,WAAA,GAAcc,IAAA,CAChChE,CAAA,IAAYA,CAAA,CAAQ4C,MAAA,IAAU3D,CAAA;MAE3BuC,CAAA,GAAiBxB,CAAA,CAAAiE,cAAA,CAAeC,mBAAA,CACpC/E,CAAA,EACA2B,CAAA,CAAQ4B,MAAA,EACR,KAAKT,GAAA,EACL1B,CAAA,EACAN,CAAA;IAEF,OAAO,KAAKK,gBAAA,CACVL,CAAA,EACAuB,CAAA,EACA,2BACA;EAAA;AAAA;AApJGJ,CAAA,CAAAE,IAAA,GArBW;AAAA,MCJP6C,CAAA,SAAuB/C,CAAA;EAOlCtC,YAAA;IACE,SAGF,KAAAuC,cAAA,GAAiB,MACR,IAAIxC,CAAA;EAAA;EATb,OAAAuF,gBAAA;IACE,OAAO,IAAID,CAAA;EAAA;AAAA;AAHNA,CAAA,CAAA7C,IAAA,GAAOF,CAAA,CAAYE,IAAA,EAAA+C,OAAA,CAAAC,WAAA,GAAAlD,CAAA,EAAAiD,OAAA,CAAAE,cAAA,GAAAJ,CAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}