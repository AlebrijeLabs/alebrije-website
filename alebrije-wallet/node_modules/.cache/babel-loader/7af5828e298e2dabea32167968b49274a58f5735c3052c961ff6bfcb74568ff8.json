{"ast":null,"code":"import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction, getAssociatedTokenAddress } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint || clusterApiUrl('devnet'), 'confirmed');\n  }\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(tokenPublicKey, walletPublicKey);\n      try {\n        const accountInfo = await this.connection.getTokenAccountBalance(associatedTokenAddress);\n        return accountInfo.value.uiAmount;\n      } catch (err) {\n        // If account doesn't exist, return 0\n        return 0;\n      }\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw new Error('Failed to get token balance: ' + error.message);\n    }\n  }\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const toPublicKey = new PublicKey(toAddress);\n\n      // Get token decimals\n      const tokenInfo = await this.getTokenInfo(tokenAddress);\n      const decimals = tokenInfo.decimals;\n\n      // Calculate token amounts with decimals\n      const rawAmount = amount * Math.pow(10, decimals);\n\n      // Get or create associated token accounts\n      const fromTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, fromPublicKey);\n      const toTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, toPublicKey);\n\n      // Create transaction\n      const transaction = new Transaction();\n\n      // Check if recipient token account exists\n      const recipientAccount = await this.connection.getAccountInfo(toTokenAccount);\n\n      // If recipient account doesn't exist, add create instruction\n      if (!recipientAccount) {\n        const createAccountInstruction = await createAssociatedTokenAccountInstruction(fromPublicKey,\n        // payer\n        toTokenAccount,\n        // associated token account\n        toPublicKey,\n        // owner\n        tokenPublicKey // mint\n        );\n        transaction.add(createAccountInstruction);\n      }\n\n      // Add transfer instruction\n      const transferInstruction = createTransferInstruction(fromTokenAccount, toTokenAccount, fromPublicKey, rawAmount, [], TOKEN_PROGRAM_ID);\n      transaction.add(transferInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('No compatible wallet found');\n      }\n\n      // Sign and send transaction\n      try {\n        var _confirmation$value;\n        const signed = await walletAdapter.signTransaction(transaction);\n        const signature = await this.connection.sendRawTransaction(signed.serialize());\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');\n        if ((_confirmation$value = confirmation.value) !== null && _confirmation$value !== void 0 && _confirmation$value.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        var _signError$message;\n        if ((_signError$message = signError.message) !== null && _signError$message !== void 0 && _signError$message.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('Token transfer error:', error);\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      if (!tokenInfo.value || !tokenInfo.value.data.parsed) {\n        throw new Error('Invalid token address');\n      }\n      const mintInfo = tokenInfo.value.data.parsed.info;\n\n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: mintInfo.decimals,\n        supply: mintInfo.supply,\n        name: mintInfo.name || 'Unknown Token',\n        symbol: mintInfo.symbol || 'UNKNOWN'\n      };\n\n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw new Error('Failed to get token info: ' + error.message);\n    }\n  }\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(walletPublicKey, {\n        limit\n      });\n\n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n  async transferNativeSOL(fromWallet, toAddress, amount, walletAdapter) {\n    if (!this.connection) {\n      console.error('Connection not initialized');\n      throw new Error('Wallet connection not initialized');\n    }\n    if (!walletAdapter) {\n      throw new Error('Wallet adapter is required');\n    }\n    try {\n      console.log('Starting SOL transfer:', {\n        from: fromWallet,\n        to: toAddress,\n        amount: amount\n      });\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n\n      // Check balance before transfer\n      const balance = await this.connection.getBalance(fromPublicKey);\n      console.log('Current balance:', balance / LAMPORTS_PER_SOL, 'SOL');\n      const transferAmount = Math.floor(amount * LAMPORTS_PER_SOL);\n      const estimatedFee = 5000; // Approximate fee in lamports\n\n      console.log('Transfer details:', {\n        transferAmount,\n        estimatedFee,\n        totalNeeded: transferAmount + estimatedFee,\n        currentBalance: balance\n      });\n      if (balance < transferAmount + estimatedFee) {\n        throw new Error(`Insufficient balance. Need ${(transferAmount + estimatedFee) / LAMPORTS_PER_SOL} SOL but have ${balance / LAMPORTS_PER_SOL} SOL`);\n      }\n\n      // Create transfer instruction\n      const transferInstruction = SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: transferAmount\n      });\n\n      // Create transaction\n      const transaction = new Transaction();\n      transaction.add(transferInstruction);\n\n      // Get the latest blockhash\n      console.log('Getting latest blockhash...');\n      const {\n        blockhash,\n        lastValidBlockHeight\n      } = await this.connection.getLatestBlockhash('confirmed');\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n      try {\n        var _confirmation$value2, _signatureStatus$valu;\n        // Sign transaction using the provided wallet adapter\n        console.log('Requesting transaction signature...');\n        const signed = await walletAdapter.signTransaction(transaction);\n\n        // Send transaction\n        console.log('Sending transaction...');\n        const signature = await this.connection.sendRawTransaction(signed.serialize(), {\n          skipPreflight: false,\n          maxRetries: 3\n        });\n        console.log('Transaction sent:', signature);\n\n        // Wait for confirmation\n        console.log('Waiting for confirmation...');\n        const confirmation = await this.connection.confirmTransaction({\n          signature,\n          blockhash,\n          lastValidBlockHeight\n        }, 'confirmed');\n        console.log('Confirmation received:', confirmation);\n        if ((_confirmation$value2 = confirmation.value) !== null && _confirmation$value2 !== void 0 && _confirmation$value2.err) {\n          console.error('Transaction error:', confirmation.value.err);\n          throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n        }\n\n        // Verify the transaction was successful\n        const signatureStatus = await this.connection.getSignatureStatus(signature);\n        console.log('Signature status:', signatureStatus);\n        if ((_signatureStatus$valu = signatureStatus.value) !== null && _signatureStatus$valu !== void 0 && _signatureStatus$valu.err) {\n          throw new Error(`Transaction verification failed: ${JSON.stringify(signatureStatus.value.err)}`);\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        var _signError$message2, _signError$message3, _signError$message4;\n        console.error('Transaction signing/sending error:', signError);\n        if ((_signError$message2 = signError.message) !== null && _signError$message2 !== void 0 && _signError$message2.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n\n        // Check if it's a simulation failure\n        if ((_signError$message3 = signError.message) !== null && _signError$message3 !== void 0 && _signError$message3.includes('0x1') || (_signError$message4 = signError.message) !== null && _signError$message4 !== void 0 && _signError$message4.includes('Transaction simulation failed')) {\n          throw new Error('Transaction simulation failed. This might be due to insufficient funds for fees or network congestion.');\n        }\n        throw signError;\n      }\n    } catch (error) {\n      var _error$message, _error$message2, _error$message3, _error$message4, _error$message5;\n      console.error('SOL transfer error:', error);\n\n      // Provide more specific error messages\n      if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('insufficient')) {\n        throw new Error(`Insufficient balance: ${error.message}`);\n      } else if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('rejected')) {\n        throw new Error('Transaction was rejected by the user');\n      } else if ((_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('blockhash')) {\n        throw new Error('Network error: Please try again');\n      } else if ((_error$message4 = error.message) !== null && _error$message4 !== void 0 && _error$message4.includes('simulation')) {\n        throw new Error('Transaction simulation failed. Please check your balance and try again.');\n      } else if ((_error$message5 = error.message) !== null && _error$message5 !== void 0 && _error$message5.includes('valid blockhash')) {\n        throw new Error('Network timeout. Please try again.');\n      }\n      throw new Error(`Transfer failed: ${error.message}`);\n    }\n  }\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      var _this$tokenInfo$token, _window$solana;\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n\n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(ownerPublicKey, {\n        mint: tokenPublicKey\n      });\n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      const tokenAccount = tokenAccounts.value[0].pubkey;\n\n      // Get token decimals\n      const decimals = ((_this$tokenInfo$token = this.tokenInfo[tokenAddress]) === null || _this$tokenInfo$token === void 0 ? void 0 : _this$tokenInfo$token.decimals) || (await this.getTokenInfo(tokenAddress)).decimals;\n\n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(tokenAccount, tokenPublicKey, ownerPublicKey, amount * Math.pow(10, decimals));\n\n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n\n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n\n      // For Phantom\n      if ((_window$solana = window.solana) !== null && _window$solana !== void 0 && _window$solana.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      } else {\n        throw new Error('No compatible wallet found');\n      }\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\nexport default new TokenService();\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n  const connection = new Connection(clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'), 'confirmed');\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    const transaction = new Transaction().add(SystemProgram.transfer({\n      fromPubkey: wallet.publicKey,\n      toPubkey: burnAddress,\n      lamports: amount * LAMPORTS_PER_SOL\n    }));\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(mint, wallet.publicKey);\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    const burnInstruction = createBurnInstruction(associatedTokenAddress, mint, wallet.publicKey, amount * Math.pow(10, mintInfo.decimals));\n    const transaction = new Transaction().add(burnInstruction);\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n};","map":{"version":3,"names":["WalletService","Connection","PublicKey","Transaction","SystemProgram","LAMPORTS_PER_SOL","createTransferInstruction","TOKEN_PROGRAM_ID","createBurnInstruction","getAssociatedTokenAddress","clusterApiUrl","TokenService","constructor","connection","tokenInfo","initialize","endpoint","getTokenBalance","tokenAddress","walletAddress","Error","tokenPublicKey","walletPublicKey","associatedTokenAddress","accountInfo","getTokenAccountBalance","value","uiAmount","err","error","console","message","transferToken","fromWallet","toAddress","amount","fromPublicKey","toPublicKey","getTokenInfo","decimals","rawAmount","Math","pow","fromTokenAccount","toTokenAccount","transaction","recipientAccount","getAccountInfo","createAccountInstruction","createAssociatedTokenAccountInstruction","add","transferInstruction","recentBlockhash","getRecentBlockhash","blockhash","feePayer","walletAdapter","window","solana","solflare","_confirmation$value","signed","signTransaction","signature","sendRawTransaction","serialize","confirmation","confirmTransaction","JSON","stringify","status","signError","_signError$message","includes","getParsedAccountInfo","data","parsed","mintInfo","info","parsedInfo","address","supply","name","symbol","getAccountTransactions","limit","signatures","getSignaturesForAddress","map","sig","timestamp","blockTime","Date","now","confirmationStatus","type","getTokenTransactions","getNativeBalance","balance","getBalance","transferNativeSOL","log","from","to","transferAmount","floor","estimatedFee","totalNeeded","currentBalance","transfer","fromPubkey","toPubkey","lamports","lastValidBlockHeight","getLatestBlockhash","_confirmation$value2","_signatureStatus$valu","skipPreflight","maxRetries","signatureStatus","getSignatureStatus","_signError$message2","_signError$message3","_signError$message4","_error$message","_error$message2","_error$message3","_error$message4","_error$message5","burnToken","ownerAddress","_this$tokenInfo$token","_window$solana","ownerPublicKey","tokenAccounts","getParsedTokenAccountsByOwner","mint","length","tokenAccount","pubkey","burnInstruction","signedTransaction","isPhantom","burnTokens","wallet","publicKey","process","env","REACT_APP_SOLANA_NETWORK","burnAddress","sendTransaction","getMint"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/token-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction, getAssociatedTokenAddress } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\n\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint || clusterApiUrl('devnet'), 'confirmed');\n  }\n\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        walletPublicKey\n      );\n      \n      try {\n        const accountInfo = await this.connection.getTokenAccountBalance(associatedTokenAddress);\n        return accountInfo.value.uiAmount;\n      } catch (err) {\n        // If account doesn't exist, return 0\n        return 0;\n      }\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw new Error('Failed to get token balance: ' + error.message);\n    }\n  }\n\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const toPublicKey = new PublicKey(toAddress);\n      \n      // Get token decimals\n      const tokenInfo = await this.getTokenInfo(tokenAddress);\n      const decimals = tokenInfo.decimals;\n      \n      // Calculate token amounts with decimals\n      const rawAmount = amount * Math.pow(10, decimals);\n      \n      // Get or create associated token accounts\n      const fromTokenAccount = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        fromPublicKey\n      );\n      \n      const toTokenAccount = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        toPublicKey\n      );\n      \n      // Create transaction\n      const transaction = new Transaction();\n      \n      // Check if recipient token account exists\n      const recipientAccount = await this.connection.getAccountInfo(toTokenAccount);\n      \n      // If recipient account doesn't exist, add create instruction\n      if (!recipientAccount) {\n        const createAccountInstruction = await createAssociatedTokenAccountInstruction(\n          fromPublicKey, // payer\n          toTokenAccount, // associated token account\n          toPublicKey, // owner\n          tokenPublicKey // mint\n        );\n        transaction.add(createAccountInstruction);\n      }\n      \n      // Add transfer instruction\n      const transferInstruction = createTransferInstruction(\n        fromTokenAccount,\n        toTokenAccount,\n        fromPublicKey,\n        rawAmount,\n        [],\n        TOKEN_PROGRAM_ID\n      );\n      \n      transaction.add(transferInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('No compatible wallet found');\n      }\n      \n      // Sign and send transaction\n      try {\n        const signed = await walletAdapter.signTransaction(transaction);\n        const signature = await this.connection.sendRawTransaction(signed.serialize());\n        \n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');\n        \n        if (confirmation.value?.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        \n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        if (signError.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('Token transfer error:', error);\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      \n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      \n      if (!tokenInfo.value || !tokenInfo.value.data.parsed) {\n        throw new Error('Invalid token address');\n      }\n      \n      const mintInfo = tokenInfo.value.data.parsed.info;\n      \n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: mintInfo.decimals,\n        supply: mintInfo.supply,\n        name: mintInfo.name || 'Unknown Token',\n        symbol: mintInfo.symbol || 'UNKNOWN'\n      };\n      \n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      \n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw new Error('Failed to get token info: ' + error.message);\n    }\n  }\n\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(\n        walletPublicKey,\n        { limit }\n      );\n      \n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n\n  async transferNativeSOL(fromWallet, toAddress, amount, walletAdapter) {\n    if (!this.connection) {\n      console.error('Connection not initialized');\n      throw new Error('Wallet connection not initialized');\n    }\n    \n    if (!walletAdapter) {\n      throw new Error('Wallet adapter is required');\n    }\n    \n    try {\n      console.log('Starting SOL transfer:', {\n        from: fromWallet,\n        to: toAddress,\n        amount: amount\n      });\n\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Check balance before transfer\n      const balance = await this.connection.getBalance(fromPublicKey);\n      console.log('Current balance:', balance / LAMPORTS_PER_SOL, 'SOL');\n      \n      const transferAmount = Math.floor(amount * LAMPORTS_PER_SOL);\n      const estimatedFee = 5000; // Approximate fee in lamports\n      \n      console.log('Transfer details:', {\n        transferAmount,\n        estimatedFee,\n        totalNeeded: transferAmount + estimatedFee,\n        currentBalance: balance\n      });\n      \n      if (balance < transferAmount + estimatedFee) {\n        throw new Error(`Insufficient balance. Need ${(transferAmount + estimatedFee) / LAMPORTS_PER_SOL} SOL but have ${balance / LAMPORTS_PER_SOL} SOL`);\n      }\n      \n      // Create transfer instruction\n      const transferInstruction = SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: transferAmount\n      });\n      \n      // Create transaction\n      const transaction = new Transaction();\n      transaction.add(transferInstruction);\n      \n      // Get the latest blockhash\n      console.log('Getting latest blockhash...');\n      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      try {\n        // Sign transaction using the provided wallet adapter\n        console.log('Requesting transaction signature...');\n        const signed = await walletAdapter.signTransaction(transaction);\n        \n        // Send transaction\n        console.log('Sending transaction...');\n        const signature = await this.connection.sendRawTransaction(signed.serialize(), {\n          skipPreflight: false,\n          maxRetries: 3\n        });\n        \n        console.log('Transaction sent:', signature);\n        \n        // Wait for confirmation\n        console.log('Waiting for confirmation...');\n        const confirmation = await this.connection.confirmTransaction({\n          signature,\n          blockhash,\n          lastValidBlockHeight\n        }, 'confirmed');\n        \n        console.log('Confirmation received:', confirmation);\n        \n        if (confirmation.value?.err) {\n          console.error('Transaction error:', confirmation.value.err);\n          throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n        }\n        \n        // Verify the transaction was successful\n        const signatureStatus = await this.connection.getSignatureStatus(signature);\n        console.log('Signature status:', signatureStatus);\n        \n        if (signatureStatus.value?.err) {\n          throw new Error(`Transaction verification failed: ${JSON.stringify(signatureStatus.value.err)}`);\n        }\n        \n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        console.error('Transaction signing/sending error:', signError);\n        \n        if (signError.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        \n        // Check if it's a simulation failure\n        if (signError.message?.includes('0x1') || signError.message?.includes('Transaction simulation failed')) {\n          throw new Error('Transaction simulation failed. This might be due to insufficient funds for fees or network congestion.');\n        }\n        \n        throw signError;\n      }\n    } catch (error) {\n      console.error('SOL transfer error:', error);\n      \n      // Provide more specific error messages\n      if (error.message?.includes('insufficient')) {\n        throw new Error(`Insufficient balance: ${error.message}`);\n      } else if (error.message?.includes('rejected')) {\n        throw new Error('Transaction was rejected by the user');\n      } else if (error.message?.includes('blockhash')) {\n        throw new Error('Network error: Please try again');\n      } else if (error.message?.includes('simulation')) {\n        throw new Error('Transaction simulation failed. Please check your balance and try again.');\n      } else if (error.message?.includes('valid blockhash')) {\n        throw new Error('Network timeout. Please try again.');\n      }\n      \n      throw new Error(`Transfer failed: ${error.message}`);\n    }\n  }\n\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n      \n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        ownerPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      \n      const tokenAccount = tokenAccounts.value[0].pubkey;\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(\n        tokenAccount,\n        tokenPublicKey,\n        ownerPublicKey,\n        amount * Math.pow(10, decimals)\n      );\n      \n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new TokenService();\n\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n\n  const connection = new Connection(\n    clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'),\n    'confirmed'\n  );\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    \n    const transaction = new Transaction().add(\n      SystemProgram.transfer({\n        fromPubkey: wallet.publicKey,\n        toPubkey: burnAddress,\n        lamports: amount * LAMPORTS_PER_SOL,\n      })\n    );\n\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(\n      mint,\n      wallet.publicKey\n    );\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    \n    const burnInstruction = createBurnInstruction(\n      associatedTokenAddress,\n      mint,\n      wallet.publicKey,\n      amount * Math.pow(10, mintInfo.decimals)\n    );\n\n    const transaction = new Transaction().add(burnInstruction);\n    \n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}