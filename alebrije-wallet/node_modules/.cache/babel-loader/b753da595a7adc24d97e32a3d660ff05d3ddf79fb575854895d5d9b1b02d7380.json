{"ast":null,"code":"import WalletService from './wallet-service';\nimport TokenService from './token-service';\nimport config from '../config';\nimport { handleError, ErrorTypes, AlebrijeError } from '../utils/error-handler';\nclass TransactionHistoryService {\n  constructor() {\n    this.transactions = new Map(); // tokenName -> transactions array\n    this.isLoading = false;\n    this.lastFetchTime = null;\n    this.eventSubscriptions = {};\n  }\n\n  /**\n   * Initialize transaction history for a token\n   * @param {string} tokenName - Name of the token\n   */\n  async initialize(tokenName) {\n    if (!this.transactions.has(tokenName)) {\n      this.transactions.set(tokenName, []);\n    }\n\n    // Subscribe to token transfer events\n    this._subscribeToTransferEvents(tokenName);\n\n    // Load initial transaction history\n    return this.fetchTransactionHistory(tokenName);\n  }\n\n  /**\n   * Fetch transaction history for a token\n   * @param {string} tokenName - Name of the token\n   * @param {number} limit - Maximum number of transactions to fetch\n   * @returns {Promise<Array>} - Array of transactions\n   */\n  async fetchTransactionHistory(tokenName, limit = 50) {\n    if (!WalletService.isConnected()) {\n      throw new AlebrijeError('Wallet not connected', ErrorTypes.WALLET);\n    }\n    const account = WalletService.getCurrentAccount();\n    if (!account) {\n      throw new AlebrijeError('No account selected', ErrorTypes.WALLET);\n    }\n    this.isLoading = true;\n    try {\n      // Get token info\n      const tokenInfo = TokenService.getTokenInfo(tokenName);\n      if (!tokenInfo) {\n        throw new AlebrijeError(`Token ${tokenName} not found`, ErrorTypes.USER);\n      }\n\n      // Determine which blockchain to use\n      const blockchain = tokenInfo.blockchain || config.DEFAULT_NETWORK.blockchain;\n\n      // Fetch transactions based on blockchain\n      let transactions = [];\n      if (blockchain === 'ethereum') {\n        transactions = await this._fetchEthereumTransactions(tokenName, account, limit);\n      } else if (blockchain === 'solana') {\n        transactions = await this._fetchSolanaTransactions(tokenName, account, limit);\n      } else {\n        throw new AlebrijeError(`Unsupported blockchain: ${blockchain}`, ErrorTypes.UNKNOWN);\n      }\n\n      // Update the transactions map\n      this.transactions.set(tokenName, transactions);\n      this.lastFetchTime = new Date();\n      return transactions;\n    } catch (error) {\n      throw handleError(error, `Failed to fetch transaction history for ${tokenName}`);\n    } finally {\n      this.isLoading = false;\n    }\n  }\n\n  /**\n   * Get cached transaction history for a token\n   * @param {string} tokenName - Name of the token\n   * @returns {Array} - Array of transactions\n   */\n  getTransactionHistory(tokenName) {\n    return this.transactions.get(tokenName) || [];\n  }\n\n  /**\n   * Add a new transaction to the history\n   * @param {string} tokenName - Name of the token\n   * @param {Object} transaction - Transaction object\n   */\n  addTransaction(tokenName, transaction) {\n    if (!this.transactions.has(tokenName)) {\n      this.transactions.set(tokenName, []);\n    }\n    const transactions = this.transactions.get(tokenName);\n\n    // Check if transaction already exists\n    const exists = transactions.some(tx => tx.hash === transaction.hash);\n    if (!exists) {\n      transactions.unshift(transaction); // Add to the beginning of the array\n      this.transactions.set(tokenName, transactions);\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    // Unsubscribe from all event subscriptions\n    Object.values(this.eventSubscriptions).forEach(unsubscribe => {\n      if (typeof unsubscribe === 'function') {\n        unsubscribe();\n      }\n    });\n    this.eventSubscriptions = {};\n  }\n\n  // Private methods\n\n  /**\n   * Fetch Ethereum transactions\n   * @private\n   */\n  async _fetchEthereumTransactions(tokenName, account, limit) {\n    var _config$API_KEYS;\n    const tokenAddress = TokenService.getTokenAddress(tokenName);\n\n    // Use Etherscan API or similar service to fetch transaction history\n    const apiKey = (_config$API_KEYS = config.API_KEYS) === null || _config$API_KEYS === void 0 ? void 0 : _config$API_KEYS.etherscan;\n    const network = config.DEFAULT_NETWORK.network;\n    const baseUrl = network === 'mainnet' ? 'https://api.etherscan.io/api' : `https://api-${network}.etherscan.io/api`;\n    const url = `${baseUrl}?module=account&action=tokentx&contractaddress=${tokenAddress}&address=${account}&sort=desc&limit=${limit}${apiKey ? `&apikey=${apiKey}` : ''}`;\n    try {\n      const response = await fetch(url);\n      const data = await response.json();\n      if (data.status !== '1') {\n        throw new Error(data.message || 'Failed to fetch transactions');\n      }\n\n      // Transform the response into our transaction format\n      return data.result.map(tx => ({\n        hash: tx.hash,\n        from: tx.from,\n        to: tx.to,\n        value: TokenService.formatTokenAmount(tx.value, tokenName),\n        timestamp: new Date(parseInt(tx.timeStamp) * 1000),\n        blockNumber: parseInt(tx.blockNumber),\n        confirmations: parseInt(tx.confirmations),\n        isIncoming: tx.to.toLowerCase() === account.toLowerCase(),\n        status: 'confirmed'\n      }));\n    } catch (error) {\n      console.error('Error fetching Ethereum transactions:', error);\n\n      // If API fails, try to get transactions from events\n      return this._getTransactionsFromEvents(tokenName);\n    }\n  }\n\n  /**\n   * Fetch Solana transactions\n   * @private\n   */\n  async _fetchSolanaTransactions(tokenName, account, limit) {\n    // Implementation for Solana would go here\n    // This is a placeholder\n    return [];\n  }\n\n  /**\n   * Get transactions from cached events\n   * @private\n   */\n  _getTransactionsFromEvents(tokenName) {\n    // This is a fallback method if API calls fail\n    return this.transactions.get(tokenName) || [];\n  }\n\n  /**\n   * Subscribe to token transfer events\n   * @private\n   */\n  _subscribeToTransferEvents(tokenName) {\n    // Unsubscribe from previous subscription if exists\n    if (this.eventSubscriptions[tokenName]) {\n      this.eventSubscriptions[tokenName]();\n    }\n\n    // Subscribe to new events\n    const unsubscribe = TokenService.subscribeToTransfers(tokenName, (error, event) => {\n      if (error) {\n        console.error(`Error in transfer event for ${tokenName}:`, error);\n        return;\n      }\n      const account = WalletService.getCurrentAccount();\n      if (!account) return;\n\n      // Create transaction object from event\n      const transaction = {\n        hash: event.transactionHash,\n        from: event.from,\n        to: event.to,\n        value: event.value,\n        timestamp: new Date(),\n        blockNumber: event.blockNumber,\n        confirmations: 1,\n        isIncoming: event.to.toLowerCase() === account.toLowerCase(),\n        status: 'confirmed'\n      };\n\n      // Add to transaction history\n      this.addTransaction(tokenName, transaction);\n    });\n    this.eventSubscriptions[tokenName] = unsubscribe;\n  }\n}\nexport default new TransactionHistoryService();","map":{"version":3,"names":["WalletService","TokenService","config","handleError","ErrorTypes","AlebrijeError","TransactionHistoryService","constructor","transactions","Map","isLoading","lastFetchTime","eventSubscriptions","initialize","tokenName","has","set","_subscribeToTransferEvents","fetchTransactionHistory","limit","isConnected","WALLET","account","getCurrentAccount","tokenInfo","getTokenInfo","USER","blockchain","DEFAULT_NETWORK","_fetchEthereumTransactions","_fetchSolanaTransactions","UNKNOWN","Date","error","getTransactionHistory","get","addTransaction","transaction","exists","some","tx","hash","unshift","cleanup","Object","values","forEach","unsubscribe","_config$API_KEYS","tokenAddress","getTokenAddress","apiKey","API_KEYS","etherscan","network","baseUrl","url","response","fetch","data","json","status","Error","message","result","map","from","to","value","formatTokenAmount","timestamp","parseInt","timeStamp","blockNumber","confirmations","isIncoming","toLowerCase","console","_getTransactionsFromEvents","subscribeToTransfers","event","transactionHash"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/transaction-history-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport TokenService from './token-service';\nimport config from '../config';\nimport { handleError, ErrorTypes, AlebrijeError } from '../utils/error-handler';\n\nclass TransactionHistoryService {\n  constructor() {\n    this.transactions = new Map(); // tokenName -> transactions array\n    this.isLoading = false;\n    this.lastFetchTime = null;\n    this.eventSubscriptions = {};\n  }\n  \n  /**\n   * Initialize transaction history for a token\n   * @param {string} tokenName - Name of the token\n   */\n  async initialize(tokenName) {\n    if (!this.transactions.has(tokenName)) {\n      this.transactions.set(tokenName, []);\n    }\n    \n    // Subscribe to token transfer events\n    this._subscribeToTransferEvents(tokenName);\n    \n    // Load initial transaction history\n    return this.fetchTransactionHistory(tokenName);\n  }\n  \n  /**\n   * Fetch transaction history for a token\n   * @param {string} tokenName - Name of the token\n   * @param {number} limit - Maximum number of transactions to fetch\n   * @returns {Promise<Array>} - Array of transactions\n   */\n  async fetchTransactionHistory(tokenName, limit = 50) {\n    if (!WalletService.isConnected()) {\n      throw new AlebrijeError('Wallet not connected', ErrorTypes.WALLET);\n    }\n    \n    const account = WalletService.getCurrentAccount();\n    if (!account) {\n      throw new AlebrijeError('No account selected', ErrorTypes.WALLET);\n    }\n    \n    this.isLoading = true;\n    \n    try {\n      // Get token info\n      const tokenInfo = TokenService.getTokenInfo(tokenName);\n      if (!tokenInfo) {\n        throw new AlebrijeError(`Token ${tokenName} not found`, ErrorTypes.USER);\n      }\n      \n      // Determine which blockchain to use\n      const blockchain = tokenInfo.blockchain || config.DEFAULT_NETWORK.blockchain;\n      \n      // Fetch transactions based on blockchain\n      let transactions = [];\n      \n      if (blockchain === 'ethereum') {\n        transactions = await this._fetchEthereumTransactions(tokenName, account, limit);\n      } else if (blockchain === 'solana') {\n        transactions = await this._fetchSolanaTransactions(tokenName, account, limit);\n      } else {\n        throw new AlebrijeError(`Unsupported blockchain: ${blockchain}`, ErrorTypes.UNKNOWN);\n      }\n      \n      // Update the transactions map\n      this.transactions.set(tokenName, transactions);\n      this.lastFetchTime = new Date();\n      \n      return transactions;\n    } catch (error) {\n      throw handleError(error, `Failed to fetch transaction history for ${tokenName}`);\n    } finally {\n      this.isLoading = false;\n    }\n  }\n  \n  /**\n   * Get cached transaction history for a token\n   * @param {string} tokenName - Name of the token\n   * @returns {Array} - Array of transactions\n   */\n  getTransactionHistory(tokenName) {\n    return this.transactions.get(tokenName) || [];\n  }\n  \n  /**\n   * Add a new transaction to the history\n   * @param {string} tokenName - Name of the token\n   * @param {Object} transaction - Transaction object\n   */\n  addTransaction(tokenName, transaction) {\n    if (!this.transactions.has(tokenName)) {\n      this.transactions.set(tokenName, []);\n    }\n    \n    const transactions = this.transactions.get(tokenName);\n    \n    // Check if transaction already exists\n    const exists = transactions.some(tx => tx.hash === transaction.hash);\n    if (!exists) {\n      transactions.unshift(transaction); // Add to the beginning of the array\n      this.transactions.set(tokenName, transactions);\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    // Unsubscribe from all event subscriptions\n    Object.values(this.eventSubscriptions).forEach(unsubscribe => {\n      if (typeof unsubscribe === 'function') {\n        unsubscribe();\n      }\n    });\n    \n    this.eventSubscriptions = {};\n  }\n  \n  // Private methods\n  \n  /**\n   * Fetch Ethereum transactions\n   * @private\n   */\n  async _fetchEthereumTransactions(tokenName, account, limit) {\n    const tokenAddress = TokenService.getTokenAddress(tokenName);\n    \n    // Use Etherscan API or similar service to fetch transaction history\n    const apiKey = config.API_KEYS?.etherscan;\n    const network = config.DEFAULT_NETWORK.network;\n    const baseUrl = network === 'mainnet' \n      ? 'https://api.etherscan.io/api' \n      : `https://api-${network}.etherscan.io/api`;\n    \n    const url = `${baseUrl}?module=account&action=tokentx&contractaddress=${tokenAddress}&address=${account}&sort=desc&limit=${limit}${apiKey ? `&apikey=${apiKey}` : ''}`;\n    \n    try {\n      const response = await fetch(url);\n      const data = await response.json();\n      \n      if (data.status !== '1') {\n        throw new Error(data.message || 'Failed to fetch transactions');\n      }\n      \n      // Transform the response into our transaction format\n      return data.result.map(tx => ({\n        hash: tx.hash,\n        from: tx.from,\n        to: tx.to,\n        value: TokenService.formatTokenAmount(tx.value, tokenName),\n        timestamp: new Date(parseInt(tx.timeStamp) * 1000),\n        blockNumber: parseInt(tx.blockNumber),\n        confirmations: parseInt(tx.confirmations),\n        isIncoming: tx.to.toLowerCase() === account.toLowerCase(),\n        status: 'confirmed'\n      }));\n    } catch (error) {\n      console.error('Error fetching Ethereum transactions:', error);\n      \n      // If API fails, try to get transactions from events\n      return this._getTransactionsFromEvents(tokenName);\n    }\n  }\n  \n  /**\n   * Fetch Solana transactions\n   * @private\n   */\n  async _fetchSolanaTransactions(tokenName, account, limit) {\n    // Implementation for Solana would go here\n    // This is a placeholder\n    return [];\n  }\n  \n  /**\n   * Get transactions from cached events\n   * @private\n   */\n  _getTransactionsFromEvents(tokenName) {\n    // This is a fallback method if API calls fail\n    return this.transactions.get(tokenName) || [];\n  }\n  \n  /**\n   * Subscribe to token transfer events\n   * @private\n   */\n  _subscribeToTransferEvents(tokenName) {\n    // Unsubscribe from previous subscription if exists\n    if (this.eventSubscriptions[tokenName]) {\n      this.eventSubscriptions[tokenName]();\n    }\n    \n    // Subscribe to new events\n    const unsubscribe = TokenService.subscribeToTransfers(tokenName, (error, event) => {\n      if (error) {\n        console.error(`Error in transfer event for ${tokenName}:`, error);\n        return;\n      }\n      \n      const account = WalletService.getCurrentAccount();\n      if (!account) return;\n      \n      // Create transaction object from event\n      const transaction = {\n        hash: event.transactionHash,\n        from: event.from,\n        to: event.to,\n        value: event.value,\n        timestamp: new Date(),\n        blockNumber: event.blockNumber,\n        confirmations: 1,\n        isIncoming: event.to.toLowerCase() === account.toLowerCase(),\n        status: 'confirmed'\n      };\n      \n      // Add to transaction history\n      this.addTransaction(tokenName, transaction);\n    });\n    \n    this.eventSubscriptions[tokenName] = unsubscribe;\n  }\n}\n\nexport default new TransactionHistoryService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}