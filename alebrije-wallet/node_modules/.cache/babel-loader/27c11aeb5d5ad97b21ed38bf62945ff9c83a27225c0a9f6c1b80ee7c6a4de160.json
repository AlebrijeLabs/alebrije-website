{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nexports.Errors = Errors;\nconst index_1 = require(\"../system/index\");\nconst index_2 = require(\"../type/keyof/index\");\nconst index_3 = require(\"../type/registry/index\");\nconst extends_undefined_1 = require(\"../type/extends/extends-undefined\");\nconst function_1 = require(\"./function\");\nconst index_4 = require(\"../type/error/index\");\nconst index_5 = require(\"../value/deref/index\");\nconst index_6 = require(\"../value/hash/index\");\nconst index_7 = require(\"../value/check/index\");\nconst index_8 = require(\"../type/symbols/index\");\nconst index_9 = require(\"../type/never/index\");\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nconst index_10 = require(\"../value/guard/index\");\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n  ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n  ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n  ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n  ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n  ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n  ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n  ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n  ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n  ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n  ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n  ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n  ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n  ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n  ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n  ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n  ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n  ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n  ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n  ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n  ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n  ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n  ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n  ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n  ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n  ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n  ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n  ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n  ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n  ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n  ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n  ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n  ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n  ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends index_4.TypeBoxError {\n  constructor(schema) {\n    super('Unknown type');\n    this.schema = schema;\n  }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n  return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n  return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nclass ValueErrorIterator {\n  constructor(iterator) {\n    this.iterator = iterator;\n  }\n  [Symbol.iterator]() {\n    return this.iterator;\n  }\n  /** Returns the first value error or undefined if no errors */\n  First() {\n    const next = this.iterator.next();\n    return next.done ? undefined : next.value;\n  }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value) {\n  let errors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  return {\n    type: errorType,\n    schema,\n    path,\n    value,\n    message: (0, function_1.GetErrorFunction)()({\n      errorType,\n      path,\n      schema,\n      value,\n      errors\n    }),\n    errors\n  };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) {}\nfunction* FromArray(schema, references, path, value) {\n  if (!(0, index_10.IsArray)(value)) {\n    return yield Create(ValueErrorType.Array, schema, path, value);\n  }\n  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n  }\n  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n  }\n  for (let i = 0; i < value.length; i++) {\n    yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n  }\n  // prettier-ignore\n  if (schema.uniqueItems === true && !function () {\n    const set = new Set();\n    for (const element of value) {\n      const hashed = (0, index_6.Hash)(element);\n      if (set.has(hashed)) {\n        return false;\n      } else {\n        set.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n  }\n  // contains\n  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n    return;\n  }\n  const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();\n  const containsCount = value.reduce((acc, value, index) => Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    yield Create(ValueErrorType.ArrayContains, schema, path, value);\n  }\n  if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n  }\n  if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n  }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n  if (!(0, index_10.IsAsyncIterator)(value)) yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n  if (!(0, index_10.IsBigInt)(value)) return yield Create(ValueErrorType.BigInt, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n  }\n}\nfunction* FromBoolean(schema, references, path, value) {\n  if (!(0, index_10.IsBoolean)(value)) yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n  yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n  if (!(0, index_10.IsDate)(value)) return yield Create(ValueErrorType.Date, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n  }\n}\nfunction* FromFunction(schema, references, path, value) {\n  if (!(0, index_10.IsFunction)(value)) yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n  if (!(0, index_10.IsInteger)(value)) return yield Create(ValueErrorType.Integer, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n  }\n}\nfunction* FromIntersect(schema, references, path, value) {\n  let hasError = false;\n  for (const inner of schema.allOf) {\n    for (const error of Visit(inner, references, path, value)) {\n      hasError = true;\n      yield error;\n    }\n  }\n  if (hasError) {\n    return yield Create(ValueErrorType.Intersect, schema, path, value);\n  }\n  if (schema.unevaluatedProperties === false) {\n    const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n      }\n    }\n  }\n  if (typeof schema.unevaluatedProperties === 'object') {\n    const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n        if (!next.done) yield next.value; // yield interior\n      }\n    }\n  }\n}\nfunction* FromIterator(schema, references, path, value) {\n  if (!(0, index_10.IsIterator)(value)) yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n  if (!(value === schema.const)) yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n  yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n  if (Visit(schema.not, references, path, value).next().done === true) yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n  if (!(0, index_10.IsNull)(value)) yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsNumberLike(value)) return yield Create(ValueErrorType.Number, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n  }\n}\nfunction* FromObject(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsObjectLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n  const knownKeys = Object.getOwnPropertyNames(schema.properties);\n  const unknownKeys = Object.getOwnPropertyNames(value);\n  for (const requiredKey of requiredKeys) {\n    if (unknownKeys.includes(requiredKey)) continue;\n    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n  }\n  if (schema.additionalProperties === false) {\n    for (const valueKey of unknownKeys) {\n      if (!knownKeys.includes(valueKey)) {\n        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n      }\n    }\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const valueKey of unknownKeys) {\n      if (knownKeys.includes(valueKey)) continue;\n      yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n    }\n  }\n  for (const knownKey of knownKeys) {\n    const property = schema.properties[knownKey];\n    if (schema.required && schema.required.includes(knownKey)) {\n      yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {\n        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n      }\n    } else {\n      if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      }\n    }\n  }\n}\nfunction* FromPromise(schema, references, path, value) {\n  if (!(0, index_10.IsPromise)(value)) yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsRecordLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n  const regex = new RegExp(patternKey);\n  for (const [propertyKey, propertyValue] of Object.entries(value)) {\n    if (regex.test(propertyKey)) yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (!regex.test(propertyKey)) yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n  if (schema.additionalProperties === false) {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (regex.test(propertyKey)) continue;\n      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n}\nfunction* FromRef(schema, references, path, value) {\n  yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  const regex = new RegExp(schema.source, schema.flags);\n  if (!regex.test(value)) {\n    return yield Create(ValueErrorType.RegExp, schema, path, value);\n  }\n}\nfunction* FromString(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  if ((0, index_10.IsString)(schema.pattern)) {\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n      yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n  }\n  if ((0, index_10.IsString)(schema.format)) {\n    if (!index_3.FormatRegistry.Has(schema.format)) {\n      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n    } else {\n      const format = index_3.FormatRegistry.Get(schema.format);\n      if (!format(value)) {\n        yield Create(ValueErrorType.StringFormat, schema, path, value);\n      }\n    }\n  }\n}\nfunction* FromSymbol(schema, references, path, value) {\n  if (!(0, index_10.IsSymbol)(value)) yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  const regex = new RegExp(schema.pattern);\n  if (!regex.test(value)) {\n    yield Create(ValueErrorType.StringPattern, schema, path, value);\n  }\n}\nfunction* FromThis(schema, references, path, value) {\n  yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n  if (!(0, index_10.IsArray)(value)) return yield Create(ValueErrorType.Tuple, schema, path, value);\n  if (schema.items === undefined && !(value.length === 0)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!(value.length === schema.maxItems)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!schema.items) {\n    return;\n  }\n  for (let i = 0; i < schema.items.length; i++) {\n    yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n  }\n}\nfunction* FromUndefined(schema, references, path, value) {\n  if (!(0, index_10.IsUndefined)(value)) yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n  if ((0, index_7.Check)(schema, references, value)) return;\n  const errors = schema.anyOf.map(variant => new ValueErrorIterator(Visit(variant, references, path, value)));\n  yield Create(ValueErrorType.Union, schema, path, value, errors);\n}\nfunction* FromUint8Array(schema, references, path, value) {\n  if (!(0, index_10.IsUint8Array)(value)) return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n  }\n  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n  }\n}\nfunction* FromUnknown(schema, references, path, value) {}\nfunction* FromVoid(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsVoidLike(value)) yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n  const check = index_3.TypeRegistry.Get(schema[index_8.Kind]);\n  if (!check(schema, value)) yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[index_8.Kind]) {\n    case 'Any':\n      return yield* FromAny(schema_, references_, path, value);\n    case 'Array':\n      return yield* FromArray(schema_, references_, path, value);\n    case 'AsyncIterator':\n      return yield* FromAsyncIterator(schema_, references_, path, value);\n    case 'BigInt':\n      return yield* FromBigInt(schema_, references_, path, value);\n    case 'Boolean':\n      return yield* FromBoolean(schema_, references_, path, value);\n    case 'Constructor':\n      return yield* FromConstructor(schema_, references_, path, value);\n    case 'Date':\n      return yield* FromDate(schema_, references_, path, value);\n    case 'Function':\n      return yield* FromFunction(schema_, references_, path, value);\n    case 'Integer':\n      return yield* FromInteger(schema_, references_, path, value);\n    case 'Intersect':\n      return yield* FromIntersect(schema_, references_, path, value);\n    case 'Iterator':\n      return yield* FromIterator(schema_, references_, path, value);\n    case 'Literal':\n      return yield* FromLiteral(schema_, references_, path, value);\n    case 'Never':\n      return yield* FromNever(schema_, references_, path, value);\n    case 'Not':\n      return yield* FromNot(schema_, references_, path, value);\n    case 'Null':\n      return yield* FromNull(schema_, references_, path, value);\n    case 'Number':\n      return yield* FromNumber(schema_, references_, path, value);\n    case 'Object':\n      return yield* FromObject(schema_, references_, path, value);\n    case 'Promise':\n      return yield* FromPromise(schema_, references_, path, value);\n    case 'Record':\n      return yield* FromRecord(schema_, references_, path, value);\n    case 'Ref':\n      return yield* FromRef(schema_, references_, path, value);\n    case 'RegExp':\n      return yield* FromRegExp(schema_, references_, path, value);\n    case 'String':\n      return yield* FromString(schema_, references_, path, value);\n    case 'Symbol':\n      return yield* FromSymbol(schema_, references_, path, value);\n    case 'TemplateLiteral':\n      return yield* FromTemplateLiteral(schema_, references_, path, value);\n    case 'This':\n      return yield* FromThis(schema_, references_, path, value);\n    case 'Tuple':\n      return yield* FromTuple(schema_, references_, path, value);\n    case 'Undefined':\n      return yield* FromUndefined(schema_, references_, path, value);\n    case 'Union':\n      return yield* FromUnion(schema_, references_, path, value);\n    case 'Uint8Array':\n      return yield* FromUint8Array(schema_, references_, path, value);\n    case 'Unknown':\n      return yield* FromUnknown(schema_, references_, path, value);\n    case 'Void':\n      return yield* FromVoid(schema_, references_, path, value);\n    default:\n      if (!index_3.TypeRegistry.Has(schema_[index_8.Kind])) throw new ValueErrorsUnknownTypeError(schema);\n      return yield* FromKind(schema_, references_, path, value);\n  }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors() {\n  const iterator = arguments.length === 3 ? Visit(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], '', arguments.length <= 2 ? undefined : arguments[2]) : Visit(arguments.length <= 0 ? undefined : arguments[0], [], '', arguments.length <= 1 ? undefined : arguments[1]);\n  return new ValueErrorIterator(iterator);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ValueErrorIterator","ValueErrorsUnknownTypeError","ValueErrorType","Errors","index_1","require","index_2","index_3","extends_undefined_1","function_1","index_4","index_5","index_6","index_7","index_8","index_9","index_10","TypeBoxError","constructor","schema","EscapeKey","key","replace","IsDefined","undefined","iterator","Symbol","First","next","done","Create","errorType","path","errors","arguments","length","type","message","GetErrorFunction","FromAny","references","FromArray","IsArray","Array","minItems","ArrayMinItems","maxItems","ArrayMaxItems","i","Visit","items","uniqueItems","set","Set","element","hashed","Hash","has","add","ArrayUniqueItems","contains","minContains","maxContains","containsSchema","Never","containsCount","reduce","acc","index","ArrayContains","IsNumber","ArrayMinContains","ArrayMaxContains","FromAsyncIterator","IsAsyncIterator","AsyncIterator","FromBigInt","IsBigInt","BigInt","exclusiveMaximum","BigIntExclusiveMaximum","exclusiveMinimum","BigIntExclusiveMinimum","maximum","BigIntMaximum","minimum","BigIntMinimum","multipleOf","BigIntMultipleOf","FromBoolean","IsBoolean","Boolean","FromConstructor","returns","prototype","FromDate","IsDate","Date","exclusiveMaximumTimestamp","getTime","DateExclusiveMaximumTimestamp","exclusiveMinimumTimestamp","DateExclusiveMinimumTimestamp","maximumTimestamp","DateMaximumTimestamp","minimumTimestamp","DateMinimumTimestamp","multipleOfTimestamp","DateMultipleOfTimestamp","FromFunction","IsFunction","Function","FromInteger","IsInteger","Integer","IntegerExclusiveMaximum","IntegerExclusiveMinimum","IntegerMaximum","IntegerMinimum","IntegerMultipleOf","FromIntersect","hasError","inner","allOf","error","Intersect","unevaluatedProperties","keyCheck","RegExp","KeyOfPattern","valueKey","getOwnPropertyNames","test","IntersectUnevaluatedProperties","FromIterator","IsIterator","Iterator","FromLiteral","const","Literal","FromNever","FromNot","not","Not","FromNull","IsNull","Null","FromNumber","TypeSystemPolicy","IsNumberLike","Number","NumberExclusiveMaximum","NumberExclusiveMinimum","NumberMaximum","NumberMinimum","NumberMultipleOf","FromObject","IsObjectLike","minProperties","ObjectMinProperties","maxProperties","ObjectMaxProperties","requiredKeys","isArray","required","knownKeys","properties","unknownKeys","requiredKey","includes","ObjectRequiredProperty","additionalProperties","ObjectAdditionalProperties","knownKey","property","ExtendsUndefinedCheck","IsExactOptionalProperty","FromPromise","IsPromise","Promise","FromRecord","IsRecordLike","patternKey","patternSchema","entries","patternProperties","regex","propertyKey","propertyValue","FromRef","Deref","FromRegExp","IsString","String","minLength","StringMinLength","maxLength","StringMaxLength","source","flags","FromString","pattern","StringPattern","format","FormatRegistry","Has","StringFormatUnknown","Get","StringFormat","FromSymbol","IsSymbol","FromTemplateLiteral","FromThis","FromTuple","Tuple","TupleLength","FromUndefined","IsUndefined","Undefined","FromUnion","Check","anyOf","map","variant","Union","FromUint8Array","IsUint8Array","Uint8Array","maxByteLength","Uint8ArrayMaxByteLength","minByteLength","Uint8ArrayMinByteLength","FromUnknown","FromVoid","IsVoidLike","Void","FromKind","check","TypeRegistry","Kind","references_","$id","schema_"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@sinclair/typebox/build/cjs/errors/errors.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nexports.Errors = Errors;\nconst index_1 = require(\"../system/index\");\nconst index_2 = require(\"../type/keyof/index\");\nconst index_3 = require(\"../type/registry/index\");\nconst extends_undefined_1 = require(\"../type/extends/extends-undefined\");\nconst function_1 = require(\"./function\");\nconst index_4 = require(\"../type/error/index\");\nconst index_5 = require(\"../value/deref/index\");\nconst index_6 = require(\"../value/hash/index\");\nconst index_7 = require(\"../value/check/index\");\nconst index_8 = require(\"../type/symbols/index\");\nconst index_9 = require(\"../type/never/index\");\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nconst index_10 = require(\"../value/guard/index\");\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends index_4.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n    return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nclass ValueErrorIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value, errors = []) {\n    return {\n        type: errorType,\n        schema,\n        path,\n        value,\n        message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value, errors }),\n        errors,\n    };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) { }\nfunction* FromArray(schema, references, path, value) {\n    if (!(0, index_10.IsArray)(value)) {\n        return yield Create(ValueErrorType.Array, schema, path, value);\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = (0, index_6.Hash)(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield Create(ValueErrorType.ArrayContains, schema, path, value);\n    }\n    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n    }\n    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n    }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n    if (!(0, index_10.IsAsyncIterator)(value))\n        yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n    if (!(0, index_10.IsBigInt)(value))\n        return yield Create(ValueErrorType.BigInt, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n    }\n}\nfunction* FromBoolean(schema, references, path, value) {\n    if (!(0, index_10.IsBoolean)(value))\n        yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n    if (!(0, index_10.IsDate)(value))\n        return yield Create(ValueErrorType.Date, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n    }\n}\nfunction* FromFunction(schema, references, path, value) {\n    if (!(0, index_10.IsFunction)(value))\n        yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n    if (!(0, index_10.IsInteger)(value))\n        return yield Create(ValueErrorType.Integer, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n    }\n}\nfunction* FromIntersect(schema, references, path, value) {\n    let hasError = false;\n    for (const inner of schema.allOf) {\n        for (const error of Visit(inner, references, path, value)) {\n            hasError = true;\n            yield error;\n        }\n    }\n    if (hasError) {\n        return yield Create(ValueErrorType.Intersect, schema, path, value);\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done)\n                    yield next.value; // yield interior\n            }\n        }\n    }\n}\nfunction* FromIterator(schema, references, path, value) {\n    if (!(0, index_10.IsIterator)(value))\n        yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n    if (!(value === schema.const))\n        yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n    yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true)\n        yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n    if (!(0, index_10.IsNull)(value))\n        yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsNumberLike(value))\n        return yield Create(ValueErrorType.Number, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n    }\n}\nfunction* FromObject(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsObjectLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n        }\n    }\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {\n                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n            }\n        }\n        else {\n            if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            }\n        }\n    }\n}\nfunction* FromPromise(schema, references, path, value) {\n    if (!(0, index_10.IsPromise)(value))\n        yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsRecordLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey))\n            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (!regex.test(propertyKey))\n                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n    if (schema.additionalProperties === false) {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (regex.test(propertyKey))\n                continue;\n            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n}\nfunction* FromRef(schema, references, path, value) {\n    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n    if (!(0, index_10.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    const regex = new RegExp(schema.source, schema.flags);\n    if (!regex.test(value)) {\n        return yield Create(ValueErrorType.RegExp, schema, path, value);\n    }\n}\nfunction* FromString(schema, references, path, value) {\n    if (!(0, index_10.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    if ((0, index_10.IsString)(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield Create(ValueErrorType.StringPattern, schema, path, value);\n        }\n    }\n    if ((0, index_10.IsString)(schema.format)) {\n        if (!index_3.FormatRegistry.Has(schema.format)) {\n            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n        }\n        else {\n            const format = index_3.FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield Create(ValueErrorType.StringFormat, schema, path, value);\n            }\n        }\n    }\n}\nfunction* FromSymbol(schema, references, path, value) {\n    if (!(0, index_10.IsSymbol)(value))\n        yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n    if (!(0, index_10.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n}\nfunction* FromThis(schema, references, path, value) {\n    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n    if (!(0, index_10.IsArray)(value))\n        return yield Create(ValueErrorType.Tuple, schema, path, value);\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!(value.length === schema.maxItems)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* FromUndefined(schema, references, path, value) {\n    if (!(0, index_10.IsUndefined)(value))\n        yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n    if ((0, index_7.Check)(schema, references, value))\n        return;\n    const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit(variant, references, path, value)));\n    yield Create(ValueErrorType.Union, schema, path, value, errors);\n}\nfunction* FromUint8Array(schema, references, path, value) {\n    if (!(0, index_10.IsUint8Array)(value))\n        return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n    }\n}\nfunction* FromUnknown(schema, references, path, value) { }\nfunction* FromVoid(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsVoidLike(value))\n        yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n    const check = index_3.TypeRegistry.Get(schema[index_8.Kind]);\n    if (!check(schema, value))\n        yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[index_8.Kind]) {\n        case 'Any':\n            return yield* FromAny(schema_, references_, path, value);\n        case 'Array':\n            return yield* FromArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* FromAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* FromBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* FromBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* FromConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* FromDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* FromFunction(schema_, references_, path, value);\n        case 'Integer':\n            return yield* FromInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* FromIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* FromIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* FromLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* FromNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* FromNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* FromNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* FromNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* FromObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* FromPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* FromRef(schema_, references_, path, value);\n        case 'RegExp':\n            return yield* FromRegExp(schema_, references_, path, value);\n        case 'String':\n            return yield* FromString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* FromSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* FromTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* FromTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* FromUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* FromUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* FromUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* FromUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* FromVoid(schema_, references_, path, value);\n        default:\n            if (!index_3.TypeRegistry.Has(schema_[index_8.Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* FromKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,kBAAkB,GAAGF,OAAO,CAACG,2BAA2B,GAAGH,OAAO,CAACI,cAAc,GAAG,KAAK,CAAC;AAClGJ,OAAO,CAACK,MAAM,GAAGA,MAAM;AACvB,MAAMC,OAAO,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC1C,MAAMC,OAAO,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAC9C,MAAME,OAAO,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AACjD,MAAMG,mBAAmB,GAAGH,OAAO,CAAC,mCAAmC,CAAC;AACxE,MAAMI,UAAU,GAAGJ,OAAO,CAAC,YAAY,CAAC;AACxC,MAAMK,OAAO,GAAGL,OAAO,CAAC,qBAAqB,CAAC;AAC9C,MAAMM,OAAO,GAAGN,OAAO,CAAC,sBAAsB,CAAC;AAC/C,MAAMO,OAAO,GAAGP,OAAO,CAAC,qBAAqB,CAAC;AAC9C,MAAMQ,OAAO,GAAGR,OAAO,CAAC,sBAAsB,CAAC;AAC/C,MAAMS,OAAO,GAAGT,OAAO,CAAC,uBAAuB,CAAC;AAChD,MAAMU,OAAO,GAAGV,OAAO,CAAC,qBAAqB,CAAC;AAC9C;AACA;AACA;AACA;AACA,MAAMW,QAAQ,GAAGX,OAAO,CAAC,sBAAsB,CAAC;AAChD;AACA;AACA;AACA,IAAIH,cAAc;AAClB,CAAC,UAAUA,cAAc,EAAE;EACvBA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe;EACrEA,cAAc,CAACA,cAAc,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;EAC3EA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe;EACrEA,cAAc,CAACA,cAAc,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;EAC3EA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe;EACrEA,cAAc,CAACA,cAAc,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;EAC3EA,cAAc,CAACA,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACrDA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe;EACrEA,cAAc,CAACA,cAAc,CAAC,wBAAwB,CAAC,GAAG,CAAC,CAAC,GAAG,wBAAwB;EACvFA,cAAc,CAACA,cAAc,CAAC,wBAAwB,CAAC,GAAG,CAAC,CAAC,GAAG,wBAAwB;EACvFA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EACtEA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EACtEA,cAAc,CAACA,cAAc,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,GAAG,kBAAkB;EAC5EA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;EACxDA,cAAc,CAACA,cAAc,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1DA,cAAc,CAACA,cAAc,CAAC,+BAA+B,CAAC,GAAG,EAAE,CAAC,GAAG,+BAA+B;EACtGA,cAAc,CAACA,cAAc,CAAC,+BAA+B,CAAC,GAAG,EAAE,CAAC,GAAG,+BAA+B;EACtGA,cAAc,CAACA,cAAc,CAAC,sBAAsB,CAAC,GAAG,EAAE,CAAC,GAAG,sBAAsB;EACpFA,cAAc,CAACA,cAAc,CAAC,sBAAsB,CAAC,GAAG,EAAE,CAAC,GAAG,sBAAsB;EACpFA,cAAc,CAACA,cAAc,CAAC,yBAAyB,CAAC,GAAG,EAAE,CAAC,GAAG,yBAAyB;EAC1FA,cAAc,CAACA,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM;EACpDA,cAAc,CAACA,cAAc,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5DA,cAAc,CAACA,cAAc,CAAC,yBAAyB,CAAC,GAAG,EAAE,CAAC,GAAG,yBAAyB;EAC1FA,cAAc,CAACA,cAAc,CAAC,yBAAyB,CAAC,GAAG,EAAE,CAAC,GAAG,yBAAyB;EAC1FA,cAAc,CAACA,cAAc,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxEA,cAAc,CAACA,cAAc,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxEA,cAAc,CAACA,cAAc,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB;EAC9EA,cAAc,CAACA,cAAc,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1DA,cAAc,CAACA,cAAc,CAAC,gCAAgC,CAAC,GAAG,EAAE,CAAC,GAAG,gCAAgC;EACxGA,cAAc,CAACA,cAAc,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9DA,cAAc,CAACA,cAAc,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5DA,cAAc,CAACA,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM;EACpDA,cAAc,CAACA,cAAc,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1DA,cAAc,CAACA,cAAc,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO;EACtDA,cAAc,CAACA,cAAc,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,KAAK;EAClDA,cAAc,CAACA,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM;EACpDA,cAAc,CAACA,cAAc,CAAC,wBAAwB,CAAC,GAAG,EAAE,CAAC,GAAG,wBAAwB;EACxFA,cAAc,CAACA,cAAc,CAAC,wBAAwB,CAAC,GAAG,EAAE,CAAC,GAAG,wBAAwB;EACxFA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EACtEA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EACtEA,cAAc,CAACA,cAAc,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,GAAG,kBAAkB;EAC5EA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;EACxDA,cAAc,CAACA,cAAc,CAAC,4BAA4B,CAAC,GAAG,EAAE,CAAC,GAAG,4BAA4B;EAChGA,cAAc,CAACA,cAAc,CAAC,qBAAqB,CAAC,GAAG,EAAE,CAAC,GAAG,qBAAqB;EAClFA,cAAc,CAACA,cAAc,CAAC,qBAAqB,CAAC,GAAG,EAAE,CAAC,GAAG,qBAAqB;EAClFA,cAAc,CAACA,cAAc,CAAC,wBAAwB,CAAC,GAAG,EAAE,CAAC,GAAG,wBAAwB;EACxFA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;EACxDA,cAAc,CAACA,cAAc,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1DA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;EACxDA,cAAc,CAACA,cAAc,CAAC,qBAAqB,CAAC,GAAG,EAAE,CAAC,GAAG,qBAAqB;EAClFA,cAAc,CAACA,cAAc,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,GAAG,cAAc;EACpEA,cAAc,CAACA,cAAc,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1EA,cAAc,CAACA,cAAc,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1EA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EACtEA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;EACxDA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;EACxDA,cAAc,CAACA,cAAc,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa;EAClEA,cAAc,CAACA,cAAc,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO;EACtDA,cAAc,CAACA,cAAc,CAAC,yBAAyB,CAAC,GAAG,EAAE,CAAC,GAAG,yBAAyB;EAC1FA,cAAc,CAACA,cAAc,CAAC,yBAAyB,CAAC,GAAG,EAAE,CAAC,GAAG,yBAAyB;EAC1FA,cAAc,CAACA,cAAc,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,YAAY;EAChEA,cAAc,CAACA,cAAc,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9DA,cAAc,CAACA,cAAc,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO;EACtDA,cAAc,CAACA,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM;AACxD,CAAC,EAAEA,cAAc,KAAKJ,OAAO,CAACI,cAAc,GAAGA,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;AACpE;AACA;AACA;AACA,MAAMD,2BAA2B,SAASS,OAAO,CAACO,YAAY,CAAC;EAC3DC,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAAC,cAAc,CAAC;IACrB,IAAI,CAACA,MAAM,GAAGA,MAAM;EACxB;AACJ;AACArB,OAAO,CAACG,2BAA2B,GAAGA,2BAA2B;AACjE;AACA;AACA;AACA,SAASmB,SAASA,CAACC,GAAG,EAAE;EACpB,OAAOA,GAAG,CAACC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;AACzD;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACxB,KAAK,EAAE;EACtB,OAAOA,KAAK,KAAKyB,SAAS;AAC9B;AACA;AACA;AACA;AACA,MAAMxB,kBAAkB,CAAC;EACrBkB,WAAWA,CAACO,QAAQ,EAAE;IAClB,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC5B;EACA,CAACC,MAAM,CAACD,QAAQ,IAAI;IAChB,OAAO,IAAI,CAACA,QAAQ;EACxB;EACA;EACAE,KAAKA,CAAA,EAAG;IACJ,MAAMC,IAAI,GAAG,IAAI,CAACH,QAAQ,CAACG,IAAI,CAAC,CAAC;IACjC,OAAOA,IAAI,CAACC,IAAI,GAAGL,SAAS,GAAGI,IAAI,CAAC7B,KAAK;EAC7C;AACJ;AACAD,OAAO,CAACE,kBAAkB,GAAGA,kBAAkB;AAC/C;AACA;AACA;AACA,SAAS8B,MAAMA,CAACC,SAAS,EAAEZ,MAAM,EAAEa,IAAI,EAAEjC,KAAK,EAAe;EAAA,IAAbkC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAV,SAAA,GAAAU,SAAA,MAAG,EAAE;EACvD,OAAO;IACHE,IAAI,EAAEL,SAAS;IACfZ,MAAM;IACNa,IAAI;IACJjC,KAAK;IACLsC,OAAO,EAAE,CAAC,CAAC,EAAE5B,UAAU,CAAC6B,gBAAgB,EAAE,CAAC,CAAC;MAAEP,SAAS;MAAEC,IAAI;MAAEb,MAAM;MAAEpB,KAAK;MAAEkC;IAAO,CAAC,CAAC;IACvFA;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA,UAAUM,OAAOA,CAACpB,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE,CAAE;AACrD,UAAU0C,SAASA,CAACtB,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACjD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC0B,OAAO,EAAE3C,KAAK,CAAC,EAAE;IAC/B,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAACyC,KAAK,EAAExB,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAClE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACyB,QAAQ,CAAC,IAAI,EAAE7C,KAAK,CAACoC,MAAM,IAAIhB,MAAM,CAACyB,QAAQ,CAAC,EAAE;IAClE,MAAMd,MAAM,CAAC5B,cAAc,CAAC2C,aAAa,EAAE1B,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAAC2B,QAAQ,CAAC,IAAI,EAAE/C,KAAK,CAACoC,MAAM,IAAIhB,MAAM,CAAC2B,QAAQ,CAAC,EAAE;IAClE,MAAMhB,MAAM,CAAC5B,cAAc,CAAC6C,aAAa,EAAE5B,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;EACA,KAAK,IAAIiD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjD,KAAK,CAACoC,MAAM,EAAEa,CAAC,EAAE,EAAE;IACnC,OAAOC,KAAK,CAAC9B,MAAM,CAAC+B,KAAK,EAAEV,UAAU,EAAE,GAAGR,IAAI,IAAIgB,CAAC,EAAE,EAAEjD,KAAK,CAACiD,CAAC,CAAC,CAAC;EACpE;EACA;EACA,IAAI7B,MAAM,CAACgC,WAAW,KAAK,IAAI,IAAI,CAAG,YAAY;IAAE,MAAMC,GAAG,GAAG,IAAIC,GAAG,CAAC,CAAC;IAAE,KAAK,MAAMC,OAAO,IAAIvD,KAAK,EAAE;MACpG,MAAMwD,MAAM,GAAG,CAAC,CAAC,EAAE3C,OAAO,CAAC4C,IAAI,EAAEF,OAAO,CAAC;MACzC,IAAIF,GAAG,CAACK,GAAG,CAACF,MAAM,CAAC,EAAE;QACjB,OAAO,KAAK;MAChB,CAAC,MACI;QACDH,GAAG,CAACM,GAAG,CAACH,MAAM,CAAC;MACnB;IACJ;IAAE,OAAO,IAAI;EAAE,CAAC,CAAE,CAAE,EAAE;IAClB,MAAMzB,MAAM,CAAC5B,cAAc,CAACyD,gBAAgB,EAAExC,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACtE;EACA;EACA,IAAI,EAAEwB,SAAS,CAACJ,MAAM,CAACyC,QAAQ,CAAC,IAAIrC,SAAS,CAACJ,MAAM,CAAC0C,WAAW,CAAC,IAAItC,SAAS,CAACJ,MAAM,CAAC2C,WAAW,CAAC,CAAC,EAAE;IACjG;EACJ;EACA,MAAMC,cAAc,GAAGxC,SAAS,CAACJ,MAAM,CAACyC,QAAQ,CAAC,GAAGzC,MAAM,CAACyC,QAAQ,GAAG,CAAC,CAAC,EAAE7C,OAAO,CAACiD,KAAK,EAAE,CAAC;EAC1F,MAAMC,aAAa,GAAGlE,KAAK,CAACmE,MAAM,CAAC,CAACC,GAAG,EAAEpE,KAAK,EAAEqE,KAAK,KAAMnB,KAAK,CAACc,cAAc,EAAEvB,UAAU,EAAE,GAAGR,IAAI,GAAGoC,KAAK,EAAE,EAAErE,KAAK,CAAC,CAAC6B,IAAI,CAAC,CAAC,CAACC,IAAI,KAAK,IAAI,GAAGsC,GAAG,GAAG,CAAC,GAAGA,GAAI,EAAE,CAAC,CAAC;EAChK,IAAIF,aAAa,KAAK,CAAC,EAAE;IACrB,MAAMnC,MAAM,CAAC5B,cAAc,CAACmE,aAAa,EAAElD,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;EACA,IAAI,CAAC,CAAC,EAAEiB,QAAQ,CAACsD,QAAQ,EAAEnD,MAAM,CAAC0C,WAAW,CAAC,IAAII,aAAa,GAAG9C,MAAM,CAAC0C,WAAW,EAAE;IAClF,MAAM/B,MAAM,CAAC5B,cAAc,CAACqE,gBAAgB,EAAEpD,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACtE;EACA,IAAI,CAAC,CAAC,EAAEiB,QAAQ,CAACsD,QAAQ,EAAEnD,MAAM,CAAC2C,WAAW,CAAC,IAAIG,aAAa,GAAG9C,MAAM,CAAC2C,WAAW,EAAE;IAClF,MAAMhC,MAAM,CAAC5B,cAAc,CAACsE,gBAAgB,EAAErD,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACtE;AACJ;AACA,UAAU0E,iBAAiBA,CAACtD,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACzD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC0D,eAAe,EAAE3E,KAAK,CAAC,EACrC,MAAM+B,MAAM,CAAC5B,cAAc,CAACyE,aAAa,EAAExD,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AACvE;AACA,UAAU6E,UAAUA,CAACzD,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAClD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC6D,QAAQ,EAAE9E,KAAK,CAAC,EAC9B,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAAC4E,MAAM,EAAE3D,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE,IAAIwB,SAAS,CAACJ,MAAM,CAAC4D,gBAAgB,CAAC,IAAI,EAAEhF,KAAK,GAAGoB,MAAM,CAAC4D,gBAAgB,CAAC,EAAE;IAC1E,MAAMjD,MAAM,CAAC5B,cAAc,CAAC8E,sBAAsB,EAAE7D,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC5E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAAC8D,gBAAgB,CAAC,IAAI,EAAElF,KAAK,GAAGoB,MAAM,CAAC8D,gBAAgB,CAAC,EAAE;IAC1E,MAAMnD,MAAM,CAAC5B,cAAc,CAACgF,sBAAsB,EAAE/D,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC5E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACgE,OAAO,CAAC,IAAI,EAAEpF,KAAK,IAAIoB,MAAM,CAACgE,OAAO,CAAC,EAAE;IACzD,MAAMrD,MAAM,CAAC5B,cAAc,CAACkF,aAAa,EAAEjE,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACkE,OAAO,CAAC,IAAI,EAAEtF,KAAK,IAAIoB,MAAM,CAACkE,OAAO,CAAC,EAAE;IACzD,MAAMvD,MAAM,CAAC5B,cAAc,CAACoF,aAAa,EAAEnE,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACoE,UAAU,CAAC,IAAI,EAAExF,KAAK,GAAGoB,MAAM,CAACoE,UAAU,KAAKT,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;IAC5E,MAAMhD,MAAM,CAAC5B,cAAc,CAACsF,gBAAgB,EAAErE,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACtE;AACJ;AACA,UAAU0F,WAAWA,CAACtE,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACnD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC0E,SAAS,EAAE3F,KAAK,CAAC,EAC/B,MAAM+B,MAAM,CAAC5B,cAAc,CAACyF,OAAO,EAAExE,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AACjE;AACA,UAAU6F,eAAeA,CAACzE,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACvD,OAAOkD,KAAK,CAAC9B,MAAM,CAAC0E,OAAO,EAAErD,UAAU,EAAER,IAAI,EAAEjC,KAAK,CAAC+F,SAAS,CAAC;AACnE;AACA,UAAUC,QAAQA,CAAC5E,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAChD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACgF,MAAM,EAAEjG,KAAK,CAAC,EAC5B,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAAC+F,IAAI,EAAE9E,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACjE,IAAIwB,SAAS,CAACJ,MAAM,CAAC+E,yBAAyB,CAAC,IAAI,EAAEnG,KAAK,CAACoG,OAAO,CAAC,CAAC,GAAGhF,MAAM,CAAC+E,yBAAyB,CAAC,EAAE;IACtG,MAAMpE,MAAM,CAAC5B,cAAc,CAACkG,6BAA6B,EAAEjF,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnF;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACkF,yBAAyB,CAAC,IAAI,EAAEtG,KAAK,CAACoG,OAAO,CAAC,CAAC,GAAGhF,MAAM,CAACkF,yBAAyB,CAAC,EAAE;IACtG,MAAMvE,MAAM,CAAC5B,cAAc,CAACoG,6BAA6B,EAAEnF,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnF;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACoF,gBAAgB,CAAC,IAAI,EAAExG,KAAK,CAACoG,OAAO,CAAC,CAAC,IAAIhF,MAAM,CAACoF,gBAAgB,CAAC,EAAE;IACrF,MAAMzE,MAAM,CAAC5B,cAAc,CAACsG,oBAAoB,EAAErF,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC1E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACsF,gBAAgB,CAAC,IAAI,EAAE1G,KAAK,CAACoG,OAAO,CAAC,CAAC,IAAIhF,MAAM,CAACsF,gBAAgB,CAAC,EAAE;IACrF,MAAM3E,MAAM,CAAC5B,cAAc,CAACwG,oBAAoB,EAAEvF,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC1E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACwF,mBAAmB,CAAC,IAAI,EAAE5G,KAAK,CAACoG,OAAO,CAAC,CAAC,GAAGhF,MAAM,CAACwF,mBAAmB,KAAK,CAAC,CAAC,EAAE;IAChG,MAAM7E,MAAM,CAAC5B,cAAc,CAAC0G,uBAAuB,EAAEzF,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC7E;AACJ;AACA,UAAU8G,YAAYA,CAAC1F,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACpD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC8F,UAAU,EAAE/G,KAAK,CAAC,EAChC,MAAM+B,MAAM,CAAC5B,cAAc,CAAC6G,QAAQ,EAAE5F,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AAClE;AACA,UAAUiH,WAAWA,CAAC7F,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACnD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACiG,SAAS,EAAElH,KAAK,CAAC,EAC/B,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAACgH,OAAO,EAAE/F,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACpE,IAAIwB,SAAS,CAACJ,MAAM,CAAC4D,gBAAgB,CAAC,IAAI,EAAEhF,KAAK,GAAGoB,MAAM,CAAC4D,gBAAgB,CAAC,EAAE;IAC1E,MAAMjD,MAAM,CAAC5B,cAAc,CAACiH,uBAAuB,EAAEhG,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC7E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAAC8D,gBAAgB,CAAC,IAAI,EAAElF,KAAK,GAAGoB,MAAM,CAAC8D,gBAAgB,CAAC,EAAE;IAC1E,MAAMnD,MAAM,CAAC5B,cAAc,CAACkH,uBAAuB,EAAEjG,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC7E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACgE,OAAO,CAAC,IAAI,EAAEpF,KAAK,IAAIoB,MAAM,CAACgE,OAAO,CAAC,EAAE;IACzD,MAAMrD,MAAM,CAAC5B,cAAc,CAACmH,cAAc,EAAElG,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACpE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACkE,OAAO,CAAC,IAAI,EAAEtF,KAAK,IAAIoB,MAAM,CAACkE,OAAO,CAAC,EAAE;IACzD,MAAMvD,MAAM,CAAC5B,cAAc,CAACoH,cAAc,EAAEnG,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACpE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACoE,UAAU,CAAC,IAAI,EAAExF,KAAK,GAAGoB,MAAM,CAACoE,UAAU,KAAK,CAAC,CAAC,EAAE;IACpE,MAAMzD,MAAM,CAAC5B,cAAc,CAACqH,iBAAiB,EAAEpG,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACvE;AACJ;AACA,UAAUyH,aAAaA,CAACrG,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACrD,IAAI0H,QAAQ,GAAG,KAAK;EACpB,KAAK,MAAMC,KAAK,IAAIvG,MAAM,CAACwG,KAAK,EAAE;IAC9B,KAAK,MAAMC,KAAK,IAAI3E,KAAK,CAACyE,KAAK,EAAElF,UAAU,EAAER,IAAI,EAAEjC,KAAK,CAAC,EAAE;MACvD0H,QAAQ,GAAG,IAAI;MACf,MAAMG,KAAK;IACf;EACJ;EACA,IAAIH,QAAQ,EAAE;IACV,OAAO,MAAM3F,MAAM,CAAC5B,cAAc,CAAC2H,SAAS,EAAE1G,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACtE;EACA,IAAIoB,MAAM,CAAC2G,qBAAqB,KAAK,KAAK,EAAE;IACxC,MAAMC,QAAQ,GAAG,IAAIC,MAAM,CAAC,CAAC,CAAC,EAAE1H,OAAO,CAAC2H,YAAY,EAAE9G,MAAM,CAAC,CAAC;IAC9D,KAAK,MAAM+G,QAAQ,IAAItI,MAAM,CAACuI,mBAAmB,CAACpI,KAAK,CAAC,EAAE;MACtD,IAAI,CAACgI,QAAQ,CAACK,IAAI,CAACF,QAAQ,CAAC,EAAE;QAC1B,MAAMpG,MAAM,CAAC5B,cAAc,CAACmI,8BAA8B,EAAElH,MAAM,EAAE,GAAGa,IAAI,IAAIkG,QAAQ,EAAE,EAAEnI,KAAK,CAAC;MACrG;IACJ;EACJ;EACA,IAAI,OAAOoB,MAAM,CAAC2G,qBAAqB,KAAK,QAAQ,EAAE;IAClD,MAAMC,QAAQ,GAAG,IAAIC,MAAM,CAAC,CAAC,CAAC,EAAE1H,OAAO,CAAC2H,YAAY,EAAE9G,MAAM,CAAC,CAAC;IAC9D,KAAK,MAAM+G,QAAQ,IAAItI,MAAM,CAACuI,mBAAmB,CAACpI,KAAK,CAAC,EAAE;MACtD,IAAI,CAACgI,QAAQ,CAACK,IAAI,CAACF,QAAQ,CAAC,EAAE;QAC1B,MAAMtG,IAAI,GAAGqB,KAAK,CAAC9B,MAAM,CAAC2G,qBAAqB,EAAEtF,UAAU,EAAE,GAAGR,IAAI,IAAIkG,QAAQ,EAAE,EAAEnI,KAAK,CAACmI,QAAQ,CAAC,CAAC,CAACtG,IAAI,CAAC,CAAC;QAC3G,IAAI,CAACA,IAAI,CAACC,IAAI,EACV,MAAMD,IAAI,CAAC7B,KAAK,CAAC,CAAC;MAC1B;IACJ;EACJ;AACJ;AACA,UAAUuI,YAAYA,CAACnH,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACpD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACuH,UAAU,EAAExI,KAAK,CAAC,EAChC,MAAM+B,MAAM,CAAC5B,cAAc,CAACsI,QAAQ,EAAErH,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AAClE;AACA,UAAU0I,WAAWA,CAACtH,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACnD,IAAI,EAAEA,KAAK,KAAKoB,MAAM,CAACuH,KAAK,CAAC,EACzB,MAAM5G,MAAM,CAAC5B,cAAc,CAACyI,OAAO,EAAExH,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AACjE;AACA,UAAU6I,SAASA,CAACzH,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACjD,MAAM+B,MAAM,CAAC5B,cAAc,CAAC8D,KAAK,EAAE7C,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AAC3D;AACA,UAAU8I,OAAOA,CAAC1H,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAC/C,IAAIkD,KAAK,CAAC9B,MAAM,CAAC2H,GAAG,EAAEtG,UAAU,EAAER,IAAI,EAAEjC,KAAK,CAAC,CAAC6B,IAAI,CAAC,CAAC,CAACC,IAAI,KAAK,IAAI,EAC/D,MAAMC,MAAM,CAAC5B,cAAc,CAAC6I,GAAG,EAAE5H,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AAC7D;AACA,UAAUiJ,QAAQA,CAAC7H,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAChD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACiI,MAAM,EAAElJ,KAAK,CAAC,EAC5B,MAAM+B,MAAM,CAAC5B,cAAc,CAACgJ,IAAI,EAAE/H,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AAC9D;AACA,UAAUoJ,UAAUA,CAAChI,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAClD,IAAI,CAACK,OAAO,CAACgJ,gBAAgB,CAACC,YAAY,CAACtJ,KAAK,CAAC,EAC7C,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAACoJ,MAAM,EAAEnI,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE,IAAIwB,SAAS,CAACJ,MAAM,CAAC4D,gBAAgB,CAAC,IAAI,EAAEhF,KAAK,GAAGoB,MAAM,CAAC4D,gBAAgB,CAAC,EAAE;IAC1E,MAAMjD,MAAM,CAAC5B,cAAc,CAACqJ,sBAAsB,EAAEpI,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC5E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAAC8D,gBAAgB,CAAC,IAAI,EAAElF,KAAK,GAAGoB,MAAM,CAAC8D,gBAAgB,CAAC,EAAE;IAC1E,MAAMnD,MAAM,CAAC5B,cAAc,CAACsJ,sBAAsB,EAAErI,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC5E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACgE,OAAO,CAAC,IAAI,EAAEpF,KAAK,IAAIoB,MAAM,CAACgE,OAAO,CAAC,EAAE;IACzD,MAAMrD,MAAM,CAAC5B,cAAc,CAACuJ,aAAa,EAAEtI,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACkE,OAAO,CAAC,IAAI,EAAEtF,KAAK,IAAIoB,MAAM,CAACkE,OAAO,CAAC,EAAE;IACzD,MAAMvD,MAAM,CAAC5B,cAAc,CAACwJ,aAAa,EAAEvI,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACoE,UAAU,CAAC,IAAI,EAAExF,KAAK,GAAGoB,MAAM,CAACoE,UAAU,KAAK,CAAC,CAAC,EAAE;IACpE,MAAMzD,MAAM,CAAC5B,cAAc,CAACyJ,gBAAgB,EAAExI,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACtE;AACJ;AACA,UAAU6J,UAAUA,CAACzI,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAClD,IAAI,CAACK,OAAO,CAACgJ,gBAAgB,CAACS,YAAY,CAAC9J,KAAK,CAAC,EAC7C,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAACN,MAAM,EAAEuB,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE,IAAIwB,SAAS,CAACJ,MAAM,CAAC2I,aAAa,CAAC,IAAI,EAAElK,MAAM,CAACuI,mBAAmB,CAACpI,KAAK,CAAC,CAACoC,MAAM,IAAIhB,MAAM,CAAC2I,aAAa,CAAC,EAAE;IACxG,MAAMhI,MAAM,CAAC5B,cAAc,CAAC6J,mBAAmB,EAAE5I,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACzE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAAC6I,aAAa,CAAC,IAAI,EAAEpK,MAAM,CAACuI,mBAAmB,CAACpI,KAAK,CAAC,CAACoC,MAAM,IAAIhB,MAAM,CAAC6I,aAAa,CAAC,EAAE;IACxG,MAAMlI,MAAM,CAAC5B,cAAc,CAAC+J,mBAAmB,EAAE9I,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACzE;EACA,MAAMmK,YAAY,GAAGvH,KAAK,CAACwH,OAAO,CAAChJ,MAAM,CAACiJ,QAAQ,CAAC,GAAGjJ,MAAM,CAACiJ,QAAQ,GAAG,EAAE;EAC1E,MAAMC,SAAS,GAAGzK,MAAM,CAACuI,mBAAmB,CAAChH,MAAM,CAACmJ,UAAU,CAAC;EAC/D,MAAMC,WAAW,GAAG3K,MAAM,CAACuI,mBAAmB,CAACpI,KAAK,CAAC;EACrD,KAAK,MAAMyK,WAAW,IAAIN,YAAY,EAAE;IACpC,IAAIK,WAAW,CAACE,QAAQ,CAACD,WAAW,CAAC,EACjC;IACJ,MAAM1I,MAAM,CAAC5B,cAAc,CAACwK,sBAAsB,EAAEvJ,MAAM,CAACmJ,UAAU,CAACE,WAAW,CAAC,EAAE,GAAGxI,IAAI,IAAIZ,SAAS,CAACoJ,WAAW,CAAC,EAAE,EAAEhJ,SAAS,CAAC;EACvI;EACA,IAAIL,MAAM,CAACwJ,oBAAoB,KAAK,KAAK,EAAE;IACvC,KAAK,MAAMzC,QAAQ,IAAIqC,WAAW,EAAE;MAChC,IAAI,CAACF,SAAS,CAACI,QAAQ,CAACvC,QAAQ,CAAC,EAAE;QAC/B,MAAMpG,MAAM,CAAC5B,cAAc,CAAC0K,0BAA0B,EAAEzJ,MAAM,EAAE,GAAGa,IAAI,IAAIZ,SAAS,CAAC8G,QAAQ,CAAC,EAAE,EAAEnI,KAAK,CAACmI,QAAQ,CAAC,CAAC;MACtH;IACJ;EACJ;EACA,IAAI,OAAO/G,MAAM,CAACwJ,oBAAoB,KAAK,QAAQ,EAAE;IACjD,KAAK,MAAMzC,QAAQ,IAAIqC,WAAW,EAAE;MAChC,IAAIF,SAAS,CAACI,QAAQ,CAACvC,QAAQ,CAAC,EAC5B;MACJ,OAAOjF,KAAK,CAAC9B,MAAM,CAACwJ,oBAAoB,EAAEnI,UAAU,EAAE,GAAGR,IAAI,IAAIZ,SAAS,CAAC8G,QAAQ,CAAC,EAAE,EAAEnI,KAAK,CAACmI,QAAQ,CAAC,CAAC;IAC5G;EACJ;EACA,KAAK,MAAM2C,QAAQ,IAAIR,SAAS,EAAE;IAC9B,MAAMS,QAAQ,GAAG3J,MAAM,CAACmJ,UAAU,CAACO,QAAQ,CAAC;IAC5C,IAAI1J,MAAM,CAACiJ,QAAQ,IAAIjJ,MAAM,CAACiJ,QAAQ,CAACK,QAAQ,CAACI,QAAQ,CAAC,EAAE;MACvD,OAAO5H,KAAK,CAAC6H,QAAQ,EAAEtI,UAAU,EAAE,GAAGR,IAAI,IAAIZ,SAAS,CAACyJ,QAAQ,CAAC,EAAE,EAAE9K,KAAK,CAAC8K,QAAQ,CAAC,CAAC;MACrF,IAAI,CAAC,CAAC,EAAErK,mBAAmB,CAACuK,qBAAqB,EAAE5J,MAAM,CAAC,IAAI,EAAE0J,QAAQ,IAAI9K,KAAK,CAAC,EAAE;QAChF,MAAM+B,MAAM,CAAC5B,cAAc,CAACwK,sBAAsB,EAAEI,QAAQ,EAAE,GAAG9I,IAAI,IAAIZ,SAAS,CAACyJ,QAAQ,CAAC,EAAE,EAAErJ,SAAS,CAAC;MAC9G;IACJ,CAAC,MACI;MACD,IAAIpB,OAAO,CAACgJ,gBAAgB,CAAC4B,uBAAuB,CAACjL,KAAK,EAAE8K,QAAQ,CAAC,EAAE;QACnE,OAAO5H,KAAK,CAAC6H,QAAQ,EAAEtI,UAAU,EAAE,GAAGR,IAAI,IAAIZ,SAAS,CAACyJ,QAAQ,CAAC,EAAE,EAAE9K,KAAK,CAAC8K,QAAQ,CAAC,CAAC;MACzF;IACJ;EACJ;AACJ;AACA,UAAUI,WAAWA,CAAC9J,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACnD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACkK,SAAS,EAAEnL,KAAK,CAAC,EAC/B,MAAM+B,MAAM,CAAC5B,cAAc,CAACiL,OAAO,EAAEhK,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AACjE;AACA,UAAUqL,UAAUA,CAACjK,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAClD,IAAI,CAACK,OAAO,CAACgJ,gBAAgB,CAACiC,YAAY,CAACtL,KAAK,CAAC,EAC7C,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAACN,MAAM,EAAEuB,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE,IAAIwB,SAAS,CAACJ,MAAM,CAAC2I,aAAa,CAAC,IAAI,EAAElK,MAAM,CAACuI,mBAAmB,CAACpI,KAAK,CAAC,CAACoC,MAAM,IAAIhB,MAAM,CAAC2I,aAAa,CAAC,EAAE;IACxG,MAAMhI,MAAM,CAAC5B,cAAc,CAAC6J,mBAAmB,EAAE5I,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACzE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAAC6I,aAAa,CAAC,IAAI,EAAEpK,MAAM,CAACuI,mBAAmB,CAACpI,KAAK,CAAC,CAACoC,MAAM,IAAIhB,MAAM,CAAC6I,aAAa,CAAC,EAAE;IACxG,MAAMlI,MAAM,CAAC5B,cAAc,CAAC+J,mBAAmB,EAAE9I,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACzE;EACA,MAAM,CAACuL,UAAU,EAAEC,aAAa,CAAC,GAAG3L,MAAM,CAAC4L,OAAO,CAACrK,MAAM,CAACsK,iBAAiB,CAAC,CAAC,CAAC,CAAC;EAC/E,MAAMC,KAAK,GAAG,IAAI1D,MAAM,CAACsD,UAAU,CAAC;EACpC,KAAK,MAAM,CAACK,WAAW,EAAEC,aAAa,CAAC,IAAIhM,MAAM,CAAC4L,OAAO,CAACzL,KAAK,CAAC,EAAE;IAC9D,IAAI2L,KAAK,CAACtD,IAAI,CAACuD,WAAW,CAAC,EACvB,OAAO1I,KAAK,CAACsI,aAAa,EAAE/I,UAAU,EAAE,GAAGR,IAAI,IAAIZ,SAAS,CAACuK,WAAW,CAAC,EAAE,EAAEC,aAAa,CAAC;EACnG;EACA,IAAI,OAAOzK,MAAM,CAACwJ,oBAAoB,KAAK,QAAQ,EAAE;IACjD,KAAK,MAAM,CAACgB,WAAW,EAAEC,aAAa,CAAC,IAAIhM,MAAM,CAAC4L,OAAO,CAACzL,KAAK,CAAC,EAAE;MAC9D,IAAI,CAAC2L,KAAK,CAACtD,IAAI,CAACuD,WAAW,CAAC,EACxB,OAAO1I,KAAK,CAAC9B,MAAM,CAACwJ,oBAAoB,EAAEnI,UAAU,EAAE,GAAGR,IAAI,IAAIZ,SAAS,CAACuK,WAAW,CAAC,EAAE,EAAEC,aAAa,CAAC;IACjH;EACJ;EACA,IAAIzK,MAAM,CAACwJ,oBAAoB,KAAK,KAAK,EAAE;IACvC,KAAK,MAAM,CAACgB,WAAW,EAAEC,aAAa,CAAC,IAAIhM,MAAM,CAAC4L,OAAO,CAACzL,KAAK,CAAC,EAAE;MAC9D,IAAI2L,KAAK,CAACtD,IAAI,CAACuD,WAAW,CAAC,EACvB;MACJ,OAAO,MAAM7J,MAAM,CAAC5B,cAAc,CAAC0K,0BAA0B,EAAEzJ,MAAM,EAAE,GAAGa,IAAI,IAAIZ,SAAS,CAACuK,WAAW,CAAC,EAAE,EAAEC,aAAa,CAAC;IAC9H;EACJ;AACJ;AACA,UAAUC,OAAOA,CAAC1K,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAC/C,OAAOkD,KAAK,CAAC,CAAC,CAAC,EAAEtC,OAAO,CAACmL,KAAK,EAAE3K,MAAM,EAAEqB,UAAU,CAAC,EAAEA,UAAU,EAAER,IAAI,EAAEjC,KAAK,CAAC;AACjF;AACA,UAAUgM,UAAUA,CAAC5K,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAClD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACgL,QAAQ,EAAEjM,KAAK,CAAC,EAC9B,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAAC+L,MAAM,EAAE9K,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE,IAAIwB,SAAS,CAACJ,MAAM,CAAC+K,SAAS,CAAC,IAAI,EAAEnM,KAAK,CAACoC,MAAM,IAAIhB,MAAM,CAAC+K,SAAS,CAAC,EAAE;IACpE,MAAMpK,MAAM,CAAC5B,cAAc,CAACiM,eAAe,EAAEhL,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACrE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACiL,SAAS,CAAC,IAAI,EAAErM,KAAK,CAACoC,MAAM,IAAIhB,MAAM,CAACiL,SAAS,CAAC,EAAE;IACpE,MAAMtK,MAAM,CAAC5B,cAAc,CAACmM,eAAe,EAAElL,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACrE;EACA,MAAM2L,KAAK,GAAG,IAAI1D,MAAM,CAAC7G,MAAM,CAACmL,MAAM,EAAEnL,MAAM,CAACoL,KAAK,CAAC;EACrD,IAAI,CAACb,KAAK,CAACtD,IAAI,CAACrI,KAAK,CAAC,EAAE;IACpB,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAAC8H,MAAM,EAAE7G,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;AACJ;AACA,UAAUyM,UAAUA,CAACrL,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAClD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACgL,QAAQ,EAAEjM,KAAK,CAAC,EAC9B,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAAC+L,MAAM,EAAE9K,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE,IAAIwB,SAAS,CAACJ,MAAM,CAAC+K,SAAS,CAAC,IAAI,EAAEnM,KAAK,CAACoC,MAAM,IAAIhB,MAAM,CAAC+K,SAAS,CAAC,EAAE;IACpE,MAAMpK,MAAM,CAAC5B,cAAc,CAACiM,eAAe,EAAEhL,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACrE;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACiL,SAAS,CAAC,IAAI,EAAErM,KAAK,CAACoC,MAAM,IAAIhB,MAAM,CAACiL,SAAS,CAAC,EAAE;IACpE,MAAMtK,MAAM,CAAC5B,cAAc,CAACmM,eAAe,EAAElL,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACrE;EACA,IAAI,CAAC,CAAC,EAAEiB,QAAQ,CAACgL,QAAQ,EAAE7K,MAAM,CAACsL,OAAO,CAAC,EAAE;IACxC,MAAMf,KAAK,GAAG,IAAI1D,MAAM,CAAC7G,MAAM,CAACsL,OAAO,CAAC;IACxC,IAAI,CAACf,KAAK,CAACtD,IAAI,CAACrI,KAAK,CAAC,EAAE;MACpB,MAAM+B,MAAM,CAAC5B,cAAc,CAACwM,aAAa,EAAEvL,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;IACnE;EACJ;EACA,IAAI,CAAC,CAAC,EAAEiB,QAAQ,CAACgL,QAAQ,EAAE7K,MAAM,CAACwL,MAAM,CAAC,EAAE;IACvC,IAAI,CAACpM,OAAO,CAACqM,cAAc,CAACC,GAAG,CAAC1L,MAAM,CAACwL,MAAM,CAAC,EAAE;MAC5C,MAAM7K,MAAM,CAAC5B,cAAc,CAAC4M,mBAAmB,EAAE3L,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;IACzE,CAAC,MACI;MACD,MAAM4M,MAAM,GAAGpM,OAAO,CAACqM,cAAc,CAACG,GAAG,CAAC5L,MAAM,CAACwL,MAAM,CAAC;MACxD,IAAI,CAACA,MAAM,CAAC5M,KAAK,CAAC,EAAE;QAChB,MAAM+B,MAAM,CAAC5B,cAAc,CAAC8M,YAAY,EAAE7L,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;MAClE;IACJ;EACJ;AACJ;AACA,UAAUkN,UAAUA,CAAC9L,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAClD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACkM,QAAQ,EAAEnN,KAAK,CAAC,EAC9B,MAAM+B,MAAM,CAAC5B,cAAc,CAACwB,MAAM,EAAEP,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AAChE;AACA,UAAUoN,mBAAmBA,CAAChM,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAC3D,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACgL,QAAQ,EAAEjM,KAAK,CAAC,EAC9B,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAAC+L,MAAM,EAAE9K,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE,MAAM2L,KAAK,GAAG,IAAI1D,MAAM,CAAC7G,MAAM,CAACsL,OAAO,CAAC;EACxC,IAAI,CAACf,KAAK,CAACtD,IAAI,CAACrI,KAAK,CAAC,EAAE;IACpB,MAAM+B,MAAM,CAAC5B,cAAc,CAACwM,aAAa,EAAEvL,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACnE;AACJ;AACA,UAAUqN,QAAQA,CAACjM,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAChD,OAAOkD,KAAK,CAAC,CAAC,CAAC,EAAEtC,OAAO,CAACmL,KAAK,EAAE3K,MAAM,EAAEqB,UAAU,CAAC,EAAEA,UAAU,EAAER,IAAI,EAAEjC,KAAK,CAAC;AACjF;AACA,UAAUsN,SAASA,CAAClM,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACjD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC0B,OAAO,EAAE3C,KAAK,CAAC,EAC7B,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAACoN,KAAK,EAAEnM,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAClE,IAAIoB,MAAM,CAAC+B,KAAK,KAAK1B,SAAS,IAAI,EAAEzB,KAAK,CAACoC,MAAM,KAAK,CAAC,CAAC,EAAE;IACrD,OAAO,MAAML,MAAM,CAAC5B,cAAc,CAACqN,WAAW,EAAEpM,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACxE;EACA,IAAI,EAAEA,KAAK,CAACoC,MAAM,KAAKhB,MAAM,CAAC2B,QAAQ,CAAC,EAAE;IACrC,OAAO,MAAMhB,MAAM,CAAC5B,cAAc,CAACqN,WAAW,EAAEpM,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACxE;EACA,IAAI,CAACoB,MAAM,CAAC+B,KAAK,EAAE;IACf;EACJ;EACA,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,CAAC+B,KAAK,CAACf,MAAM,EAAEa,CAAC,EAAE,EAAE;IAC1C,OAAOC,KAAK,CAAC9B,MAAM,CAAC+B,KAAK,CAACF,CAAC,CAAC,EAAER,UAAU,EAAE,GAAGR,IAAI,IAAIgB,CAAC,EAAE,EAAEjD,KAAK,CAACiD,CAAC,CAAC,CAAC;EACvE;AACJ;AACA,UAAUwK,aAAaA,CAACrM,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACrD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACyM,WAAW,EAAE1N,KAAK,CAAC,EACjC,MAAM+B,MAAM,CAAC5B,cAAc,CAACwN,SAAS,EAAEvM,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AACnE;AACA,UAAU4N,SAASA,CAACxM,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACjD,IAAI,CAAC,CAAC,EAAEc,OAAO,CAAC+M,KAAK,EAAEzM,MAAM,EAAEqB,UAAU,EAAEzC,KAAK,CAAC,EAC7C;EACJ,MAAMkC,MAAM,GAAGd,MAAM,CAAC0M,KAAK,CAACC,GAAG,CAAEC,OAAO,IAAK,IAAI/N,kBAAkB,CAACiD,KAAK,CAAC8K,OAAO,EAAEvL,UAAU,EAAER,IAAI,EAAEjC,KAAK,CAAC,CAAC,CAAC;EAC7G,MAAM+B,MAAM,CAAC5B,cAAc,CAAC8N,KAAK,EAAE7M,MAAM,EAAEa,IAAI,EAAEjC,KAAK,EAAEkC,MAAM,CAAC;AACnE;AACA,UAAUgM,cAAcA,CAAC9M,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EACtD,IAAI,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAACkN,YAAY,EAAEnO,KAAK,CAAC,EAClC,OAAO,MAAM+B,MAAM,CAAC5B,cAAc,CAACiO,UAAU,EAAEhN,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EACvE,IAAIwB,SAAS,CAACJ,MAAM,CAACiN,aAAa,CAAC,IAAI,EAAErO,KAAK,CAACoC,MAAM,IAAIhB,MAAM,CAACiN,aAAa,CAAC,EAAE;IAC5E,MAAMtM,MAAM,CAAC5B,cAAc,CAACmO,uBAAuB,EAAElN,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC7E;EACA,IAAIwB,SAAS,CAACJ,MAAM,CAACmN,aAAa,CAAC,IAAI,EAAEvO,KAAK,CAACoC,MAAM,IAAIhB,MAAM,CAACmN,aAAa,CAAC,EAAE;IAC5E,MAAMxM,MAAM,CAAC5B,cAAc,CAACqO,uBAAuB,EAAEpN,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;EAC7E;AACJ;AACA,UAAUyO,WAAWA,CAACrN,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE,CAAE;AACzD,UAAU0O,QAAQA,CAACtN,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAChD,IAAI,CAACK,OAAO,CAACgJ,gBAAgB,CAACsF,UAAU,CAAC3O,KAAK,CAAC,EAC3C,MAAM+B,MAAM,CAAC5B,cAAc,CAACyO,IAAI,EAAExN,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AAC9D;AACA,UAAU6O,QAAQA,CAACzN,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAChD,MAAM8O,KAAK,GAAGtO,OAAO,CAACuO,YAAY,CAAC/B,GAAG,CAAC5L,MAAM,CAACL,OAAO,CAACiO,IAAI,CAAC,CAAC;EAC5D,IAAI,CAACF,KAAK,CAAC1N,MAAM,EAAEpB,KAAK,CAAC,EACrB,MAAM+B,MAAM,CAAC5B,cAAc,CAAC6O,IAAI,EAAE5N,MAAM,EAAEa,IAAI,EAAEjC,KAAK,CAAC;AAC9D;AACA,UAAUkD,KAAKA,CAAC9B,MAAM,EAAEqB,UAAU,EAAER,IAAI,EAAEjC,KAAK,EAAE;EAC7C,MAAMiP,WAAW,GAAGzN,SAAS,CAACJ,MAAM,CAAC8N,GAAG,CAAC,GAAG,CAAC,GAAGzM,UAAU,EAAErB,MAAM,CAAC,GAAGqB,UAAU;EAChF,MAAM0M,OAAO,GAAG/N,MAAM;EACtB,QAAQ+N,OAAO,CAACpO,OAAO,CAACiO,IAAI,CAAC;IACzB,KAAK,KAAK;MACN,OAAO,OAAOxM,OAAO,CAAC2M,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC5D,KAAK,OAAO;MACR,OAAO,OAAO0C,SAAS,CAACyM,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC9D,KAAK,eAAe;MAChB,OAAO,OAAO0E,iBAAiB,CAACyK,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IACtE,KAAK,QAAQ;MACT,OAAO,OAAO6E,UAAU,CAACsK,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC/D,KAAK,SAAS;MACV,OAAO,OAAO0F,WAAW,CAACyJ,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAChE,KAAK,aAAa;MACd,OAAO,OAAO6F,eAAe,CAACsJ,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IACpE,KAAK,MAAM;MACP,OAAO,OAAOgG,QAAQ,CAACmJ,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC7D,KAAK,UAAU;MACX,OAAO,OAAO8G,YAAY,CAACqI,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IACjE,KAAK,SAAS;MACV,OAAO,OAAOiH,WAAW,CAACkI,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAChE,KAAK,WAAW;MACZ,OAAO,OAAOyH,aAAa,CAAC0H,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAClE,KAAK,UAAU;MACX,OAAO,OAAOuI,YAAY,CAAC4G,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IACjE,KAAK,SAAS;MACV,OAAO,OAAO0I,WAAW,CAACyG,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAChE,KAAK,OAAO;MACR,OAAO,OAAO6I,SAAS,CAACsG,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC9D,KAAK,KAAK;MACN,OAAO,OAAO8I,OAAO,CAACqG,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC5D,KAAK,MAAM;MACP,OAAO,OAAOiJ,QAAQ,CAACkG,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC7D,KAAK,QAAQ;MACT,OAAO,OAAOoJ,UAAU,CAAC+F,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC/D,KAAK,QAAQ;MACT,OAAO,OAAO6J,UAAU,CAACsF,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC/D,KAAK,SAAS;MACV,OAAO,OAAOkL,WAAW,CAACiE,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAChE,KAAK,QAAQ;MACT,OAAO,OAAOqL,UAAU,CAAC8D,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC/D,KAAK,KAAK;MACN,OAAO,OAAO8L,OAAO,CAACqD,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC5D,KAAK,QAAQ;MACT,OAAO,OAAOgM,UAAU,CAACmD,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC/D,KAAK,QAAQ;MACT,OAAO,OAAOyM,UAAU,CAAC0C,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC/D,KAAK,QAAQ;MACT,OAAO,OAAOkN,UAAU,CAACiC,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC/D,KAAK,iBAAiB;MAClB,OAAO,OAAOoN,mBAAmB,CAAC+B,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IACxE,KAAK,MAAM;MACP,OAAO,OAAOqN,QAAQ,CAAC8B,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC7D,KAAK,OAAO;MACR,OAAO,OAAOsN,SAAS,CAAC6B,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC9D,KAAK,WAAW;MACZ,OAAO,OAAOyN,aAAa,CAAC0B,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAClE,KAAK,OAAO;MACR,OAAO,OAAO4N,SAAS,CAACuB,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC9D,KAAK,YAAY;MACb,OAAO,OAAOkO,cAAc,CAACiB,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IACnE,KAAK,SAAS;MACV,OAAO,OAAOyO,WAAW,CAACU,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAChE,KAAK,MAAM;MACP,OAAO,OAAO0O,QAAQ,CAACS,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;IAC7D;MACI,IAAI,CAACQ,OAAO,CAACuO,YAAY,CAACjC,GAAG,CAACqC,OAAO,CAACpO,OAAO,CAACiO,IAAI,CAAC,CAAC,EAChD,MAAM,IAAI9O,2BAA2B,CAACkB,MAAM,CAAC;MACjD,OAAO,OAAOyN,QAAQ,CAACM,OAAO,EAAEF,WAAW,EAAEhN,IAAI,EAAEjC,KAAK,CAAC;EACjE;AACJ;AACA;AACA,SAASI,MAAMA,CAAA,EAAU;EACrB,MAAMsB,QAAQ,GAAGS,SAAA,CAAKC,MAAM,KAAK,CAAC,GAAGc,KAAK,CAAAf,SAAA,CAAAC,MAAA,QAAAX,SAAA,GAAAU,SAAA,KAAAA,SAAA,CAAAC,MAAA,QAAAX,SAAA,GAAAU,SAAA,KAAmB,EAAE,EAAAA,SAAA,CAAAC,MAAA,QAAAX,SAAA,GAAAU,SAAA,GAAS,CAAC,GAAGe,KAAK,CAAAf,SAAA,CAAAC,MAAA,QAAAX,SAAA,GAAAU,SAAA,KAAU,EAAE,EAAE,EAAE,EAAAA,SAAA,CAAAC,MAAA,QAAAX,SAAA,GAAAU,SAAA,GAAS,CAAC;EAC3G,OAAO,IAAIlC,kBAAkB,CAACyB,QAAQ,CAAC;AAC3C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}