{"ast":null,"code":"import { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { createInitializeInstruction, createRemoveKeyInstruction, createUpdateAuthorityInstruction, createUpdateFieldInstruction, pack, unpack } from '@solana/spl-token-metadata';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\nimport { updateTokenMetadata } from './state.js';\nimport { TokenAccountNotFoundError } from '../../errors.js';\nimport { unpackMint } from '../../state/index.js';\nasync function getAdditionalRentForNewMetadata(connection, address, tokenMetadata) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_2022_PROGRAM_ID;\n  const info = await connection.getAccountInfo(address);\n  if (!info) {\n    throw new TokenAccountNotFoundError();\n  }\n  const extensionLen = pack(tokenMetadata).length;\n  const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);\n  if (newAccountLen <= info.data.length) {\n    return 0;\n  }\n  const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n  return newRentExemptMinimum - info.lamports;\n}\nasync function getAdditionalRentForUpdatedMetadata(connection, address, field, value) {\n  let programId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TOKEN_2022_PROGRAM_ID;\n  const info = await connection.getAccountInfo(address);\n  if (!info) {\n    throw new TokenAccountNotFoundError();\n  }\n  const mint = unpackMint(address, info, programId);\n  const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\n  if (extensionData === null) {\n    throw new Error('TokenMetadata extension not initialized');\n  }\n  const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\n  const extensionLen = pack(updatedTokenMetadata).length;\n  const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);\n  if (newAccountLen <= info.data.length) {\n    return 0;\n  }\n  const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n  return newRentExemptMinimum - info.lamports;\n}\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri) {\n  let multiSigners = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n  let confirmOptions = arguments.length > 9 ? arguments[9] : undefined;\n  let programId = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : TOKEN_2022_PROGRAM_ID;\n  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n  const transaction = new Transaction().add(createInitializeInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority,\n    mint,\n    mintAuthority: mintAuthorityPublicKey,\n    name,\n    symbol,\n    uri\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Initializes a TLV entry with the basic token-metadata fields,\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri) {\n  let multiSigners = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n  let confirmOptions = arguments.length > 9 ? arguments[9] : undefined;\n  let programId = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : TOKEN_2022_PROGRAM_ID;\n  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n  const transaction = new Transaction();\n  const lamports = await getAdditionalRentForNewMetadata(connection, mint, {\n    updateAuthority,\n    mint,\n    name,\n    symbol,\n    uri,\n    additionalMetadata: []\n  }, programId);\n  if (lamports > 0) {\n    transaction.add(SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: mint,\n      lamports: lamports\n    }));\n  }\n  transaction.add(createInitializeInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority,\n    mint,\n    mintAuthority: mintAuthorityPublicKey,\n    name,\n    symbol,\n    uri\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value) {\n  let multiSigners = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  let confirmOptions = arguments.length > 7 ? arguments[7] : undefined;\n  let programId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : TOKEN_2022_PROGRAM_ID;\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createUpdateFieldInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    field,\n    value\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value) {\n  let multiSigners = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  let confirmOptions = arguments.length > 7 ? arguments[7] : undefined;\n  let programId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : TOKEN_2022_PROGRAM_ID;\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction();\n  const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n  if (lamports > 0) {\n    transaction.add(SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: mint,\n      lamports: lamports\n    }));\n  }\n  transaction.add(createUpdateFieldInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    field,\n    value\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Remove a field in a token-metadata account.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param key              Key to remove in the additional metadata portion\n * @param idempotent       When true, instruction will not error if the key does not exist\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent) {\n  let multiSigners = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  let confirmOptions = arguments.length > 7 ? arguments[7] : undefined;\n  let programId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : TOKEN_2022_PROGRAM_ID;\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createRemoveKeyInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    key,\n    idempotent\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n *  Update authority\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param newAuthority     New authority for the token metadata, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority) {\n  let multiSigners = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n  let confirmOptions = arguments.length > 6 ? arguments[6] : undefined;\n  let programId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : TOKEN_2022_PROGRAM_ID;\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createUpdateAuthorityInstruction({\n    programId,\n    metadata: mint,\n    oldAuthority: updateAuthorityPublicKey,\n    newAuthority\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}","map":{"version":3,"names":["sendAndConfirmTransaction","SystemProgram","Transaction","createInitializeInstruction","createRemoveKeyInstruction","createUpdateAuthorityInstruction","createUpdateFieldInstruction","pack","unpack","TOKEN_2022_PROGRAM_ID","getSigners","ExtensionType","getExtensionData","getNewAccountLenForExtensionLen","updateTokenMetadata","TokenAccountNotFoundError","unpackMint","getAdditionalRentForNewMetadata","connection","address","tokenMetadata","programId","arguments","length","undefined","info","getAccountInfo","extensionLen","newAccountLen","TokenMetadata","data","newRentExemptMinimum","getMinimumBalanceForRentExemption","lamports","getAdditionalRentForUpdatedMetadata","field","value","mint","extensionData","tlvData","Error","updatedTokenMetadata","tokenMetadataInitialize","payer","updateAuthority","mintAuthority","name","symbol","uri","multiSigners","confirmOptions","mintAuthorityPublicKey","signers","transaction","add","metadata","tokenMetadataInitializeWithRentTransfer","additionalMetadata","transfer","fromPubkey","publicKey","toPubkey","tokenMetadataUpdateField","updateAuthorityPublicKey","tokenMetadataUpdateFieldWithRentTransfer","tokenMetadataRemoveKey","key","idempotent","tokenMetadataUpdateAuthority","newAuthority","oldAuthority"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/spl-token/src/extensions/tokenMetadata/actions.ts"],"sourcesContent":["import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport type { Field, TokenMetadata } from '@solana/spl-token-metadata';\nimport {\n    createInitializeInstruction,\n    createRemoveKeyInstruction,\n    createUpdateAuthorityInstruction,\n    createUpdateFieldInstruction,\n    pack,\n    unpack,\n} from '@solana/spl-token-metadata';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\nimport { updateTokenMetadata } from './state.js';\nimport { TokenAccountNotFoundError } from '../../errors.js';\nimport { unpackMint } from '../../state/index.js';\n\nasync function getAdditionalRentForNewMetadata(\n    connection: Connection,\n    address: PublicKey,\n    tokenMetadata: TokenMetadata,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<number> {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n\n    const extensionLen = pack(tokenMetadata).length;\n    const newAccountLen = getNewAccountLenForExtensionLen(\n        info,\n        address,\n        ExtensionType.TokenMetadata,\n        extensionLen,\n        programId\n    );\n\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n\n    return newRentExemptMinimum - info.lamports;\n}\n\nasync function getAdditionalRentForUpdatedMetadata(\n    connection: Connection,\n    address: PublicKey,\n    field: string | Field,\n    value: string,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<number> {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n\n    const mint = unpackMint(address, info, programId);\n    const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\n    if (extensionData === null) {\n        throw new Error('TokenMetadata extension not initialized');\n    }\n\n    const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\n    const extensionLen = pack(updatedTokenMetadata).length;\n\n    const newAccountLen = getNewAccountLenForExtensionLen(\n        info,\n        address,\n        ExtensionType.TokenMetadata,\n        extensionLen,\n        programId\n    );\n\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n\n    return newRentExemptMinimum - info.lamports;\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitialize(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    name: string,\n    symbol: string,\n    uri: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createInitializeInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            name,\n            symbol,\n            uri,\n        })\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields,\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitializeWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    name: string,\n    symbol: string,\n    uri: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction();\n\n    const lamports = await getAdditionalRentForNewMetadata(\n        connection,\n        mint,\n        {\n            updateAuthority,\n            mint,\n            name,\n            symbol,\n            uri,\n            additionalMetadata: [],\n        },\n        programId\n    );\n\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n\n    transaction.add(\n        createInitializeInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            name,\n            symbol,\n            uri,\n        })\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateField(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    field: string | Field,\n    value: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateFieldInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            field,\n            value,\n        })\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateFieldWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    field: string | Field,\n    value: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction();\n\n    const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n\n    transaction.add(\n        createUpdateFieldInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            field,\n            value,\n        })\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Remove a field in a token-metadata account.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param key              Key to remove in the additional metadata portion\n * @param idempotent       When true, instruction will not error if the key does not exist\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataRemoveKey(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    key: string,\n    idempotent: boolean,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createRemoveKeyInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            key,\n            idempotent,\n        })\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n *  Update authority\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param newAuthority     New authority for the token metadata, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateAuthority(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateAuthorityInstruction({\n            programId,\n            metadata: mint,\n            oldAuthority: updateAuthorityPublicKey,\n            newAuthority,\n        })\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n"],"mappings":"AACA,SAASA,yBAAyB,EAAEC,aAAa,EAAEC,WAAW,QAAQ,iBAAiB;AAEvF,SACIC,2BAA2B,EAC3BC,0BAA0B,EAC1BC,gCAAgC,EAChCC,4BAA4B,EAC5BC,IAAI,EACJC,MAAM,QACH,4BAA4B;AAEnC,SAASC,qBAAqB,QAAQ,oBAAoB;AAC1D,SAASC,UAAU,QAAQ,2BAA2B;AACtD,SAASC,aAAa,EAAEC,gBAAgB,EAAEC,+BAA+B,QAAQ,qBAAqB;AACtG,SAASC,mBAAmB,QAAQ,YAAY;AAChD,SAASC,yBAAyB,QAAQ,iBAAiB;AAC3D,SAASC,UAAU,QAAQ,sBAAsB;AAEjD,eAAeC,+BAA+BA,CAC1CC,UAAsB,EACtBC,OAAkB,EAClBC,aAA4B,EACK;EAAA,IAAjCC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGb,qBAAqB;EAEjC,MAAMgB,IAAI,GAAG,MAAMP,UAAU,CAACQ,cAAc,CAACP,OAAO,CAAC;EACrD,IAAI,CAACM,IAAI,EAAE;IACP,MAAM,IAAIV,yBAAyB,EAAE;EACzC;EAEA,MAAMY,YAAY,GAAGpB,IAAI,CAACa,aAAa,CAAC,CAACG,MAAM;EAC/C,MAAMK,aAAa,GAAGf,+BAA+B,CACjDY,IAAI,EACJN,OAAO,EACPR,aAAa,CAACkB,aAAa,EAC3BF,YAAY,EACZN,SAAS,CACZ;EAED,IAAIO,aAAa,IAAIH,IAAI,CAACK,IAAI,CAACP,MAAM,EAAE;IACnC,OAAO,CAAC;EACZ;EAEA,MAAMQ,oBAAoB,GAAG,MAAMb,UAAU,CAACc,iCAAiC,CAACJ,aAAa,CAAC;EAE9F,OAAOG,oBAAoB,GAAGN,IAAI,CAACQ,QAAQ;AAC/C;AAEA,eAAeC,mCAAmCA,CAC9ChB,UAAsB,EACtBC,OAAkB,EAClBgB,KAAqB,EACrBC,KAAa,EACoB;EAAA,IAAjCf,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGb,qBAAqB;EAEjC,MAAMgB,IAAI,GAAG,MAAMP,UAAU,CAACQ,cAAc,CAACP,OAAO,CAAC;EACrD,IAAI,CAACM,IAAI,EAAE;IACP,MAAM,IAAIV,yBAAyB,EAAE;EACzC;EAEA,MAAMsB,IAAI,GAAGrB,UAAU,CAACG,OAAO,EAAEM,IAAI,EAAEJ,SAAS,CAAC;EACjD,MAAMiB,aAAa,GAAG1B,gBAAgB,CAACD,aAAa,CAACkB,aAAa,EAAEQ,IAAI,CAACE,OAAO,CAAC;EACjF,IAAID,aAAa,KAAK,IAAI,EAAE;IACxB,MAAM,IAAIE,KAAK,CAAC,yCAAyC,CAAC;EAC9D;EAEA,MAAMC,oBAAoB,GAAG3B,mBAAmB,CAACN,MAAM,CAAC8B,aAAa,CAAC,EAAEH,KAAK,EAAEC,KAAK,CAAC;EACrF,MAAMT,YAAY,GAAGpB,IAAI,CAACkC,oBAAoB,CAAC,CAAClB,MAAM;EAEtD,MAAMK,aAAa,GAAGf,+BAA+B,CACjDY,IAAI,EACJN,OAAO,EACPR,aAAa,CAACkB,aAAa,EAC3BF,YAAY,EACZN,SAAS,CACZ;EAED,IAAIO,aAAa,IAAIH,IAAI,CAACK,IAAI,CAACP,MAAM,EAAE;IACnC,OAAO,CAAC;EACZ;EAEA,MAAMQ,oBAAoB,GAAG,MAAMb,UAAU,CAACc,iCAAiC,CAACJ,aAAa,CAAC;EAE9F,OAAOG,oBAAoB,GAAGN,IAAI,CAACQ,QAAQ;AAC/C;AAEA;;;;;;;;;;;;;;;;;AAiBA,OAAO,eAAeS,uBAAuBA,CACzCxB,UAAsB,EACtByB,KAAa,EACbN,IAAe,EACfO,eAA0B,EAC1BC,aAAiC,EACjCC,IAAY,EACZC,MAAc,EACdC,GAAW,EAGsB;EAAA,IAFjCC,YAAA,GAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyB,EAAE;EAAA,IAC3B4B,cAA+B,GAAA5B,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAC/BH,SAAS,GAAAC,SAAA,CAAAC,MAAA,SAAAD,SAAA,SAAAE,SAAA,GAAAF,SAAA,OAAGb,qBAAqB;EAEjC,MAAM,CAAC0C,sBAAsB,EAAEC,OAAO,CAAC,GAAG1C,UAAU,CAACmC,aAAa,EAAEI,YAAY,CAAC;EAEjF,MAAMI,WAAW,GAAG,IAAInD,WAAW,EAAE,CAACoD,GAAG,CACrCnD,2BAA2B,CAAC;IACxBkB,SAAS;IACTkC,QAAQ,EAAElB,IAAI;IACdO,eAAe;IACfP,IAAI;IACJQ,aAAa,EAAEM,sBAAsB;IACrCL,IAAI;IACJC,MAAM;IACNC;GACH,CAAC,CACL;EAED,OAAO,MAAMhD,yBAAyB,CAACkB,UAAU,EAAEmC,WAAW,EAAE,CAACV,KAAK,EAAE,GAAGS,OAAO,CAAC,EAAEF,cAAc,CAAC;AACxG;AAEA;;;;;;;;;;;;;;;;;;AAkBA,OAAO,eAAeM,uCAAuCA,CACzDtC,UAAsB,EACtByB,KAAa,EACbN,IAAe,EACfO,eAA0B,EAC1BC,aAAiC,EACjCC,IAAY,EACZC,MAAc,EACdC,GAAW,EAGsB;EAAA,IAFjCC,YAAA,GAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyB,EAAE;EAAA,IAC3B4B,cAA+B,GAAA5B,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAC/BH,SAAS,GAAAC,SAAA,CAAAC,MAAA,SAAAD,SAAA,SAAAE,SAAA,GAAAF,SAAA,OAAGb,qBAAqB;EAEjC,MAAM,CAAC0C,sBAAsB,EAAEC,OAAO,CAAC,GAAG1C,UAAU,CAACmC,aAAa,EAAEI,YAAY,CAAC;EAEjF,MAAMI,WAAW,GAAG,IAAInD,WAAW,EAAE;EAErC,MAAM+B,QAAQ,GAAG,MAAMhB,+BAA+B,CAClDC,UAAU,EACVmB,IAAI,EACJ;IACIO,eAAe;IACfP,IAAI;IACJS,IAAI;IACJC,MAAM;IACNC,GAAG;IACHS,kBAAkB,EAAE;GACvB,EACDpC,SAAS,CACZ;EAED,IAAIY,QAAQ,GAAG,CAAC,EAAE;IACdoB,WAAW,CAACC,GAAG,CAACrD,aAAa,CAACyD,QAAQ,CAAC;MAAEC,UAAU,EAAEhB,KAAK,CAACiB,SAAS;MAAEC,QAAQ,EAAExB,IAAI;MAAEJ,QAAQ,EAAEA;IAAQ,CAAE,CAAC,CAAC;EAChH;EAEAoB,WAAW,CAACC,GAAG,CACXnD,2BAA2B,CAAC;IACxBkB,SAAS;IACTkC,QAAQ,EAAElB,IAAI;IACdO,eAAe;IACfP,IAAI;IACJQ,aAAa,EAAEM,sBAAsB;IACrCL,IAAI;IACJC,MAAM;IACNC;GACH,CAAC,CACL;EAED,OAAO,MAAMhD,yBAAyB,CAACkB,UAAU,EAAEmC,WAAW,EAAE,CAACV,KAAK,EAAE,GAAGS,OAAO,CAAC,EAAEF,cAAc,CAAC;AACxG;AAEA;;;;;;;;;;;;;;;;;;;AAmBA,OAAO,eAAeY,wBAAwBA,CAC1C5C,UAAsB,EACtByB,KAAa,EACbN,IAAe,EACfO,eAAmC,EACnCT,KAAqB,EACrBC,KAAa,EAGoB;EAAA,IAFjCa,YAAA,GAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyB,EAAE;EAAA,IAC3B4B,cAA+B,GAAA5B,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAC/BH,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGb,qBAAqB;EAEjC,MAAM,CAACsD,wBAAwB,EAAEX,OAAO,CAAC,GAAG1C,UAAU,CAACkC,eAAe,EAAEK,YAAY,CAAC;EAErF,MAAMI,WAAW,GAAG,IAAInD,WAAW,EAAE,CAACoD,GAAG,CACrChD,4BAA4B,CAAC;IACzBe,SAAS;IACTkC,QAAQ,EAAElB,IAAI;IACdO,eAAe,EAAEmB,wBAAwB;IACzC5B,KAAK;IACLC;GACH,CAAC,CACL;EAED,OAAO,MAAMpC,yBAAyB,CAACkB,UAAU,EAAEmC,WAAW,EAAE,CAACV,KAAK,EAAE,GAAGS,OAAO,CAAC,EAAEF,cAAc,CAAC;AACxG;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA,OAAO,eAAec,wCAAwCA,CAC1D9C,UAAsB,EACtByB,KAAa,EACbN,IAAe,EACfO,eAAmC,EACnCT,KAAqB,EACrBC,KAAa,EAGoB;EAAA,IAFjCa,YAAA,GAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyB,EAAE;EAAA,IAC3B4B,cAA+B,GAAA5B,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAC/BH,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGb,qBAAqB;EAEjC,MAAM,CAACsD,wBAAwB,EAAEX,OAAO,CAAC,GAAG1C,UAAU,CAACkC,eAAe,EAAEK,YAAY,CAAC;EAErF,MAAMI,WAAW,GAAG,IAAInD,WAAW,EAAE;EAErC,MAAM+B,QAAQ,GAAG,MAAMC,mCAAmC,CAAChB,UAAU,EAAEmB,IAAI,EAAEF,KAAK,EAAEC,KAAK,EAAEf,SAAS,CAAC;EAErG,IAAIY,QAAQ,GAAG,CAAC,EAAE;IACdoB,WAAW,CAACC,GAAG,CAACrD,aAAa,CAACyD,QAAQ,CAAC;MAAEC,UAAU,EAAEhB,KAAK,CAACiB,SAAS;MAAEC,QAAQ,EAAExB,IAAI;MAAEJ,QAAQ,EAAEA;IAAQ,CAAE,CAAC,CAAC;EAChH;EAEAoB,WAAW,CAACC,GAAG,CACXhD,4BAA4B,CAAC;IACzBe,SAAS;IACTkC,QAAQ,EAAElB,IAAI;IACdO,eAAe,EAAEmB,wBAAwB;IACzC5B,KAAK;IACLC;GACH,CAAC,CACL;EAED,OAAO,MAAMpC,yBAAyB,CAACkB,UAAU,EAAEmC,WAAW,EAAE,CAACV,KAAK,EAAE,GAAGS,OAAO,CAAC,EAAEF,cAAc,CAAC;AACxG;AAEA;;;;;;;;;;;;;;;;;AAiBA,OAAO,eAAee,sBAAsBA,CACxC/C,UAAsB,EACtByB,KAAa,EACbN,IAAe,EACfO,eAAmC,EACnCsB,GAAW,EACXC,UAAmB,EAGc;EAAA,IAFjClB,YAAA,GAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyB,EAAE;EAAA,IAC3B4B,cAA+B,GAAA5B,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAC/BH,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGb,qBAAqB;EAEjC,MAAM,CAACsD,wBAAwB,EAAEX,OAAO,CAAC,GAAG1C,UAAU,CAACkC,eAAe,EAAEK,YAAY,CAAC;EAErF,MAAMI,WAAW,GAAG,IAAInD,WAAW,EAAE,CAACoD,GAAG,CACrClD,0BAA0B,CAAC;IACvBiB,SAAS;IACTkC,QAAQ,EAAElB,IAAI;IACdO,eAAe,EAAEmB,wBAAwB;IACzCG,GAAG;IACHC;GACH,CAAC,CACL;EAED,OAAO,MAAMnE,yBAAyB,CAACkB,UAAU,EAAEmC,WAAW,EAAE,CAACV,KAAK,EAAE,GAAGS,OAAO,CAAC,EAAEF,cAAc,CAAC;AACxG;AAEA;;;;;;;;;;;;;;AAcA,OAAO,eAAekB,4BAA4BA,CAC9ClD,UAAsB,EACtByB,KAAa,EACbN,IAAe,EACfO,eAAmC,EACnCyB,YAA8B,EAGG;EAAA,IAFjCpB,YAAA,GAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyB,EAAE;EAAA,IAC3B4B,cAA+B,GAAA5B,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAC/BH,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGb,qBAAqB;EAEjC,MAAM,CAACsD,wBAAwB,EAAEX,OAAO,CAAC,GAAG1C,UAAU,CAACkC,eAAe,EAAEK,YAAY,CAAC;EAErF,MAAMI,WAAW,GAAG,IAAInD,WAAW,EAAE,CAACoD,GAAG,CACrCjD,gCAAgC,CAAC;IAC7BgB,SAAS;IACTkC,QAAQ,EAAElB,IAAI;IACdiC,YAAY,EAAEP,wBAAwB;IACtCM;GACH,CAAC,CACL;EAED,OAAO,MAAMrE,yBAAyB,CAACkB,UAAU,EAAEmC,WAAW,EAAE,CAACV,KAAK,EAAE,GAAGS,OAAO,CAAC,EAAEF,cAAc,CAAC;AACxG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}