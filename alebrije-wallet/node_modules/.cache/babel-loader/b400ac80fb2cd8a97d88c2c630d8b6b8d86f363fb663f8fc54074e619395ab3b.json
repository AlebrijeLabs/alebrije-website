{"ast":null,"code":"import WalletService from'./wallet-service';import{Connection,PublicKey,Transaction,SystemProgram}from'@solana/web3.js';import{createTransferInstruction,TOKEN_PROGRAM_ID}from'@solana/spl-token';class TokenService{constructor(){this.connection=null;this.tokenInfo={};}initialize(endpoint){this.connection=new Connection(endpoint,'confirmed');}async getTokenBalance(tokenAddress,walletAddress){if(!this.connection)throw new Error('Token service not initialized');if(!walletAddress)throw new Error('Wallet address is required');try{const tokenPublicKey=new PublicKey(tokenAddress);const walletPublicKey=new PublicKey(walletAddress);// Get token account info\nconst tokenAccounts=await this.connection.getParsedTokenAccountsByOwner(walletPublicKey,{mint:tokenPublicKey});// If no token accounts found, balance is 0\nif(tokenAccounts.value.length===0)return 0;// Get balance from the first token account\nconst balance=tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;return balance;}catch(error){console.error('Error getting token balance:',error);throw error;}}async transferToken(tokenAddress,fromWallet,toAddress,amount){if(!this.connection)throw new Error('Token service not initialized');if(!WalletService.isConnected())throw new Error('Wallet not connected');try{var _this$tokenInfo$token;const tokenPublicKey=new PublicKey(tokenAddress);const toPublicKey=new PublicKey(toAddress);// Get the token account of the fromWallet address for the token\nconst fromTokenAccounts=await this.connection.getParsedTokenAccountsByOwner(new PublicKey(fromWallet),{mint:tokenPublicKey});// If no token account found, throw error\nif(fromTokenAccounts.value.length===0){throw new Error('No token account found for the sender');}const fromTokenAccount=fromTokenAccounts.value[0].pubkey;// Get or create associated token account for recipient\nlet toTokenAccount;try{const toTokenAccounts=await this.connection.getParsedTokenAccountsByOwner(toPublicKey,{mint:tokenPublicKey});if(toTokenAccounts.value.length>0){toTokenAccount=toTokenAccounts.value[0].pubkey;}else{// In a real implementation, you would create an associated token account\n// This is simplified for the example\nthrow new Error('Recipient does not have a token account for this token');}}catch(error){throw new Error('Error checking recipient token account: '+error.message);}// Create transfer instruction - Updated to use createTransferInstruction\nconst transferInstruction=createTransferInstruction(fromTokenAccount,toTokenAccount,new PublicKey(fromWallet),amount*Math.pow(10,((_this$tokenInfo$token=this.tokenInfo[tokenAddress])===null||_this$tokenInfo$token===void 0?void 0:_this$tokenInfo$token.decimals)||9),[],TOKEN_PROGRAM_ID);// Create transaction and add the transfer instruction\nconst transaction=new Transaction().add(transferInstruction);// Set recent blockhash and fee payer\ntransaction.recentBlockhash=(await this.connection.getRecentBlockhash()).blockhash;transaction.feePayer=new PublicKey(fromWallet);// Sign and send transaction\nconst signedTransaction=await WalletService.signTransaction(transaction);const signature=await this.connection.sendRawTransaction(signedTransaction.serialize());// Wait for confirmation\nawait this.connection.confirmTransaction(signature);return{signature,status:'confirmed'};}catch(error){console.error('Error transferring tokens:',error);throw error;}}async getTokenInfo(tokenAddress){if(!this.connection)throw new Error('Token service not initialized');try{// If we already have the info cached, return it\nif(this.tokenInfo[tokenAddress]){return this.tokenInfo[tokenAddress];}const tokenPublicKey=new PublicKey(tokenAddress);const tokenInfo=await this.connection.getParsedAccountInfo(tokenPublicKey);if(!tokenInfo.value){throw new Error('Token not found');}// Parse token info\nconst parsedInfo={address:tokenAddress,decimals:tokenInfo.value.data.parsed.info.decimals,supply:tokenInfo.value.data.parsed.info.supply,name:tokenInfo.value.data.parsed.info.name||'Unknown Token',symbol:tokenInfo.value.data.parsed.info.symbol||'UNKNOWN'};// Cache the info\nthis.tokenInfo[tokenAddress]=parsedInfo;return parsedInfo;}catch(error){console.error('Error getting token info:',error);throw error;}}async getAccountTransactions(walletAddress){let limit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:10;if(!this.connection)throw new Error('Token service not initialized');if(!walletAddress)throw new Error('Wallet address is required');try{const walletPublicKey=new PublicKey(walletAddress);// Get recent transactions for the account\nconst transactions=await this.connection.getSignaturesForAddress(walletPublicKey,{limit});// Process and return transaction data\nconst processedTxs=await Promise.all(transactions.map(async tx=>{const transaction=await this.connection.getTransaction(tx.signature);// Basic transaction info\nconst txInfo={signature:tx.signature,timestamp:tx.blockTime,status:tx.confirmationStatus,type:'unknown'};// Try to determine transaction type and details\nif(transaction){var _transaction$meta;// Check if it's a SOL transfer\nconst solTransfer=(_transaction$meta=transaction.meta)===null||_transaction$meta===void 0?void 0:_transaction$meta.innerInstructions.find(ix=>ix.instructions.some(inst=>{var _inst$parsed;return inst.program==='system'&&((_inst$parsed=inst.parsed)===null||_inst$parsed===void 0?void 0:_inst$parsed.type)==='transfer';}));if(solTransfer){const transferInfo=solTransfer.instructions.find(inst=>{var _inst$parsed2;return inst.program==='system'&&((_inst$parsed2=inst.parsed)===null||_inst$parsed2===void 0?void 0:_inst$parsed2.type)==='transfer';}).parsed;txInfo.type=transferInfo.info.source===walletAddress?'send':'receive';txInfo.amount=transferInfo.info.lamports;txInfo.decimals=9;txInfo.symbol='SOL';txInfo.from=transferInfo.info.source;txInfo.to=transferInfo.info.destination;}}return txInfo;}));return processedTxs;}catch(error){console.error('Error getting account transactions:',error);throw error;}}async getTokenTransactions(tokenAddress,walletAddress){let limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:10;if(!this.connection)throw new Error('Token service not initialized');if(!tokenAddress)throw new Error('Token address is required');if(!walletAddress)throw new Error('Wallet address is required');try{const tokenPublicKey=new PublicKey(tokenAddress);const walletPublicKey=new PublicKey(walletAddress);// Get token accounts for this wallet and token\nconst tokenAccounts=await this.connection.getParsedTokenAccountsByOwner(walletPublicKey,{mint:tokenPublicKey});if(tokenAccounts.value.length===0){return[];}// Get token account address\nconst tokenAccount=tokenAccounts.value[0].pubkey;// Get recent transactions for the token account\nconst transactions=await this.connection.getSignaturesForAddress(tokenAccount,{limit});// Get token info for symbol and decimals\nlet tokenInfo;try{tokenInfo=await this.getTokenInfo(tokenAddress);}catch(err){tokenInfo={symbol:'UNKNOWN',decimals:0};}// Process and return transaction data\nconst processedTxs=await Promise.all(transactions.map(async tx=>{const transaction=await this.connection.getTransaction(tx.signature);// Basic transaction info\nconst txInfo={signature:tx.signature,timestamp:tx.blockTime,status:tx.confirmationStatus,type:'unknown',symbol:tokenInfo.symbol,decimals:tokenInfo.decimals};// Try to determine transaction type and details\nif(transaction){var _transaction$meta2;// Check if it's a token transfer\nconst tokenTransfer=(_transaction$meta2=transaction.meta)===null||_transaction$meta2===void 0?void 0:_transaction$meta2.innerInstructions.find(ix=>ix.instructions.some(inst=>{var _inst$parsed3;return inst.program==='spl-token'&&((_inst$parsed3=inst.parsed)===null||_inst$parsed3===void 0?void 0:_inst$parsed3.type)==='transfer';}));if(tokenTransfer){const transferInfo=tokenTransfer.instructions.find(inst=>{var _inst$parsed4;return inst.program==='spl-token'&&((_inst$parsed4=inst.parsed)===null||_inst$parsed4===void 0?void 0:_inst$parsed4.type)==='transfer';}).parsed;txInfo.type=transferInfo.info.source===tokenAccount.toString()?'send':'receive';txInfo.amount=transferInfo.info.amount;txInfo.from=transferInfo.info.source;txInfo.to=transferInfo.info.destination;}}return txInfo;}));return processedTxs;}catch(error){console.error('Error getting token transactions:',error);throw error;}}async getNativeBalance(walletAddress){if(!this.connection)throw new Error('Token service not initialized');if(!walletAddress)throw new Error('Wallet address is required');try{const walletPublicKey=new PublicKey(walletAddress);const balance=await this.connection.getBalance(walletPublicKey);return balance/1000000000;// Convert lamports to SOL\n}catch(error){console.error('Error getting native balance:',error);throw error;}}async transferNativeSOL(fromWallet,toAddress,amount){if(!this.connection)throw new Error('Token service not initialized');if(!WalletService.isConnected())throw new Error('Wallet not connected');try{const toPublicKey=new PublicKey(toAddress);const fromPublicKey=new PublicKey(fromWallet);// Create a simple transfer instruction\nconst transaction=new Transaction().add(SystemProgram.transfer({fromPubkey:fromPublicKey,toPubkey:toPublicKey,lamports:amount*1000000000// Convert SOL to lamports\n}));// Set recent blockhash and fee payer\ntransaction.recentBlockhash=(await this.connection.getRecentBlockhash()).blockhash;transaction.feePayer=fromPublicKey;// Sign and send transaction\nconst signedTransaction=await WalletService.signTransaction(transaction);const signature=await this.connection.sendRawTransaction(signedTransaction.serialize());// Wait for confirmation\nawait this.connection.confirmTransaction(signature);return{signature,status:'confirmed'};}catch(error){console.error('Error transferring SOL:',error);throw error;}}}export default new TokenService();","map":{"version":3,"names":["WalletService","Connection","PublicKey","Transaction","SystemProgram","createTransferInstruction","TOKEN_PROGRAM_ID","TokenService","constructor","connection","tokenInfo","initialize","endpoint","getTokenBalance","tokenAddress","walletAddress","Error","tokenPublicKey","walletPublicKey","tokenAccounts","getParsedTokenAccountsByOwner","mint","value","length","balance","account","data","parsed","info","tokenAmount","uiAmount","error","console","transferToken","fromWallet","toAddress","amount","isConnected","_this$tokenInfo$token","toPublicKey","fromTokenAccounts","fromTokenAccount","pubkey","toTokenAccount","toTokenAccounts","message","transferInstruction","Math","pow","decimals","transaction","add","recentBlockhash","getRecentBlockhash","blockhash","feePayer","signedTransaction","signTransaction","signature","sendRawTransaction","serialize","confirmTransaction","status","getTokenInfo","getParsedAccountInfo","parsedInfo","address","supply","name","symbol","getAccountTransactions","limit","arguments","undefined","transactions","getSignaturesForAddress","processedTxs","Promise","all","map","tx","getTransaction","txInfo","timestamp","blockTime","confirmationStatus","type","_transaction$meta","solTransfer","meta","innerInstructions","find","ix","instructions","some","inst","_inst$parsed","program","transferInfo","_inst$parsed2","source","lamports","from","to","destination","getTokenTransactions","tokenAccount","err","_transaction$meta2","tokenTransfer","_inst$parsed3","_inst$parsed4","toString","getNativeBalance","getBalance","transferNativeSOL","fromPublicKey","transfer","fromPubkey","toPubkey"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/token-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID } from '@solana/spl-token';\n\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint, 'confirmed');\n  }\n\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get token account info\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        walletPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      // If no token accounts found, balance is 0\n      if (tokenAccounts.value.length === 0) return 0;\n      \n      // Get balance from the first token account\n      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;\n      return balance;\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw error;\n    }\n  }\n\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!WalletService.isConnected()) throw new Error('Wallet not connected');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const toPublicKey = new PublicKey(toAddress);\n      \n      // Get the token account of the fromWallet address for the token\n      const fromTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        new PublicKey(fromWallet),\n        { mint: tokenPublicKey }\n      );\n      \n      // If no token account found, throw error\n      if (fromTokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the sender');\n      }\n      \n      const fromTokenAccount = fromTokenAccounts.value[0].pubkey;\n      \n      // Get or create associated token account for recipient\n      let toTokenAccount;\n      try {\n        const toTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n          toPublicKey,\n          { mint: tokenPublicKey }\n        );\n        \n        if (toTokenAccounts.value.length > 0) {\n          toTokenAccount = toTokenAccounts.value[0].pubkey;\n        } else {\n          // In a real implementation, you would create an associated token account\n          // This is simplified for the example\n          throw new Error('Recipient does not have a token account for this token');\n        }\n      } catch (error) {\n        throw new Error('Error checking recipient token account: ' + error.message);\n      }\n      \n      // Create transfer instruction - Updated to use createTransferInstruction\n      const transferInstruction = createTransferInstruction(\n        fromTokenAccount,\n        toTokenAccount,\n        new PublicKey(fromWallet),\n        amount * Math.pow(10, this.tokenInfo[tokenAddress]?.decimals || 9),\n        [],\n        TOKEN_PROGRAM_ID\n      );\n      \n      // Create transaction and add the transfer instruction\n      const transaction = new Transaction().add(transferInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = new PublicKey(fromWallet);\n      \n      // Sign and send transaction\n      const signedTransaction = await WalletService.signTransaction(transaction);\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error transferring tokens:', error);\n      throw error;\n    }\n  }\n\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      \n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      \n      if (!tokenInfo.value) {\n        throw new Error('Token not found');\n      }\n      \n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: tokenInfo.value.data.parsed.info.decimals,\n        supply: tokenInfo.value.data.parsed.info.supply,\n        name: tokenInfo.value.data.parsed.info.name || 'Unknown Token',\n        symbol: tokenInfo.value.data.parsed.info.symbol || 'UNKNOWN'\n      };\n      \n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      \n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw error;\n    }\n  }\n\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get recent transactions for the account\n      const transactions = await this.connection.getSignaturesForAddress(\n        walletPublicKey,\n        { limit }\n      );\n      \n      // Process and return transaction data\n      const processedTxs = await Promise.all(\n        transactions.map(async (tx) => {\n          const transaction = await this.connection.getTransaction(tx.signature);\n          \n          // Basic transaction info\n          const txInfo = {\n            signature: tx.signature,\n            timestamp: tx.blockTime,\n            status: tx.confirmationStatus,\n            type: 'unknown'\n          };\n          \n          // Try to determine transaction type and details\n          if (transaction) {\n            // Check if it's a SOL transfer\n            const solTransfer = transaction.meta?.innerInstructions.find(\n              (ix) => ix.instructions.some(\n                (inst) => inst.program === 'system' && inst.parsed?.type === 'transfer'\n              )\n            );\n            \n            if (solTransfer) {\n              const transferInfo = solTransfer.instructions.find(\n                (inst) => inst.program === 'system' && inst.parsed?.type === 'transfer'\n              ).parsed;\n              \n              txInfo.type = transferInfo.info.source === walletAddress ? 'send' : 'receive';\n              txInfo.amount = transferInfo.info.lamports;\n              txInfo.decimals = 9;\n              txInfo.symbol = 'SOL';\n              txInfo.from = transferInfo.info.source;\n              txInfo.to = transferInfo.info.destination;\n            }\n          }\n          \n          return txInfo;\n        })\n      );\n      \n      return processedTxs;\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      throw error;\n    }\n  }\n\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get token accounts for this wallet and token\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        walletPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      if (tokenAccounts.value.length === 0) {\n        return [];\n      }\n      \n      // Get token account address\n      const tokenAccount = tokenAccounts.value[0].pubkey;\n      \n      // Get recent transactions for the token account\n      const transactions = await this.connection.getSignaturesForAddress(\n        tokenAccount,\n        { limit }\n      );\n      \n      // Get token info for symbol and decimals\n      let tokenInfo;\n      try {\n        tokenInfo = await this.getTokenInfo(tokenAddress);\n      } catch (err) {\n        tokenInfo = { symbol: 'UNKNOWN', decimals: 0 };\n      }\n      \n      // Process and return transaction data\n      const processedTxs = await Promise.all(\n        transactions.map(async (tx) => {\n          const transaction = await this.connection.getTransaction(tx.signature);\n          \n          // Basic transaction info\n          const txInfo = {\n            signature: tx.signature,\n            timestamp: tx.blockTime,\n            status: tx.confirmationStatus,\n            type: 'unknown',\n            symbol: tokenInfo.symbol,\n            decimals: tokenInfo.decimals\n          };\n          \n          // Try to determine transaction type and details\n          if (transaction) {\n            // Check if it's a token transfer\n            const tokenTransfer = transaction.meta?.innerInstructions.find(\n              (ix) => ix.instructions.some(\n                (inst) => inst.program === 'spl-token' && inst.parsed?.type === 'transfer'\n              )\n            );\n            \n            if (tokenTransfer) {\n              const transferInfo = tokenTransfer.instructions.find(\n                (inst) => inst.program === 'spl-token' && inst.parsed?.type === 'transfer'\n              ).parsed;\n              \n              txInfo.type = transferInfo.info.source === tokenAccount.toString() ? 'send' : 'receive';\n              txInfo.amount = transferInfo.info.amount;\n              txInfo.from = transferInfo.info.source;\n              txInfo.to = transferInfo.info.destination;\n            }\n          }\n          \n          return txInfo;\n        })\n      );\n      \n      return processedTxs;\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      throw error;\n    }\n  }\n\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n\n  async transferNativeSOL(fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!WalletService.isConnected()) throw new Error('Wallet not connected');\n    \n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Create a simple transfer instruction\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: fromPublicKey,\n          toPubkey: toPublicKey,\n          lamports: amount * 1000000000 // Convert SOL to lamports\n        })\n      );\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Sign and send transaction\n      const signedTransaction = await WalletService.signTransaction(transaction);\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error transferring SOL:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new TokenService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}