{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function assert(publicKey) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    compressed\n  } = options;\n  const {\n    prefix,\n    x,\n    y\n  } = publicKey;\n  // Uncompressed\n  if (compressed === false || typeof x === 'bigint' && typeof y === 'bigint') {\n    if (prefix !== 4) throw new InvalidPrefixError({\n      prefix,\n      cause: new InvalidUncompressedPrefixError()\n    });\n    return;\n  }\n  // Compressed\n  if (compressed === true || typeof x === 'bigint' && typeof y === 'undefined') {\n    if (prefix !== 3 && prefix !== 2) throw new InvalidPrefixError({\n      prefix,\n      cause: new InvalidCompressedPrefixError()\n    });\n    return;\n  }\n  // Unknown/invalid\n  throw new InvalidError({\n    publicKey\n  });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport function compress(publicKey) {\n  const {\n    x,\n    y\n  } = publicKey;\n  return {\n    prefix: y % 2n === 0n ? 2 : 3,\n    x\n  };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nexport function from(value) {\n  const publicKey = (() => {\n    if (Hex.validate(value)) return fromHex(value);\n    if (Bytes.validate(value)) return fromBytes(value);\n    const {\n      prefix,\n      x,\n      y\n    } = value;\n    if (typeof x === 'bigint' && typeof y === 'bigint') return {\n      prefix: prefix ?? 0x04,\n      x,\n      y\n    };\n    return {\n      prefix,\n      x\n    };\n  })();\n  assert(publicKey);\n  return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromBytes(publicKey) {\n  return fromHex(Hex.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromHex(publicKey) {\n  if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68) throw new InvalidSerializedSizeError({\n    publicKey\n  });\n  if (publicKey.length === 130) {\n    const x = BigInt(Hex.slice(publicKey, 0, 32));\n    const y = BigInt(Hex.slice(publicKey, 32, 64));\n    return {\n      prefix: 4,\n      x,\n      y\n    };\n  }\n  if (publicKey.length === 132) {\n    const prefix = Number(Hex.slice(publicKey, 0, 1));\n    const x = BigInt(Hex.slice(publicKey, 1, 33));\n    const y = BigInt(Hex.slice(publicKey, 33, 65));\n    return {\n      prefix,\n      x,\n      y\n    };\n  }\n  const prefix = Number(Hex.slice(publicKey, 0, 1));\n  const x = BigInt(Hex.slice(publicKey, 1, 33));\n  return {\n    prefix,\n    x\n  };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toBytes(publicKey) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Bytes.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toHex(publicKey) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  assert(publicKey);\n  const {\n    prefix,\n    x,\n    y\n  } = publicKey;\n  const {\n    includePrefix = true\n  } = options;\n  const publicKey_ = Hex.concat(includePrefix ? Hex.fromNumber(prefix, {\n    size: 1\n  }) : '0x', Hex.fromNumber(x, {\n    size: 32\n  }),\n  // If the public key is not compressed, add the y coordinate.\n  typeof y === 'bigint' ? Hex.fromNumber(y, {\n    size: 32\n  }) : '0x');\n  return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function validate(publicKey) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  try {\n    assert(publicKey, options);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nexport class InvalidError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      publicKey\n    } = _ref;\n    super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n      metaMessages: ['Public key must contain:', '- an `x` and `prefix` value (compressed)', '- an `x`, `y`, and `prefix` value (uncompressed)']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidError'\n    });\n  }\n}\n/** Thrown when a public key has an invalid prefix. */\nexport class InvalidPrefixError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      prefix,\n      cause\n    } = _ref2;\n    super(`Prefix \"${prefix}\" is invalid.`, {\n      cause\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidPrefixError'\n    });\n  }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nexport class InvalidCompressedPrefixError extends Errors.BaseError {\n  constructor() {\n    super('Prefix must be 2 or 3 for compressed public keys.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidCompressedPrefixError'\n    });\n  }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nexport class InvalidUncompressedPrefixError extends Errors.BaseError {\n  constructor() {\n    super('Prefix must be 4 for uncompressed public keys.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidUncompressedPrefixError'\n    });\n  }\n}\n/** Thrown when the public key has an invalid serialized size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      publicKey\n    } = _ref3;\n    super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n      metaMessages: ['Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).', `Received ${Hex.size(Hex.from(publicKey))} bytes.`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidSerializedSizeError'\n    });\n  }\n}","map":{"version":3,"names":["Bytes","Errors","Hex","Json","assert","publicKey","options","arguments","length","undefined","compressed","prefix","x","y","InvalidPrefixError","cause","InvalidUncompressedPrefixError","InvalidCompressedPrefixError","InvalidError","compress","from","value","validate","fromHex","fromBytes","InvalidSerializedSizeError","BigInt","slice","Number","toBytes","toHex","includePrefix","publicKey_","concat","fromNumber","size","error","BaseError","constructor","_ref","stringify","metaMessages","Object","defineProperty","_ref2","_ref3"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@reown/appkit-controllers/node_modules/ox/core/PublicKey.ts"],"sourcesContent":["import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport type { Compute, ExactPartial } from './internal/types.js'\n\n/** Root type for an ECDSA Public Key. */\nexport type PublicKey<\n  compressed extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  compressed extends true\n    ? {\n        prefix: numberType\n        x: bigintType\n        y?: undefined\n      }\n    : {\n        prefix: numberType\n        x: bigintType\n        y: bigintType\n      }\n>\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function assert(\n  publicKey: ExactPartial<PublicKey>,\n  options: assert.Options = {},\n): asserts publicKey is PublicKey {\n  const { compressed } = options\n  const { prefix, x, y } = publicKey\n\n  // Uncompressed\n  if (\n    compressed === false ||\n    (typeof x === 'bigint' && typeof y === 'bigint')\n  ) {\n    if (prefix !== 4)\n      throw new InvalidPrefixError({\n        prefix,\n        cause: new InvalidUncompressedPrefixError(),\n      })\n    return\n  }\n\n  // Compressed\n  if (\n    compressed === true ||\n    (typeof x === 'bigint' && typeof y === 'undefined')\n  ) {\n    if (prefix !== 3 && prefix !== 2)\n      throw new InvalidPrefixError({\n        prefix,\n        cause: new InvalidCompressedPrefixError(),\n      })\n    return\n  }\n\n  // Unknown/invalid\n  throw new InvalidError({ publicKey })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the public key should be compressed. */\n    compressed?: boolean\n  }\n\n  type ErrorType = InvalidError | InvalidPrefixError | Errors.GlobalErrorType\n}\n\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport function compress(publicKey: PublicKey<false>): PublicKey<true> {\n  const { x, y } = publicKey\n  return {\n    prefix: y % 2n === 0n ? 2 : 3,\n    x,\n  }\n}\n\nexport declare namespace compress {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nexport function from<\n  const publicKey extends\n    | CompressedPublicKey\n    | UncompressedPublicKey\n    | Hex.Hex\n    | Bytes.Bytes,\n>(value: from.Value<publicKey>): from.ReturnType<publicKey> {\n  const publicKey = (() => {\n    if (Hex.validate(value)) return fromHex(value)\n    if (Bytes.validate(value)) return fromBytes(value)\n\n    const { prefix, x, y } = value\n    if (typeof x === 'bigint' && typeof y === 'bigint')\n      return { prefix: prefix ?? 0x04, x, y }\n    return { prefix, x }\n  })()\n\n  assert(publicKey)\n\n  return publicKey as never\n}\n\n/** @internal */\ntype CompressedPublicKey = PublicKey<true>\n\n/** @internal */\ntype UncompressedPublicKey = Omit<PublicKey<false>, 'prefix'> & {\n  prefix?: PublicKey['prefix'] | undefined\n}\n\nexport declare namespace from {\n  type Value<\n    publicKey extends\n      | CompressedPublicKey\n      | UncompressedPublicKey\n      | Hex.Hex\n      | Bytes.Bytes = PublicKey,\n  > = publicKey | CompressedPublicKey | UncompressedPublicKey\n\n  type ReturnType<\n    publicKey extends\n      | CompressedPublicKey\n      | UncompressedPublicKey\n      | Hex.Hex\n      | Bytes.Bytes = PublicKey,\n  > = publicKey extends CompressedPublicKey | UncompressedPublicKey\n    ? publicKey extends UncompressedPublicKey\n      ? Compute<publicKey & { readonly prefix: 0x04 }>\n      : publicKey\n    : PublicKey\n\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromBytes(publicKey: Bytes.Bytes): PublicKey {\n  return fromHex(Hex.fromBytes(publicKey))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType =\n    | fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromHex(publicKey: Hex.Hex): PublicKey {\n  if (\n    publicKey.length !== 132 &&\n    publicKey.length !== 130 &&\n    publicKey.length !== 68\n  )\n    throw new InvalidSerializedSizeError({ publicKey })\n\n  if (publicKey.length === 130) {\n    const x = BigInt(Hex.slice(publicKey, 0, 32))\n    const y = BigInt(Hex.slice(publicKey, 32, 64))\n    return {\n      prefix: 4,\n      x,\n      y,\n    } as never\n  }\n\n  if (publicKey.length === 132) {\n    const prefix = Number(Hex.slice(publicKey, 0, 1))\n    const x = BigInt(Hex.slice(publicKey, 1, 33))\n    const y = BigInt(Hex.slice(publicKey, 33, 65))\n    return {\n      prefix,\n      x,\n      y,\n    } as never\n  }\n\n  const prefix = Number(Hex.slice(publicKey, 0, 1))\n  const x = BigInt(Hex.slice(publicKey, 1, 33))\n  return {\n    prefix,\n    x,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType = Hex.slice.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toBytes(\n  publicKey: PublicKey<boolean>,\n  options: toBytes.Options = {},\n): Bytes.Bytes {\n  return Bytes.fromHex(toHex(publicKey, options))\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /**\n     * Whether to include the prefix in the serialized public key.\n     * @default true\n     */\n    includePrefix?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toHex(\n  publicKey: PublicKey<boolean>,\n  options: toHex.Options = {},\n): Hex.Hex {\n  assert(publicKey)\n\n  const { prefix, x, y } = publicKey\n  const { includePrefix = true } = options\n\n  const publicKey_ = Hex.concat(\n    includePrefix ? Hex.fromNumber(prefix, { size: 1 }) : '0x',\n    Hex.fromNumber(x, { size: 32 }),\n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? Hex.fromNumber(y, { size: 32 }) : '0x',\n  )\n\n  return publicKey_\n}\n\nexport declare namespace toHex {\n  type Options = {\n    /**\n     * Whether to include the prefix in the serialized public key.\n     * @default true\n     */\n    includePrefix?: boolean | undefined\n  }\n\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function validate(\n  publicKey: ExactPartial<PublicKey>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(publicKey, options)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the public key should be compressed. */\n    compressed?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nexport class InvalidError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidError'\n\n  constructor({ publicKey }: { publicKey: unknown }) {\n    super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n      metaMessages: [\n        'Public key must contain:',\n        '- an `x` and `prefix` value (compressed)',\n        '- an `x`, `y`, and `prefix` value (uncompressed)',\n      ],\n    })\n  }\n}\n\n/** Thrown when a public key has an invalid prefix. */\nexport class InvalidPrefixError<\n  cause extends InvalidCompressedPrefixError | InvalidUncompressedPrefixError =\n    | InvalidCompressedPrefixError\n    | InvalidUncompressedPrefixError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'PublicKey.InvalidPrefixError'\n\n  constructor({ prefix, cause }: { prefix: number | undefined; cause: cause }) {\n    super(`Prefix \"${prefix}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nexport class InvalidCompressedPrefixError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidCompressedPrefixError'\n\n  constructor() {\n    super('Prefix must be 2 or 3 for compressed public keys.')\n  }\n}\n\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nexport class InvalidUncompressedPrefixError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidUncompressedPrefixError'\n\n  constructor() {\n    super('Prefix must be 4 for uncompressed public keys.')\n  }\n}\n\n/** Thrown when the public key has an invalid serialized size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidSerializedSizeError'\n\n  constructor({ publicKey }: { publicKey: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n      metaMessages: [\n        'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n        `Received ${Hex.size(Hex.from(publicKey))} bytes.`,\n      ],\n    })\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,YAAY;AACnC,OAAO,KAAKC,MAAM,MAAM,aAAa;AACrC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAC/B,OAAO,KAAKC,IAAI,MAAM,WAAW;AAsBjC;;;;;;;;;;;;;;;;;;;AAmBA,OAAM,SAAUC,MAAMA,CACpBC,SAAkC,EACN;EAAA,IAA5BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0B,EAAE;EAE5B,MAAM;IAAEG;EAAU,CAAE,GAAGJ,OAAO;EAC9B,MAAM;IAAEK,MAAM;IAAEC,CAAC;IAAEC;EAAC,CAAE,GAAGR,SAAS;EAElC;EACA,IACEK,UAAU,KAAK,KAAK,IACnB,OAAOE,CAAC,KAAK,QAAQ,IAAI,OAAOC,CAAC,KAAK,QAAS,EAChD;IACA,IAAIF,MAAM,KAAK,CAAC,EACd,MAAM,IAAIG,kBAAkB,CAAC;MAC3BH,MAAM;MACNI,KAAK,EAAE,IAAIC,8BAA8B;KAC1C,CAAC;IACJ;EACF;EAEA;EACA,IACEN,UAAU,KAAK,IAAI,IAClB,OAAOE,CAAC,KAAK,QAAQ,IAAI,OAAOC,CAAC,KAAK,WAAY,EACnD;IACA,IAAIF,MAAM,KAAK,CAAC,IAAIA,MAAM,KAAK,CAAC,EAC9B,MAAM,IAAIG,kBAAkB,CAAC;MAC3BH,MAAM;MACNI,KAAK,EAAE,IAAIE,4BAA4B;KACxC,CAAC;IACJ;EACF;EAEA;EACA,MAAM,IAAIC,YAAY,CAAC;IAAEb;EAAS,CAAE,CAAC;AACvC;AAWA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUc,QAAQA,CAACd,SAA2B;EAClD,MAAM;IAAEO,CAAC;IAAEC;EAAC,CAAE,GAAGR,SAAS;EAC1B,OAAO;IACLM,MAAM,EAAEE,CAAC,GAAG,EAAE,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC;IAC7BD;GACD;AACH;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,OAAM,SAAUQ,IAAIA,CAMlBC,KAA4B;EAC5B,MAAMhB,SAAS,GAAG,CAAC,MAAK;IACtB,IAAIH,GAAG,CAACoB,QAAQ,CAACD,KAAK,CAAC,EAAE,OAAOE,OAAO,CAACF,KAAK,CAAC;IAC9C,IAAIrB,KAAK,CAACsB,QAAQ,CAACD,KAAK,CAAC,EAAE,OAAOG,SAAS,CAACH,KAAK,CAAC;IAElD,MAAM;MAAEV,MAAM;MAAEC,CAAC;MAAEC;IAAC,CAAE,GAAGQ,KAAK;IAC9B,IAAI,OAAOT,CAAC,KAAK,QAAQ,IAAI,OAAOC,CAAC,KAAK,QAAQ,EAChD,OAAO;MAAEF,MAAM,EAAEA,MAAM,IAAI,IAAI;MAAEC,CAAC;MAAEC;IAAC,CAAE;IACzC,OAAO;MAAEF,MAAM;MAAEC;IAAC,CAAE;EACtB,CAAC,EAAC,CAAE;EAEJR,MAAM,CAACC,SAAS,CAAC;EAEjB,OAAOA,SAAkB;AAC3B;AAkCA;;;;;;;;;;;;;;;;;;;AAmBA,OAAM,SAAUmB,SAASA,CAACnB,SAAsB;EAC9C,OAAOkB,OAAO,CAACrB,GAAG,CAACsB,SAAS,CAACnB,SAAS,CAAC,CAAC;AAC1C;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,OAAM,SAAUkB,OAAOA,CAAClB,SAAkB;EACxC,IACEA,SAAS,CAACG,MAAM,KAAK,GAAG,IACxBH,SAAS,CAACG,MAAM,KAAK,GAAG,IACxBH,SAAS,CAACG,MAAM,KAAK,EAAE,EAEvB,MAAM,IAAIiB,0BAA0B,CAAC;IAAEpB;EAAS,CAAE,CAAC;EAErD,IAAIA,SAAS,CAACG,MAAM,KAAK,GAAG,EAAE;IAC5B,MAAMI,CAAC,GAAGc,MAAM,CAACxB,GAAG,CAACyB,KAAK,CAACtB,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;IAC7C,MAAMQ,CAAC,GAAGa,MAAM,CAACxB,GAAG,CAACyB,KAAK,CAACtB,SAAS,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAC9C,OAAO;MACLM,MAAM,EAAE,CAAC;MACTC,CAAC;MACDC;KACQ;EACZ;EAEA,IAAIR,SAAS,CAACG,MAAM,KAAK,GAAG,EAAE;IAC5B,MAAMG,MAAM,GAAGiB,MAAM,CAAC1B,GAAG,CAACyB,KAAK,CAACtB,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACjD,MAAMO,CAAC,GAAGc,MAAM,CAACxB,GAAG,CAACyB,KAAK,CAACtB,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;IAC7C,MAAMQ,CAAC,GAAGa,MAAM,CAACxB,GAAG,CAACyB,KAAK,CAACtB,SAAS,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAC9C,OAAO;MACLM,MAAM;MACNC,CAAC;MACDC;KACQ;EACZ;EAEA,MAAMF,MAAM,GAAGiB,MAAM,CAAC1B,GAAG,CAACyB,KAAK,CAACtB,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACjD,MAAMO,CAAC,GAAGc,MAAM,CAACxB,GAAG,CAACyB,KAAK,CAACtB,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;EAC7C,OAAO;IACLM,MAAM;IACNC;GACQ;AACZ;AAMA;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUiB,OAAOA,CACrBxB,SAA6B,EACA;EAAA,IAA7BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;EAE7B,OAAOP,KAAK,CAACuB,OAAO,CAACO,KAAK,CAACzB,SAAS,EAAEC,OAAO,CAAC,CAAC;AACjD;AAiBA;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUwB,KAAKA,CACnBzB,SAA6B,EACF;EAAA,IAA3BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyB,EAAE;EAE3BH,MAAM,CAACC,SAAS,CAAC;EAEjB,MAAM;IAAEM,MAAM;IAAEC,CAAC;IAAEC;EAAC,CAAE,GAAGR,SAAS;EAClC,MAAM;IAAE0B,aAAa,GAAG;EAAI,CAAE,GAAGzB,OAAO;EAExC,MAAM0B,UAAU,GAAG9B,GAAG,CAAC+B,MAAM,CAC3BF,aAAa,GAAG7B,GAAG,CAACgC,UAAU,CAACvB,MAAM,EAAE;IAAEwB,IAAI,EAAE;EAAC,CAAE,CAAC,GAAG,IAAI,EAC1DjC,GAAG,CAACgC,UAAU,CAACtB,CAAC,EAAE;IAAEuB,IAAI,EAAE;EAAE,CAAE,CAAC;EAC/B;EACA,OAAOtB,CAAC,KAAK,QAAQ,GAAGX,GAAG,CAACgC,UAAU,CAACrB,CAAC,EAAE;IAAEsB,IAAI,EAAE;EAAE,CAAE,CAAC,GAAG,IAAI,CAC/D;EAED,OAAOH,UAAU;AACnB;AAcA;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUV,QAAQA,CACtBjB,SAAkC,EACJ;EAAA,IAA9BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA4B,EAAE;EAE9B,IAAI;IACFH,MAAM,CAACC,SAAS,EAAEC,OAAO,CAAC;IAC1B,OAAO,IAAI;EACb,CAAC,CAAC,OAAO8B,KAAK,EAAE;IACd,OAAO,KAAK;EACd;AACF;AAWA;;;;;;;;;;;;;;AAcA,OAAM,MAAOlB,YAAa,SAAQjB,MAAM,CAACoC,SAAS;EAGhDC,YAAAC,IAAA,EAAiD;IAAA,IAArC;MAAElC;IAAS,CAA0B,GAAAkC,IAAA;IAC/C,KAAK,CAAC,WAAWpC,IAAI,CAACqC,SAAS,CAACnC,SAAS,CAAC,+BAA+B,EAAE;MACzEoC,YAAY,EAAE,CACZ,0BAA0B,EAC1B,0CAA0C,EAC1C,kDAAkD;KAErD,CAAC;IATcC,MAAA,CAAAC,cAAA;;;;aAAO;;EAUzB;;AAGF;AACA,OAAM,MAAO7B,kBAIX,SAAQb,MAAM,CAACoC,SAAgB;EAG/BC,YAAAM,KAAA,EAA2E;IAAA,IAA/D;MAAEjC,MAAM;MAAEI;IAAK,CAAgD,GAAA6B,KAAA;IACzE,KAAK,CAAC,WAAWjC,MAAM,eAAe,EAAE;MACtCI;KACD,CAAC;IALc2B,MAAA,CAAAC,cAAA;;;;aAAO;;EAMzB;;AAGF;AACA,OAAM,MAAO1B,4BAA6B,SAAQhB,MAAM,CAACoC,SAAS;EAGhEC,YAAA;IACE,KAAK,CAAC,mDAAmD,CAAC;IAH1CI,MAAA,CAAAC,cAAA;;;;aAAO;;EAIzB;;AAGF;AACA,OAAM,MAAO3B,8BAA+B,SAAQf,MAAM,CAACoC,SAAS;EAGlEC,YAAA;IACE,KAAK,CAAC,gDAAgD,CAAC;IAHvCI,MAAA,CAAAC,cAAA;;;;aAAO;;EAIzB;;AAGF;AACA,OAAM,MAAOlB,0BAA2B,SAAQxB,MAAM,CAACoC,SAAS;EAG9DC,YAAAO,KAAA,EAA+D;IAAA,IAAnD;MAAExC;IAAS,CAAwC,GAAAwC,KAAA;IAC7D,KAAK,CAAC,WAAWxC,SAAS,mCAAmC,EAAE;MAC7DoC,YAAY,EAAE,CACZ,wGAAwG,EACxG,YAAYvC,GAAG,CAACiC,IAAI,CAACjC,GAAG,CAACkB,IAAI,CAACf,SAAS,CAAC,CAAC,SAAS;KAErD,CAAC;IARcqC,MAAA,CAAAC,cAAA;;;;aAAO;;EASzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}