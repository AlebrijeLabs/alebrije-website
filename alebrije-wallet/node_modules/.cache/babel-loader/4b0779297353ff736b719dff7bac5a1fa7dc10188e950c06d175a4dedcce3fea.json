{"ast":null,"code":"import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL, sendAndConfirmTransaction, Keypair } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction, getAssociatedTokenAddress } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint || clusterApiUrl('devnet'), 'confirmed');\n  }\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(tokenPublicKey, walletPublicKey);\n      try {\n        const accountInfo = await this.connection.getTokenAccountBalance(associatedTokenAddress);\n        return accountInfo.value.uiAmount;\n      } catch (err) {\n        // If account doesn't exist, return 0\n        return 0;\n      }\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw new Error('Failed to get token balance: ' + error.message);\n    }\n  }\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const toPublicKey = new PublicKey(toAddress);\n\n      // Get token decimals\n      const tokenInfo = await this.getTokenInfo(tokenAddress);\n      const decimals = tokenInfo.decimals;\n\n      // Calculate token amounts with decimals\n      const rawAmount = amount * Math.pow(10, decimals);\n\n      // Get or create associated token accounts\n      const fromTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, fromPublicKey);\n      const toTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, toPublicKey);\n\n      // Create transaction\n      const transaction = new Transaction();\n\n      // Check if recipient token account exists\n      const recipientAccount = await this.connection.getAccountInfo(toTokenAccount);\n\n      // If recipient account doesn't exist, add create instruction\n      if (!recipientAccount) {\n        const createAccountInstruction = await createAssociatedTokenAccountInstruction(fromPublicKey,\n        // payer\n        toTokenAccount,\n        // associated token account\n        toPublicKey,\n        // owner\n        tokenPublicKey // mint\n        );\n        transaction.add(createAccountInstruction);\n      }\n\n      // Add transfer instruction\n      const transferInstruction = createTransferInstruction(fromTokenAccount, toTokenAccount, fromPublicKey, rawAmount, [], TOKEN_PROGRAM_ID);\n      transaction.add(transferInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('No compatible wallet found');\n      }\n\n      // Sign and send transaction\n      try {\n        var _confirmation$value;\n        const signed = await walletAdapter.signTransaction(transaction);\n        const signature = await this.connection.sendRawTransaction(signed.serialize());\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');\n        if ((_confirmation$value = confirmation.value) !== null && _confirmation$value !== void 0 && _confirmation$value.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        var _signError$message;\n        if ((_signError$message = signError.message) !== null && _signError$message !== void 0 && _signError$message.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('Token transfer error:', error);\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      if (!tokenInfo.value || !tokenInfo.value.data.parsed) {\n        throw new Error('Invalid token address');\n      }\n      const mintInfo = tokenInfo.value.data.parsed.info;\n\n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: mintInfo.decimals,\n        supply: mintInfo.supply,\n        name: mintInfo.name || 'Unknown Token',\n        symbol: mintInfo.symbol || 'UNKNOWN'\n      };\n\n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw new Error('Failed to get token info: ' + error.message);\n    }\n  }\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(walletPublicKey, {\n        limit\n      });\n\n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n  async transferNativeSOL(fromWallet, toAddress, amount, walletAdapter) {\n    if (!this.connection) {\n      throw new Error('Connection not initialized');\n    }\n    if (!walletAdapter) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const transferAmount = Math.floor(amount * LAMPORTS_PER_SOL);\n\n      // Check balance\n      const balance = await this.connection.getBalance(fromPublicKey);\n      const minimumBalance = transferAmount + 5000; // Add 5000 lamports for fees\n\n      if (balance < minimumBalance) {\n        throw new Error(`Insufficient balance for transfer and fees. Need ${minimumBalance / LAMPORTS_PER_SOL} SOL but have ${balance / LAMPORTS_PER_SOL} SOL`);\n      }\n\n      // Create transaction\n      const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: transferAmount\n      }));\n\n      // Get latest blockhash\n      const {\n        blockhash,\n        lastValidBlockHeight\n      } = await this.connection.getLatestBlockhash();\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n      try {\n        var _confirmation$value2;\n        // Create a versioned transaction\n        transaction.sign([]); // This is needed to serialize the transaction properly\n\n        // Request signature from wallet\n        const signedTransaction = await walletAdapter.signTransaction(transaction);\n\n        // Send and confirm transaction\n        const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n        // Wait for confirmation with specific commitment\n        const confirmation = await this.connection.confirmTransaction({\n          signature,\n          blockhash,\n          lastValidBlockHeight\n        }, 'confirmed');\n        if ((_confirmation$value2 = confirmation.value) !== null && _confirmation$value2 !== void 0 && _confirmation$value2.err) {\n          throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n        }\n\n        // Double check the balance change\n        const newBalance = await this.connection.getBalance(fromPublicKey);\n        if (newBalance >= balance) {\n          throw new Error('Transaction may have failed: Balance not updated');\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (err) {\n        var _err$message, _err$message2, _err$message3;\n        console.error('Transaction error:', err);\n        if ((_err$message = err.message) !== null && _err$message !== void 0 && _err$message.includes('User rejected')) {\n          throw new Error('Transaction was rejected by user');\n        }\n\n        // Check for specific error types\n        if ((_err$message2 = err.message) !== null && _err$message2 !== void 0 && _err$message2.includes('0x1')) {\n          throw new Error('Transaction simulation failed. Please check your balance and try again.');\n        }\n        if ((_err$message3 = err.message) !== null && _err$message3 !== void 0 && _err$message3.includes('blockhash')) {\n          throw new Error('Network error: Please try again (blockhash expired)');\n        }\n        throw new Error(`Transaction failed: ${err.message}`);\n      }\n    } catch (error) {\n      console.error('SOL transfer error:', error);\n      throw error;\n    }\n  }\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      var _this$tokenInfo$token, _window$solana;\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n\n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(ownerPublicKey, {\n        mint: tokenPublicKey\n      });\n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      const tokenAccount = tokenAccounts.value[0].pubkey;\n\n      // Get token decimals\n      const decimals = ((_this$tokenInfo$token = this.tokenInfo[tokenAddress]) === null || _this$tokenInfo$token === void 0 ? void 0 : _this$tokenInfo$token.decimals) || (await this.getTokenInfo(tokenAddress)).decimals;\n\n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(tokenAccount, tokenPublicKey, ownerPublicKey, amount * Math.pow(10, decimals));\n\n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n\n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n\n      // For Phantom\n      if ((_window$solana = window.solana) !== null && _window$solana !== void 0 && _window$solana.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      } else {\n        throw new Error('No compatible wallet found');\n      }\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\nexport default new TokenService();\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n  const connection = new Connection(clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'), 'confirmed');\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    const transaction = new Transaction().add(SystemProgram.transfer({\n      fromPubkey: wallet.publicKey,\n      toPubkey: burnAddress,\n      lamports: amount * LAMPORTS_PER_SOL\n    }));\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(mint, wallet.publicKey);\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    const burnInstruction = createBurnInstruction(associatedTokenAddress, mint, wallet.publicKey, amount * Math.pow(10, mintInfo.decimals));\n    const transaction = new Transaction().add(burnInstruction);\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n};","map":{"version":3,"names":["WalletService","Connection","PublicKey","Transaction","SystemProgram","LAMPORTS_PER_SOL","sendAndConfirmTransaction","Keypair","createTransferInstruction","TOKEN_PROGRAM_ID","createBurnInstruction","getAssociatedTokenAddress","clusterApiUrl","TokenService","constructor","connection","tokenInfo","initialize","endpoint","getTokenBalance","tokenAddress","walletAddress","Error","tokenPublicKey","walletPublicKey","associatedTokenAddress","accountInfo","getTokenAccountBalance","value","uiAmount","err","error","console","message","transferToken","fromWallet","toAddress","amount","fromPublicKey","toPublicKey","getTokenInfo","decimals","rawAmount","Math","pow","fromTokenAccount","toTokenAccount","transaction","recipientAccount","getAccountInfo","createAccountInstruction","createAssociatedTokenAccountInstruction","add","transferInstruction","recentBlockhash","getRecentBlockhash","blockhash","feePayer","walletAdapter","window","solana","solflare","_confirmation$value","signed","signTransaction","signature","sendRawTransaction","serialize","confirmation","confirmTransaction","JSON","stringify","status","signError","_signError$message","includes","getParsedAccountInfo","data","parsed","mintInfo","info","parsedInfo","address","supply","name","symbol","getAccountTransactions","limit","signatures","getSignaturesForAddress","map","sig","timestamp","blockTime","Date","now","confirmationStatus","type","getTokenTransactions","getNativeBalance","balance","getBalance","transferNativeSOL","transferAmount","floor","minimumBalance","transfer","fromPubkey","toPubkey","lamports","lastValidBlockHeight","getLatestBlockhash","_confirmation$value2","sign","signedTransaction","newBalance","_err$message","_err$message2","_err$message3","burnToken","ownerAddress","_this$tokenInfo$token","_window$solana","ownerPublicKey","tokenAccounts","getParsedTokenAccountsByOwner","mint","length","tokenAccount","pubkey","burnInstruction","isPhantom","burnTokens","wallet","publicKey","process","env","REACT_APP_SOLANA_NETWORK","burnAddress","sendTransaction","getMint"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/token-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL, sendAndConfirmTransaction, Keypair } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction, getAssociatedTokenAddress } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\n\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint || clusterApiUrl('devnet'), 'confirmed');\n  }\n\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        walletPublicKey\n      );\n      \n      try {\n        const accountInfo = await this.connection.getTokenAccountBalance(associatedTokenAddress);\n        return accountInfo.value.uiAmount;\n      } catch (err) {\n        // If account doesn't exist, return 0\n        return 0;\n      }\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw new Error('Failed to get token balance: ' + error.message);\n    }\n  }\n\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const toPublicKey = new PublicKey(toAddress);\n      \n      // Get token decimals\n      const tokenInfo = await this.getTokenInfo(tokenAddress);\n      const decimals = tokenInfo.decimals;\n      \n      // Calculate token amounts with decimals\n      const rawAmount = amount * Math.pow(10, decimals);\n      \n      // Get or create associated token accounts\n      const fromTokenAccount = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        fromPublicKey\n      );\n      \n      const toTokenAccount = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        toPublicKey\n      );\n      \n      // Create transaction\n      const transaction = new Transaction();\n      \n      // Check if recipient token account exists\n      const recipientAccount = await this.connection.getAccountInfo(toTokenAccount);\n      \n      // If recipient account doesn't exist, add create instruction\n      if (!recipientAccount) {\n        const createAccountInstruction = await createAssociatedTokenAccountInstruction(\n          fromPublicKey, // payer\n          toTokenAccount, // associated token account\n          toPublicKey, // owner\n          tokenPublicKey // mint\n        );\n        transaction.add(createAccountInstruction);\n      }\n      \n      // Add transfer instruction\n      const transferInstruction = createTransferInstruction(\n        fromTokenAccount,\n        toTokenAccount,\n        fromPublicKey,\n        rawAmount,\n        [],\n        TOKEN_PROGRAM_ID\n      );\n      \n      transaction.add(transferInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('No compatible wallet found');\n      }\n      \n      // Sign and send transaction\n      try {\n        const signed = await walletAdapter.signTransaction(transaction);\n        const signature = await this.connection.sendRawTransaction(signed.serialize());\n        \n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');\n        \n        if (confirmation.value?.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        \n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        if (signError.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('Token transfer error:', error);\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      \n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      \n      if (!tokenInfo.value || !tokenInfo.value.data.parsed) {\n        throw new Error('Invalid token address');\n      }\n      \n      const mintInfo = tokenInfo.value.data.parsed.info;\n      \n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: mintInfo.decimals,\n        supply: mintInfo.supply,\n        name: mintInfo.name || 'Unknown Token',\n        symbol: mintInfo.symbol || 'UNKNOWN'\n      };\n      \n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      \n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw new Error('Failed to get token info: ' + error.message);\n    }\n  }\n\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(\n        walletPublicKey,\n        { limit }\n      );\n      \n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n\n  async transferNativeSOL(fromWallet, toAddress, amount, walletAdapter) {\n    if (!this.connection) {\n      throw new Error('Connection not initialized');\n    }\n    \n    if (!walletAdapter) {\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const transferAmount = Math.floor(amount * LAMPORTS_PER_SOL);\n\n      // Check balance\n      const balance = await this.connection.getBalance(fromPublicKey);\n      const minimumBalance = transferAmount + 5000; // Add 5000 lamports for fees\n      \n      if (balance < minimumBalance) {\n        throw new Error(`Insufficient balance for transfer and fees. Need ${minimumBalance / LAMPORTS_PER_SOL} SOL but have ${balance / LAMPORTS_PER_SOL} SOL`);\n      }\n\n      // Create transaction\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: fromPublicKey,\n          toPubkey: toPublicKey,\n          lamports: transferAmount,\n        })\n      );\n\n      // Get latest blockhash\n      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash();\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      try {\n        // Create a versioned transaction\n        transaction.sign([]); // This is needed to serialize the transaction properly\n\n        // Request signature from wallet\n        const signedTransaction = await walletAdapter.signTransaction(transaction);\n\n        // Send and confirm transaction\n        const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n        \n        // Wait for confirmation with specific commitment\n        const confirmation = await this.connection.confirmTransaction({\n          signature,\n          blockhash,\n          lastValidBlockHeight\n        }, 'confirmed');\n\n        if (confirmation.value?.err) {\n          throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n        }\n\n        // Double check the balance change\n        const newBalance = await this.connection.getBalance(fromPublicKey);\n        if (newBalance >= balance) {\n          throw new Error('Transaction may have failed: Balance not updated');\n        }\n\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (err) {\n        console.error('Transaction error:', err);\n        \n        if (err.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by user');\n        }\n        \n        // Check for specific error types\n        if (err.message?.includes('0x1')) {\n          throw new Error('Transaction simulation failed. Please check your balance and try again.');\n        }\n        \n        if (err.message?.includes('blockhash')) {\n          throw new Error('Network error: Please try again (blockhash expired)');\n        }\n        \n        throw new Error(`Transaction failed: ${err.message}`);\n      }\n    } catch (error) {\n      console.error('SOL transfer error:', error);\n      throw error;\n    }\n  }\n\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n      \n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        ownerPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      \n      const tokenAccount = tokenAccounts.value[0].pubkey;\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(\n        tokenAccount,\n        tokenPublicKey,\n        ownerPublicKey,\n        amount * Math.pow(10, decimals)\n      );\n      \n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new TokenService();\n\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n\n  const connection = new Connection(\n    clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'),\n    'confirmed'\n  );\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    \n    const transaction = new Transaction().add(\n      SystemProgram.transfer({\n        fromPubkey: wallet.publicKey,\n        toPubkey: burnAddress,\n        lamports: amount * LAMPORTS_PER_SOL,\n      })\n    );\n\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(\n      mint,\n      wallet.publicKey\n    );\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    \n    const burnInstruction = createBurnInstruction(\n      associatedTokenAddress,\n      mint,\n      wallet.publicKey,\n      amount * Math.pow(10, mintInfo.decimals)\n    );\n\n    const transaction = new Transaction().add(burnInstruction);\n    \n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}