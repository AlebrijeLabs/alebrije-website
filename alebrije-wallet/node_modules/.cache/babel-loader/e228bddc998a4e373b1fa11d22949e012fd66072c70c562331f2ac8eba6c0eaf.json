{"ast":null,"code":"import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Json from './Json.js';\nimport * as internal_bytes from './internal/bytes.js';\nimport * as internal from './internal/hex.js';\nconst encoder = /*#__PURE__*/new TextEncoder();\nconst hexes = /*#__PURE__*/Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    strict = false\n  } = options;\n  if (!value) throw new InvalidHexTypeError(value);\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value);\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value);\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value) {\n  if (value instanceof Uint8Array) return fromBytes(value);\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value));\n  return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const hex = `0x${Number(value)}`;\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size);\n    return padLeft(hex, options.size);\n  }\n  return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let string = '';\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]];\n  const hex = `0x${string}`;\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size);\n    return padRight(hex, options.size);\n  }\n  return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed,\n    size\n  } = options;\n  const value_ = BigInt(value);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value_ > maxValue || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : '';\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`\n    });\n  }\n  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n  const hex = `0x${stringValue}`;\n  if (size) return padLeft(hex, size);\n  return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA, hexB) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(value, size) {\n  return internal.pad(value, {\n    dir: 'left',\n    size\n  });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(value, size) {\n  return internal.pad(value, {\n    dir: 'right',\n    size\n  });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length) {\n  return fromBytes(Bytes.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(value, start, end) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    strict\n  } = options;\n  internal.assertStartOffset(value, start);\n  const value_ = `0x${value.replace('0x', '').slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n  if (strict) internal.assertEndOffset(value_, start, end);\n  return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value) {\n  return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value) {\n  return internal.trim(value, {\n    dir: 'left'\n  });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value) {\n  return internal.trim(value, {\n    dir: 'right'\n  });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed\n  } = options;\n  if (options.size) internal.assertSize(hex, options.size);\n  const value = BigInt(hex);\n  if (!signed) return value;\n  const size = (hex.length - 2) / 2;\n  const max_unsigned = (1n << BigInt(size) * 8n) - 1n;\n  const max_signed = max_unsigned >> 1n;\n  if (value <= max_signed) return value;\n  return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (options.size) internal.assertSize(hex, options.size);\n  const hex_ = trimLeft(hex);\n  if (hex_ === '0x') return false;\n  if (hex_ === '0x1') return true;\n  throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Bytes.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed,\n    size\n  } = options;\n  if (!signed && !size) return Number(hex);\n  return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  let bytes = Bytes.fromHex(hex);\n  if (size) {\n    internal_bytes.assertSize(bytes, size);\n    bytes = Bytes.trimRight(bytes);\n  }\n  return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    strict = false\n  } = options;\n  try {\n    assert(value, {\n      strict\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      max,\n      min,\n      signed,\n      size,\n      value\n    } = _ref;\n    super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.IntegerOutOfRangeError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  constructor(hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: ['The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexBooleanError'\n    });\n  }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  constructor(value) {\n    super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n      metaMessages: ['Hex types must be represented as `\"0x${string}\"`.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexTypeError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  constructor(value) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: ['Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexValueError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  constructor(value) {\n    super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n      metaMessages: ['It must be an even length.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidLengthError'\n    });\n  }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      givenSize,\n      maxSize\n    } = _ref2;\n    super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SizeOverflowError'\n    });\n  }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      offset,\n      position,\n      size\n    } = _ref3;\n    super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SliceOffsetOutOfBoundsError'\n    });\n  }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  constructor(_ref4) {\n    let {\n      size,\n      targetSize,\n      type\n    } = _ref4;\n    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SizeExceedsPaddingSizeError'\n    });\n  }\n}","map":{"version":3,"names":["equalBytes","Bytes","Errors","Json","internal_bytes","internal","encoder","TextEncoder","hexes","Array","from","length","_v","i","toString","padStart","assert","value","options","arguments","undefined","strict","InvalidHexTypeError","test","InvalidHexValueError","startsWith","concat","_len","values","_key","reduce","acc","x","replace","Uint8Array","fromBytes","isArray","fromBoolean","hex","Number","size","assertSize","padLeft","string","padRight","fromNumber","signed","value_","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","IntegerOutOfRangeError","max","min","stringValue","fromString","encode","isEqual","hexA","hexB","fromHex","pad","dir","random","slice","start","end","assertStartOffset","assertEndOffset","Math","ceil","trimLeft","trim","trimRight","toBigInt","max_unsigned","max_signed","toBoolean","hex_","InvalidHexBooleanError","toBytes","toNumber","bytes","TextDecoder","decode","validate","BaseError","constructor","_ref","Object","defineProperty","metaMessages","stringify","InvalidLengthError","SizeOverflowError","_ref2","givenSize","maxSize","SliceOffsetOutOfBoundsError","_ref3","offset","position","SizeExceedsPaddingSizeError","_ref4","targetSize","type","charAt","toUpperCase","toLowerCase"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@walletconnect/utils/node_modules/ox/core/Hex.ts"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Json from './Json.js'\nimport * as internal_bytes from './internal/bytes.js'\nimport * as internal from './internal/hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\n/** Root type for a Hex string. */\nexport type Hex = `0x${string}`\n\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(\n  value: unknown,\n  options: assert.Options = {},\n): asserts value is Hex {\n  const { strict = false } = options\n  if (!value) throw new InvalidHexTypeError(value)\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value)\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value)\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value)\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | InvalidHexTypeError\n    | InvalidHexValueError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce((acc, x) => acc + x.replace('0x', ''), '')}`\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value: Hex | Bytes.Bytes | readonly number[]): Hex {\n  if (value instanceof Uint8Array) return fromBytes(value)\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value))\n  return value as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(\n  value: boolean,\n  options: fromBoolean.Options = {},\n): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padLeft(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(\n  value: Bytes.Bytes,\n  options: fromBytes.Options = {},\n): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]!]\n  const hex = `0x${string}` as const\n\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padRight(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(\n  value: number | bigint,\n  options: fromNumber.Options = {},\n): Hex {\n  const { signed, size } = options\n\n  const value_ = BigInt(value)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value_ > maxValue) || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`,\n    })\n  }\n\n  const stringValue = (\n    signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_\n  ).toString(16)\n\n  const hex = `0x${stringValue}` as Hex\n  if (size) return padLeft(hex, size) as Hex\n  return hex\n}\n\nexport declare namespace fromNumber {\n  type Options =\n    | {\n        /** Whether or not the number of a signed representation. */\n        signed?: boolean | undefined\n        /** The size (in bytes) of the output hex value. */\n        size: number\n      }\n    | {\n        signed?: undefined\n        /** The size (in bytes) of the output hex value. */\n        size?: number | undefined\n      }\n\n  type ErrorType =\n    | IntegerOutOfRangeError\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Hex {\n  return fromBytes(encoder.encode(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA: Hex, hexB: Hex) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB))\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(\n  value: Hex,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(\n  value: Hex,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length: number): Hex {\n  return fromBytes(Bytes.random(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(\n  value: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Hex {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = `0x${value\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value.length) * 2)}` as const\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value: Hex): number {\n  return Math.ceil((value.length - 2) / 2)\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value: Hex): trimLeft.ReturnType {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value: Hex): trimRight.ReturnType {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex: Hex, options: toBigInt.Options = {}): bigint {\n  const { signed } = options\n\n  if (options.size) internal.assertSize(hex, options.size)\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n\n  const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n\n  const max_signed = max_unsigned >> 1n\n\n  if (value <= max_signed) return value\n  return value - max_unsigned - 1n\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = internal.assertSize.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex: Hex, options: toBoolean.Options = {}): boolean {\n  if (options.size) internal.assertSize(hex, options.size)\n  const hex_ = trimLeft(hex)\n  if (hex_ === '0x') return false\n  if (hex_ === '0x1') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | InvalidHexBooleanError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex: Hex, options: toBytes.Options = {}): Bytes.Bytes {\n  return Bytes.fromHex(hex, options)\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex: Hex, options: toNumber.Options = {}): number {\n  const { signed, size } = options\n  if (!signed && !size) return Number(hex)\n  return Number(toBigInt(hex, options))\n}\n\nexport declare namespace toNumber {\n  type Options = toBigInt.Options\n\n  type ErrorType = toBigInt.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex: Hex, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes = Bytes.fromHex(hex)\n  if (size) {\n    internal_bytes.assertSize(bytes, size)\n    bytes = Bytes.trimRight(bytes)\n  }\n  return new TextDecoder().decode(bytes)\n}\n\nexport declare namespace toString {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_bytes.assertSize.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(\n  value: unknown,\n  options: validate.Options = {},\n): value is Hex {\n  const { strict = false } = options\n  try {\n    assert(value, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  override readonly name = 'Hex.IntegerOutOfRangeError'\n\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \\`${value}\\` is not in safe${\n        size ? ` ${size * 8}-bit` : ''\n      }${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`,\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexBooleanError'\n\n  constructor(hex: Hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`,\n      {\n        metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexValueError'\n\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: [\n        'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidLengthError'\n\n  constructor(value: Hex) {\n    super(\n      `Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`,\n      {\n        metaMessages: ['It must be an even length.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Hex.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}