{"ast":null,"code":"import { getRandomBytesSync } from 'ethereum-cryptography/random.js';\n// eslint-disable-next-line no-restricted-imports\nimport { bytesToHex as _bytesToUnprefixedHex } from 'ethereum-cryptography/utils.js';\nimport { assertIsArray, assertIsBytes, assertIsHexString } from './helpers.js';\nimport { isHexString, padToEven, stripHexPrefix } from './internal.js';\nconst BIGINT_0 = BigInt(0);\n/**\n * @deprecated\n */\nexport const bytesToUnprefixedHex = _bytesToUnprefixedHex;\n// hexToBytes cache\nconst hexToBytesMapFirstKey = {};\nconst hexToBytesMapSecondKey = {};\nfor (let i = 0; i < 16; i++) {\n  const vSecondKey = i;\n  const vFirstKey = i * 16;\n  const key = i.toString(16).toLowerCase();\n  hexToBytesMapSecondKey[key] = vSecondKey;\n  hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey;\n  hexToBytesMapFirstKey[key] = vFirstKey;\n  hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey;\n}\n/**\n * NOTE: only use this function if the string is even, and only consists of hex characters\n * If this is not the case, this function could return weird results\n * @deprecated\n */\nfunction _unprefixedHexToBytes(hex) {\n  const byteLen = hex.length;\n  const bytes = new Uint8Array(byteLen / 2);\n  for (let i = 0; i < byteLen; i += 2) {\n    bytes[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]];\n  }\n  return bytes;\n}\n/**\n * @deprecated\n */\nexport const unprefixedHexToBytes = inp => {\n  if (inp.slice(0, 2) === '0x') {\n    throw new Error('hex string is prefixed with 0x, should be unprefixed');\n  } else {\n    return _unprefixedHexToBytes(padToEven(inp));\n  }\n};\n/****************  Borrowed from @chainsafe/ssz */\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nexport const bytesToHex = bytes => {\n  let hex = `0x`;\n  if (bytes === undefined || bytes.length === 0) return hex;\n  for (const byte of bytes) {\n    hex = `${hex}${hexByByte[byte]}`;\n  }\n  return hex;\n};\n// BigInt cache for the numbers 0 - 256*256-1 (two-byte bytes)\nconst BIGINT_CACHE = [];\nfor (let i = 0; i <= 256 * 256 - 1; i++) {\n  BIGINT_CACHE[i] = BigInt(i);\n}\n/**\n * Converts a {@link Uint8Array} to a {@link bigint}\n * @param {Uint8Array} bytes the bytes to convert\n * @returns {bigint}\n */\nexport const bytesToBigInt = function (bytes) {\n  let littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (littleEndian) {\n    bytes.reverse();\n  }\n  const hex = bytesToHex(bytes);\n  if (hex === '0x') {\n    return BIGINT_0;\n  }\n  if (hex.length === 4) {\n    // If the byte length is 1 (this is faster than checking `bytes.length === 1`)\n    return BIGINT_CACHE[bytes[0]];\n  }\n  if (hex.length === 6) {\n    return BIGINT_CACHE[bytes[0] * 256 + bytes[1]];\n  }\n  return BigInt(hex);\n};\n/**\n * Converts a {@link Uint8Array} to a {@link number}.\n * @param {Uint8Array} bytes the bytes to convert\n * @return  {number}\n * @throws If the input number exceeds 53 bits.\n */\nexport const bytesToInt = bytes => {\n  const res = Number(bytesToBigInt(bytes));\n  if (!Number.isSafeInteger(res)) throw new Error('Number exceeds 53 bits');\n  return res;\n};\n// TODO: Restrict the input type to only PrefixedHexString\n/**\n * Converts a {@link PrefixedHexString} to a {@link Uint8Array}\n * @param {PrefixedHexString | string} hex The 0x-prefixed hex string to convert\n * @returns {Uint8Array} The converted bytes\n * @throws If the input is not a valid 0x-prefixed hex string\n */\nexport const hexToBytes = hex => {\n  if (typeof hex !== 'string') {\n    throw new Error(`hex argument type ${typeof hex} must be of type string`);\n  }\n  if (!/^0x[0-9a-fA-F]*$/.test(hex)) {\n    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);\n  }\n  const unprefixedHex = hex.slice(2);\n  return _unprefixedHexToBytes(unprefixedHex.length % 2 === 0 ? unprefixedHex : padToEven(unprefixedHex));\n};\n/******************************************/\n/**\n * Converts a {@link number} into a {@link PrefixedHexString}\n * @param {number} i\n * @return {PrefixedHexString}\n */\nexport const intToHex = i => {\n  if (!Number.isSafeInteger(i) || i < 0) {\n    throw new Error(`Received an invalid integer type: ${i}`);\n  }\n  return `0x${i.toString(16)}`;\n};\n/**\n * Converts an {@link number} to a {@link Uint8Array}\n * @param {Number} i\n * @return {Uint8Array}\n */\nexport const intToBytes = i => {\n  const hex = intToHex(i);\n  return hexToBytes(hex);\n};\n/**\n * Converts a {@link bigint} to a {@link Uint8Array}\n *  * @param {bigint} num the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToBytes = function (num) {\n  let littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const bytes = toBytes(`0x${padToEven(num.toString(16))}`);\n  return littleEndian ? bytes.reverse() : bytes;\n};\n/**\n * Returns a Uint8Array filled with 0s.\n * @param {number} bytes the number of bytes of the Uint8Array\n * @return {Uint8Array}\n */\nexport const zeros = bytes => {\n  return new Uint8Array(bytes);\n};\n/**\n * Pads a `Uint8Array` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @param {boolean} right whether to start padding form the left or right\n * @return {Uint8Array}\n */\nconst setLength = (msg, length, right) => {\n  if (right) {\n    if (msg.length < length) {\n      return new Uint8Array([...msg, ...zeros(length - msg.length)]);\n    }\n    return msg.subarray(0, length);\n  } else {\n    if (msg.length < length) {\n      return new Uint8Array([...zeros(length - msg.length), ...msg]);\n    }\n    return msg.subarray(-length);\n  }\n};\n/**\n * Left Pads a `Uint8Array` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthLeft = (msg, length) => {\n  assertIsBytes(msg);\n  return setLength(msg, length, false);\n};\n/**\n * Right Pads a `Uint8Array` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthRight = (msg, length) => {\n  assertIsBytes(msg);\n  return setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Uint8Array`, `number[]` or `string`.\n * @param {Uint8Array|number[]|string} a\n * @return {Uint8Array|number[]|string}\n */\nconst stripZeros = a => {\n  let first = a[0];\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n  return a;\n};\n/**\n * Trims leading zeros from a `Uint8Array`.\n * @param {Uint8Array} a\n * @return {Uint8Array}\n */\nexport const unpadBytes = a => {\n  assertIsBytes(a);\n  return stripZeros(a);\n};\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param  {number[]} a\n * @return {number[]}\n */\nexport const unpadArray = a => {\n  assertIsArray(a);\n  return stripZeros(a);\n};\n// TODO: Restrict the input type to only PrefixedHexString\n/**\n * Trims leading zeros from a `PrefixedHexString`.\n * @param {PrefixedHexString | string} a\n * @return {PrefixedHexString}\n */\nexport const unpadHex = a => {\n  assertIsHexString(a);\n  return `0x${stripZeros(stripHexPrefix(a))}`;\n};\n/**\n * Attempts to turn a value into a `Uint8Array`.\n * Inputs supported: `Buffer`, `Uint8Array`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBytes()` method.\n * @param {ToBytesInputTypes} v the value\n * @return {Uint8Array}\n */\nexport const toBytes = v => {\n  if (v === null || v === undefined) {\n    return new Uint8Array();\n  }\n  if (Array.isArray(v) || v instanceof Uint8Array) {\n    return Uint8Array.from(v);\n  }\n  if (typeof v === 'string') {\n    if (!isHexString(v)) {\n      throw new Error(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`);\n    }\n    return hexToBytes(v);\n  }\n  if (typeof v === 'number') {\n    return intToBytes(v);\n  }\n  if (typeof v === 'bigint') {\n    if (v < BIGINT_0) {\n      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);\n    }\n    let n = v.toString(16);\n    if (n.length % 2) n = '0' + n;\n    return unprefixedHexToBytes(n);\n  }\n  if (v.toBytes !== undefined) {\n    // converts a `TransformableToBytes` object to a Uint8Array\n    return v.toBytes();\n  }\n  throw new Error('invalid type');\n};\n/**\n * Interprets a `Uint8Array` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param {Uint8Array} num Signed integer value\n * @returns {bigint}\n */\nexport const fromSigned = num => {\n  return BigInt.asIntN(256, bytesToBigInt(num));\n};\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Uint8Array`. Assumes 256-bit numbers.\n * @param {bigint} num\n * @returns {Uint8Array}\n */\nexport const toUnsigned = num => {\n  return bigIntToBytes(BigInt.asUintN(256, num));\n};\n/**\n * Adds \"0x\" to a given `string` if it does not already start with \"0x\".\n * @param {string} str\n * @return {PrefixedHexString}\n */\nexport const addHexPrefix = str => {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  return isHexString(str) ? str : `0x${str}`;\n};\n/**\n * Shortens a string  or Uint8Array's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000…'\n * @param {Uint8Array | string} bytes\n * @param {number} maxLength\n * @return {string}\n */\nexport const short = function (bytes) {\n  let maxLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n  const byteStr = bytes instanceof Uint8Array ? bytesToHex(bytes) : bytes;\n  const len = byteStr.slice(0, 2) === '0x' ? maxLength + 2 : maxLength;\n  if (byteStr.length <= len) {\n    return byteStr;\n  }\n  return byteStr.slice(0, len) + '…';\n};\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nexport const validateNoLeadingZeroes = values => {\n  for (const [k, v] of Object.entries(values)) {\n    if (v !== undefined && v.length > 0 && v[0] === 0) {\n      throw new Error(`${k} cannot have leading zeroes, received: ${bytesToHex(v)}`);\n    }\n  }\n};\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n * @param {bigint} num the bigint to convert\n * @returns {PrefixedHexString}\n */\nexport const bigIntToHex = num => {\n  return `0x${num.toString(16)}`;\n};\n/**\n * Calculates max bigint from an array of bigints\n * @param args array of bigints\n */\nexport const bigIntMax = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return args.reduce((m, e) => e > m ? e : m);\n};\n/**\n * Calculates min BigInt from an array of BigInts\n * @param args array of bigints\n */\nexport const bigIntMin = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  return args.reduce((m, e) => e < m ? e : m);\n};\n/**\n * Convert value from bigint to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {bigint} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToUnpaddedBytes = value => {\n  return unpadBytes(bigIntToBytes(value));\n};\nexport const bigIntToAddressBytes = function (value) {\n  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const addressBytes = bigIntToBytes(value);\n  if (strict && addressBytes.length > 20) {\n    throw Error(`Invalid address bytes length=${addressBytes.length} strict=${strict}`);\n  }\n  // setLength already slices if more than requisite length\n  return setLengthLeft(addressBytes, 20);\n};\n/**\n * Convert value from number to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {number} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const intToUnpaddedBytes = value => {\n  return unpadBytes(intToBytes(value));\n};\n/**\n * Compares two Uint8Arrays and returns a number indicating their order in a sorted array.\n *\n * @param {Uint8Array} value1 - The first Uint8Array to compare.\n * @param {Uint8Array} value2 - The second Uint8Array to compare.\n * @returns {number} A positive number if value1 is larger than value2,\n *                   A negative number if value1 is smaller than value2,\n *                   or 0 if value1 and value2 are equal.\n */\nexport const compareBytes = (value1, value2) => {\n  const bigIntValue1 = bytesToBigInt(value1);\n  const bigIntValue2 = bytesToBigInt(value2);\n  return bigIntValue1 > bigIntValue2 ? 1 : bigIntValue1 < bigIntValue2 ? -1 : 0;\n};\n/**\n * Generates a Uint8Array of random bytes of specified length.\n *\n * @param {number} length - The length of the Uint8Array.\n * @returns {Uint8Array} A Uint8Array of random bytes of specified length.\n */\nexport const randomBytes = length => {\n  return getRandomBytesSync(length);\n};\n/**\n * This mirrors the functionality of the `ethereum-cryptography` export except\n * it skips the check to validate that every element of `arrays` is indead a `uint8Array`\n * Can give small performance gains on large arrays\n * @param {Uint8Array[]} arrays an array of Uint8Arrays\n * @returns {Uint8Array} one Uint8Array with all the elements of the original set\n * works like `Buffer.concat`\n */\nexport const concatBytes = function () {\n  for (var _len3 = arguments.length, arrays = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    arrays[_key3] = arguments[_key3];\n  }\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n};\n/**\n * @notice Convert a Uint8Array to a 32-bit integer\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 32-bit integer.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {number} The 32-bit integer read from the input Uint8Array.\n */\nexport function bytesToInt32(bytes) {\n  let littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (bytes.length < 4) {\n    bytes = setLength(bytes, 4, littleEndian);\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  return dataView.getUint32(0, littleEndian);\n}\n/**\n * @notice Convert a Uint8Array to a 64-bit bigint\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 64-bit bigint.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {bigint} The 64-bit bigint read from the input Uint8Array.\n */\nexport function bytesToBigInt64(bytes) {\n  let littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (bytes.length < 8) {\n    bytes = setLength(bytes, 8, littleEndian);\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  return dataView.getBigUint64(0, littleEndian);\n}\n/**\n * @notice Convert a 32-bit integer to a Uint8Array.\n * @param {number} value The 32-bit integer to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 4 containing the integer.\n */\nexport function int32ToBytes(value) {\n  let littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const buffer = new ArrayBuffer(4);\n  const dataView = new DataView(buffer);\n  dataView.setUint32(0, value, littleEndian);\n  return new Uint8Array(buffer);\n}\n/**\n * @notice Convert a 64-bit bigint to a Uint8Array.\n * @param {bigint} value The 64-bit bigint to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 8 containing the bigint.\n */\nexport function bigInt64ToBytes(value) {\n  let littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n  dataView.setBigUint64(0, value, littleEndian);\n  return new Uint8Array(buffer);\n}\n// eslint-disable-next-line no-restricted-imports\nexport { bytesToUtf8, equalsBytes, utf8ToBytes } from 'ethereum-cryptography/utils.js';\n// TODO: Restrict the input type to only PrefixedHexString\nexport function hexToBigInt(input) {\n  return bytesToBigInt(hexToBytes(isHexString(input) ? input : `0x${input}`));\n}","map":{"version":3,"names":["getRandomBytesSync","bytesToHex","_bytesToUnprefixedHex","assertIsArray","assertIsBytes","assertIsHexString","isHexString","padToEven","stripHexPrefix","BIGINT_0","BigInt","bytesToUnprefixedHex","hexToBytesMapFirstKey","hexToBytesMapSecondKey","i","vSecondKey","vFirstKey","key","toString","toLowerCase","toUpperCase","_unprefixedHexToBytes","hex","byteLen","length","bytes","Uint8Array","unprefixedHexToBytes","inp","slice","Error","hexByByte","Array","from","v","padStart","undefined","byte","BIGINT_CACHE","bytesToBigInt","littleEndian","arguments","reverse","bytesToInt","res","Number","isSafeInteger","hexToBytes","test","unprefixedHex","intToHex","intToBytes","bigIntToBytes","num","toBytes","zeros","setLength","msg","right","subarray","setLengthLeft","setLengthRight","stripZeros","a","first","unpadBytes","unpadArray","unpadHex","isArray","n","fromSigned","asIntN","toUnsigned","asUintN","addHexPrefix","str","short","maxLength","byteStr","len","validateNoLeadingZeroes","values","k","Object","entries","bigIntToHex","bigIntMax","_len","args","_key","reduce","m","e","bigIntMin","_len2","_key2","bigIntToUnpaddedBytes","value","bigIntToAddressBytes","strict","addressBytes","intToUnpaddedBytes","compareBytes","value1","value2","bigIntValue1","bigIntValue2","randomBytes","concatBytes","_len3","arrays","_key3","arr","result","pad","set","bytesToInt32","dataView","DataView","buffer","byteOffset","byteLength","getUint32","bytesToBigInt64","getBigUint64","int32ToBytes","ArrayBuffer","setUint32","bigInt64ToBytes","setBigUint64","bytesToUtf8","equalsBytes","utf8ToBytes","hexToBigInt","input"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@ethereumjs/util/src/bytes.ts"],"sourcesContent":["import { getRandomBytesSync } from 'ethereum-cryptography/random.js'\n// eslint-disable-next-line no-restricted-imports\nimport { bytesToHex as _bytesToUnprefixedHex } from 'ethereum-cryptography/utils.js'\n\nimport { assertIsArray, assertIsBytes, assertIsHexString } from './helpers.js'\nimport { isHexString, padToEven, stripHexPrefix } from './internal.js'\n\nimport type { PrefixedHexString, TransformabletoBytes } from './types.js'\n\nconst BIGINT_0 = BigInt(0)\n\n/**\n * @deprecated\n */\nexport const bytesToUnprefixedHex = _bytesToUnprefixedHex\n\n// hexToBytes cache\nconst hexToBytesMapFirstKey: { [key: string]: number } = {}\nconst hexToBytesMapSecondKey: { [key: string]: number } = {}\n\nfor (let i = 0; i < 16; i++) {\n  const vSecondKey = i\n  const vFirstKey = i * 16\n  const key = i.toString(16).toLowerCase()\n  hexToBytesMapSecondKey[key] = vSecondKey\n  hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey\n  hexToBytesMapFirstKey[key] = vFirstKey\n  hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey\n}\n\n/**\n * NOTE: only use this function if the string is even, and only consists of hex characters\n * If this is not the case, this function could return weird results\n * @deprecated\n */\nfunction _unprefixedHexToBytes(hex: string): Uint8Array {\n  const byteLen = hex.length\n  const bytes = new Uint8Array(byteLen / 2)\n  for (let i = 0; i < byteLen; i += 2) {\n    bytes[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]]\n  }\n  return bytes\n}\n\n/**\n * @deprecated\n */\nexport const unprefixedHexToBytes = (inp: string) => {\n  if (inp.slice(0, 2) === '0x') {\n    throw new Error('hex string is prefixed with 0x, should be unprefixed')\n  } else {\n    return _unprefixedHexToBytes(padToEven(inp))\n  }\n}\n\n/****************  Borrowed from @chainsafe/ssz */\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'))\n\nexport const bytesToHex = (bytes: Uint8Array): PrefixedHexString => {\n  let hex: PrefixedHexString = `0x`\n  if (bytes === undefined || bytes.length === 0) return hex\n  for (const byte of bytes) {\n    hex = `${hex}${hexByByte[byte]}`\n  }\n  return hex\n}\n\n// BigInt cache for the numbers 0 - 256*256-1 (two-byte bytes)\nconst BIGINT_CACHE: bigint[] = []\nfor (let i = 0; i <= 256 * 256 - 1; i++) {\n  BIGINT_CACHE[i] = BigInt(i)\n}\n\n/**\n * Converts a {@link Uint8Array} to a {@link bigint}\n * @param {Uint8Array} bytes the bytes to convert\n * @returns {bigint}\n */\nexport const bytesToBigInt = (bytes: Uint8Array, littleEndian = false): bigint => {\n  if (littleEndian) {\n    bytes.reverse()\n  }\n  const hex = bytesToHex(bytes)\n  if (hex === '0x') {\n    return BIGINT_0\n  }\n  if (hex.length === 4) {\n    // If the byte length is 1 (this is faster than checking `bytes.length === 1`)\n    return BIGINT_CACHE[bytes[0]]\n  }\n  if (hex.length === 6) {\n    return BIGINT_CACHE[bytes[0] * 256 + bytes[1]]\n  }\n  return BigInt(hex)\n}\n\n/**\n * Converts a {@link Uint8Array} to a {@link number}.\n * @param {Uint8Array} bytes the bytes to convert\n * @return  {number}\n * @throws If the input number exceeds 53 bits.\n */\nexport const bytesToInt = (bytes: Uint8Array): number => {\n  const res = Number(bytesToBigInt(bytes))\n  if (!Number.isSafeInteger(res)) throw new Error('Number exceeds 53 bits')\n  return res\n}\n\n// TODO: Restrict the input type to only PrefixedHexString\n/**\n * Converts a {@link PrefixedHexString} to a {@link Uint8Array}\n * @param {PrefixedHexString | string} hex The 0x-prefixed hex string to convert\n * @returns {Uint8Array} The converted bytes\n * @throws If the input is not a valid 0x-prefixed hex string\n */\nexport const hexToBytes = (hex: PrefixedHexString | string): Uint8Array => {\n  if (typeof hex !== 'string') {\n    throw new Error(`hex argument type ${typeof hex} must be of type string`)\n  }\n\n  if (!/^0x[0-9a-fA-F]*$/.test(hex)) {\n    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`)\n  }\n\n  const unprefixedHex = hex.slice(2)\n\n  return _unprefixedHexToBytes(\n    unprefixedHex.length % 2 === 0 ? unprefixedHex : padToEven(unprefixedHex)\n  )\n}\n\n/******************************************/\n\n/**\n * Converts a {@link number} into a {@link PrefixedHexString}\n * @param {number} i\n * @return {PrefixedHexString}\n */\nexport const intToHex = (i: number): PrefixedHexString => {\n  if (!Number.isSafeInteger(i) || i < 0) {\n    throw new Error(`Received an invalid integer type: ${i}`)\n  }\n  return `0x${i.toString(16)}`\n}\n\n/**\n * Converts an {@link number} to a {@link Uint8Array}\n * @param {Number} i\n * @return {Uint8Array}\n */\nexport const intToBytes = (i: number): Uint8Array => {\n  const hex = intToHex(i)\n  return hexToBytes(hex)\n}\n\n/**\n * Converts a {@link bigint} to a {@link Uint8Array}\n *  * @param {bigint} num the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToBytes = (num: bigint, littleEndian = false): Uint8Array => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const bytes = toBytes(`0x${padToEven(num.toString(16))}`)\n\n  return littleEndian ? bytes.reverse() : bytes\n}\n\n/**\n * Returns a Uint8Array filled with 0s.\n * @param {number} bytes the number of bytes of the Uint8Array\n * @return {Uint8Array}\n */\nexport const zeros = (bytes: number): Uint8Array => {\n  return new Uint8Array(bytes)\n}\n\n/**\n * Pads a `Uint8Array` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @param {boolean} right whether to start padding form the left or right\n * @return {Uint8Array}\n */\nconst setLength = (msg: Uint8Array, length: number, right: boolean): Uint8Array => {\n  if (right) {\n    if (msg.length < length) {\n      return new Uint8Array([...msg, ...zeros(length - msg.length)])\n    }\n    return msg.subarray(0, length)\n  } else {\n    if (msg.length < length) {\n      return new Uint8Array([...zeros(length - msg.length), ...msg])\n    }\n    return msg.subarray(-length)\n  }\n}\n\n/**\n * Left Pads a `Uint8Array` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthLeft = (msg: Uint8Array, length: number): Uint8Array => {\n  assertIsBytes(msg)\n  return setLength(msg, length, false)\n}\n\n/**\n * Right Pads a `Uint8Array` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthRight = (msg: Uint8Array, length: number): Uint8Array => {\n  assertIsBytes(msg)\n  return setLength(msg, length, true)\n}\n\n/**\n * Trims leading zeros from a `Uint8Array`, `number[]` or `string`.\n * @param {Uint8Array|number[]|string} a\n * @return {Uint8Array|number[]|string}\n */\nconst stripZeros = <T extends Uint8Array | number[] | string = Uint8Array | number[] | string>(\n  a: T\n): T => {\n  let first = a[0]\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1) as T\n    first = a[0]\n  }\n  return a\n}\n\n/**\n * Trims leading zeros from a `Uint8Array`.\n * @param {Uint8Array} a\n * @return {Uint8Array}\n */\nexport const unpadBytes = (a: Uint8Array): Uint8Array => {\n  assertIsBytes(a)\n  return stripZeros(a)\n}\n\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param  {number[]} a\n * @return {number[]}\n */\nexport const unpadArray = (a: number[]): number[] => {\n  assertIsArray(a)\n  return stripZeros(a)\n}\n\n// TODO: Restrict the input type to only PrefixedHexString\n/**\n * Trims leading zeros from a `PrefixedHexString`.\n * @param {PrefixedHexString | string} a\n * @return {PrefixedHexString}\n */\nexport const unpadHex = (a: PrefixedHexString | string): PrefixedHexString => {\n  assertIsHexString(a)\n  return `0x${stripZeros(stripHexPrefix(a))}`\n}\n\n// TODO: remove the string type from this function (only keep PrefixedHexString)\nexport type ToBytesInputTypes =\n  | PrefixedHexString\n  | string\n  | number\n  | bigint\n  | Uint8Array\n  | number[]\n  | TransformabletoBytes\n  | null\n  | undefined\n\n/**\n * Attempts to turn a value into a `Uint8Array`.\n * Inputs supported: `Buffer`, `Uint8Array`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBytes()` method.\n * @param {ToBytesInputTypes} v the value\n * @return {Uint8Array}\n */\n\nexport const toBytes = (v: ToBytesInputTypes): Uint8Array => {\n  if (v === null || v === undefined) {\n    return new Uint8Array()\n  }\n\n  if (Array.isArray(v) || v instanceof Uint8Array) {\n    return Uint8Array.from(v)\n  }\n\n  if (typeof v === 'string') {\n    if (!isHexString(v)) {\n      throw new Error(\n        `Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`\n      )\n    }\n    return hexToBytes(v)\n  }\n\n  if (typeof v === 'number') {\n    return intToBytes(v)\n  }\n\n  if (typeof v === 'bigint') {\n    if (v < BIGINT_0) {\n      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`)\n    }\n    let n = v.toString(16)\n    if (n.length % 2) n = '0' + n\n    return unprefixedHexToBytes(n)\n  }\n\n  if (v.toBytes !== undefined) {\n    // converts a `TransformableToBytes` object to a Uint8Array\n    return v.toBytes()\n  }\n\n  throw new Error('invalid type')\n}\n\n/**\n * Interprets a `Uint8Array` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param {Uint8Array} num Signed integer value\n * @returns {bigint}\n */\nexport const fromSigned = (num: Uint8Array): bigint => {\n  return BigInt.asIntN(256, bytesToBigInt(num))\n}\n\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Uint8Array`. Assumes 256-bit numbers.\n * @param {bigint} num\n * @returns {Uint8Array}\n */\nexport const toUnsigned = (num: bigint): Uint8Array => {\n  return bigIntToBytes(BigInt.asUintN(256, num))\n}\n\n/**\n * Adds \"0x\" to a given `string` if it does not already start with \"0x\".\n * @param {string} str\n * @return {PrefixedHexString}\n */\nexport const addHexPrefix = (str: string): PrefixedHexString => {\n  if (typeof str !== 'string') {\n    return str\n  }\n\n  return isHexString(str) ? str : `0x${str}`\n}\n\n/**\n * Shortens a string  or Uint8Array's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000…'\n * @param {Uint8Array | string} bytes\n * @param {number} maxLength\n * @return {string}\n */\nexport const short = (bytes: Uint8Array | string, maxLength: number = 50): string => {\n  const byteStr = bytes instanceof Uint8Array ? bytesToHex(bytes) : bytes\n  const len = byteStr.slice(0, 2) === '0x' ? maxLength + 2 : maxLength\n  if (byteStr.length <= len) {\n    return byteStr\n  }\n  return byteStr.slice(0, len) + '…'\n}\n\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nexport const validateNoLeadingZeroes = (values: { [key: string]: Uint8Array | undefined }) => {\n  for (const [k, v] of Object.entries(values)) {\n    if (v !== undefined && v.length > 0 && v[0] === 0) {\n      throw new Error(`${k} cannot have leading zeroes, received: ${bytesToHex(v)}`)\n    }\n  }\n}\n\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n * @param {bigint} num the bigint to convert\n * @returns {PrefixedHexString}\n */\nexport const bigIntToHex = (num: bigint): PrefixedHexString => {\n  return `0x${num.toString(16)}`\n}\n\n/**\n * Calculates max bigint from an array of bigints\n * @param args array of bigints\n */\nexport const bigIntMax = (...args: bigint[]) => args.reduce((m, e) => (e > m ? e : m))\n\n/**\n * Calculates min BigInt from an array of BigInts\n * @param args array of bigints\n */\nexport const bigIntMin = (...args: bigint[]) => args.reduce((m, e) => (e < m ? e : m))\n\n/**\n * Convert value from bigint to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {bigint} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToUnpaddedBytes = (value: bigint): Uint8Array => {\n  return unpadBytes(bigIntToBytes(value))\n}\n\nexport const bigIntToAddressBytes = (value: bigint, strict: boolean = true): Uint8Array => {\n  const addressBytes = bigIntToBytes(value)\n  if (strict && addressBytes.length > 20) {\n    throw Error(`Invalid address bytes length=${addressBytes.length} strict=${strict}`)\n  }\n\n  // setLength already slices if more than requisite length\n  return setLengthLeft(addressBytes, 20)\n}\n\n/**\n * Convert value from number to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {number} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const intToUnpaddedBytes = (value: number): Uint8Array => {\n  return unpadBytes(intToBytes(value))\n}\n\n/**\n * Compares two Uint8Arrays and returns a number indicating their order in a sorted array.\n *\n * @param {Uint8Array} value1 - The first Uint8Array to compare.\n * @param {Uint8Array} value2 - The second Uint8Array to compare.\n * @returns {number} A positive number if value1 is larger than value2,\n *                   A negative number if value1 is smaller than value2,\n *                   or 0 if value1 and value2 are equal.\n */\nexport const compareBytes = (value1: Uint8Array, value2: Uint8Array): number => {\n  const bigIntValue1 = bytesToBigInt(value1)\n  const bigIntValue2 = bytesToBigInt(value2)\n  return bigIntValue1 > bigIntValue2 ? 1 : bigIntValue1 < bigIntValue2 ? -1 : 0\n}\n\n/**\n * Generates a Uint8Array of random bytes of specified length.\n *\n * @param {number} length - The length of the Uint8Array.\n * @returns {Uint8Array} A Uint8Array of random bytes of specified length.\n */\nexport const randomBytes = (length: number): Uint8Array => {\n  return getRandomBytesSync(length)\n}\n\n/**\n * This mirrors the functionality of the `ethereum-cryptography` export except\n * it skips the check to validate that every element of `arrays` is indead a `uint8Array`\n * Can give small performance gains on large arrays\n * @param {Uint8Array[]} arrays an array of Uint8Arrays\n * @returns {Uint8Array} one Uint8Array with all the elements of the original set\n * works like `Buffer.concat`\n */\nexport const concatBytes = (...arrays: Uint8Array[]): Uint8Array => {\n  if (arrays.length === 1) return arrays[0]\n  const length = arrays.reduce((a, arr) => a + arr.length, 0)\n  const result = new Uint8Array(length)\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i]\n    result.set(arr, pad)\n    pad += arr.length\n  }\n  return result\n}\n\n/**\n * @notice Convert a Uint8Array to a 32-bit integer\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 32-bit integer.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {number} The 32-bit integer read from the input Uint8Array.\n */\nexport function bytesToInt32(bytes: Uint8Array, littleEndian: boolean = false): number {\n  if (bytes.length < 4) {\n    bytes = setLength(bytes, 4, littleEndian)\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dataView.getUint32(0, littleEndian)\n}\n\n/**\n * @notice Convert a Uint8Array to a 64-bit bigint\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 64-bit bigint.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {bigint} The 64-bit bigint read from the input Uint8Array.\n */\nexport function bytesToBigInt64(bytes: Uint8Array, littleEndian: boolean = false): bigint {\n  if (bytes.length < 8) {\n    bytes = setLength(bytes, 8, littleEndian)\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dataView.getBigUint64(0, littleEndian)\n}\n\n/**\n * @notice Convert a 32-bit integer to a Uint8Array.\n * @param {number} value The 32-bit integer to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 4 containing the integer.\n */\nexport function int32ToBytes(value: number, littleEndian: boolean = false): Uint8Array {\n  const buffer = new ArrayBuffer(4)\n  const dataView = new DataView(buffer)\n  dataView.setUint32(0, value, littleEndian)\n  return new Uint8Array(buffer)\n}\n\n/**\n * @notice Convert a 64-bit bigint to a Uint8Array.\n * @param {bigint} value The 64-bit bigint to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 8 containing the bigint.\n */\nexport function bigInt64ToBytes(value: bigint, littleEndian: boolean = false): Uint8Array {\n  const buffer = new ArrayBuffer(8)\n  const dataView = new DataView(buffer)\n  dataView.setBigUint64(0, value, littleEndian)\n  return new Uint8Array(buffer)\n}\n\n// eslint-disable-next-line no-restricted-imports\nexport { bytesToUtf8, equalsBytes, utf8ToBytes } from 'ethereum-cryptography/utils.js'\n\n// TODO: Restrict the input type to only PrefixedHexString\nexport function hexToBigInt(input: PrefixedHexString | string): bigint {\n  return bytesToBigInt(hexToBytes(isHexString(input) ? input : `0x${input}`))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}