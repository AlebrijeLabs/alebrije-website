{"ast":null,"code":"import WalletService from'./wallet-service';import TokenService from'./token-service';import config from'../config';import{handleWalletError,ErrorTypes,AlebrijeError}from'../utils/error-handler';class TransactionHistoryService{constructor(){this.transactions=new Map();// tokenName -> transactions array\nthis.isLoading=false;this.lastFetchTime=null;this.eventSubscriptions={};}/**\n   * Initialize transaction history for a token\n   * @param {string} tokenName - Name of the token\n   */async initialize(tokenName){if(!this.transactions.has(tokenName)){this.transactions.set(tokenName,[]);}// Subscribe to token transfer events\nthis._subscribeToTransferEvents(tokenName);// Load initial transaction history\nreturn this.fetchTransactionHistory(tokenName);}/**\n   * Fetch transaction history for a token\n   * @param {string} tokenName - Name of the token\n   * @param {number} limit - Maximum number of transactions to fetch\n   * @returns {Promise<Array>} - Array of transactions\n   */async fetchTransactionHistory(tokenName){let limit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:50;if(!WalletService.isConnected()){throw new AlebrijeError('Wallet not connected',ErrorTypes.WALLET);}const account=WalletService.getCurrentAccount();if(!account){throw new AlebrijeError('No account selected',ErrorTypes.WALLET);}this.isLoading=true;try{// Get token info\nconst tokenInfo=TokenService.getTokenInfo(tokenName);if(!tokenInfo){throw new AlebrijeError(`Token ${tokenName} not found`,ErrorTypes.USER);}// Determine which blockchain to use\nconst blockchain=tokenInfo.blockchain||config.DEFAULT_NETWORK.blockchain;// Fetch transactions based on blockchain\nlet transactions=[];if(blockchain==='ethereum'){transactions=await this._fetchEthereumTransactions(tokenName,account,limit);}else if(blockchain==='solana'){transactions=await this._fetchSolanaTransactions(tokenName,account,limit);}else{throw new AlebrijeError(`Unsupported blockchain: ${blockchain}`,ErrorTypes.UNKNOWN);}// Update the transactions map\nthis.transactions.set(tokenName,transactions);this.lastFetchTime=new Date();return transactions;}catch(error){throw handleWalletError(error,`Failed to fetch transaction history for ${tokenName}`);}finally{this.isLoading=false;}}/**\n   * Get cached transaction history for a token\n   * @param {string} tokenName - Name of the token\n   * @returns {Array} - Array of transactions\n   */getTransactionHistory(tokenName){return this.transactions.get(tokenName)||[];}/**\n   * Add a new transaction to the history\n   * @param {string} tokenName - Name of the token\n   * @param {Object} transaction - Transaction object\n   */addTransaction(tokenName,transaction){if(!this.transactions.has(tokenName)){this.transactions.set(tokenName,[]);}const transactions=this.transactions.get(tokenName);// Check if transaction already exists\nconst exists=transactions.some(tx=>tx.hash===transaction.hash);if(!exists){transactions.unshift(transaction);// Add to the beginning of the array\nthis.transactions.set(tokenName,transactions);}}/**\n   * Clean up resources\n   */cleanup(){// Unsubscribe from all event subscriptions\nObject.values(this.eventSubscriptions).forEach(unsubscribe=>{if(typeof unsubscribe==='function'){unsubscribe();}});this.eventSubscriptions={};}// Private methods\n/**\n   * Fetch Ethereum transactions\n   * @private\n   */async _fetchEthereumTransactions(tokenName,account,limit){var _config$API_KEYS;const tokenAddress=TokenService.getTokenAddress(tokenName);// Use Etherscan API or similar service to fetch transaction history\nconst apiKey=(_config$API_KEYS=config.API_KEYS)===null||_config$API_KEYS===void 0?void 0:_config$API_KEYS.etherscan;const network=config.DEFAULT_NETWORK.network;const baseUrl=network==='mainnet'?'https://api.etherscan.io/api':`https://api-${network}.etherscan.io/api`;const url=`${baseUrl}?module=account&action=tokentx&contractaddress=${tokenAddress}&address=${account}&sort=desc&limit=${limit}${apiKey?`&apikey=${apiKey}`:''}`;try{const response=await fetch(url);const data=await response.json();if(data.status!=='1'){throw new Error(data.message||'Failed to fetch transactions');}// Transform the response into our transaction format\nreturn data.result.map(tx=>({hash:tx.hash,from:tx.from,to:tx.to,value:TokenService.formatTokenAmount(tx.value,tokenName),timestamp:new Date(parseInt(tx.timeStamp)*1000),blockNumber:parseInt(tx.blockNumber),confirmations:parseInt(tx.confirmations),isIncoming:tx.to.toLowerCase()===account.toLowerCase(),status:'confirmed'}));}catch(error){console.error('Error fetching Ethereum transactions:',error);// If API fails, try to get transactions from events\nreturn this._getTransactionsFromEvents(tokenName);}}/**\n   * Fetch Solana transactions\n   * @private\n   */async _fetchSolanaTransactions(tokenName,account,limit){// Implementation for Solana would go here\n// This is a placeholder\nreturn[];}/**\n   * Get transactions from cached events\n   * @private\n   */_getTransactionsFromEvents(tokenName){// This is a fallback method if API calls fail\nreturn this.transactions.get(tokenName)||[];}/**\n   * Subscribe to token transfer events\n   * @private\n   */_subscribeToTransferEvents(tokenName){// Unsubscribe from previous subscription if exists\nif(this.eventSubscriptions[tokenName]){this.eventSubscriptions[tokenName]();}// Subscribe to new events\nconst unsubscribe=TokenService.subscribeToTransfers(tokenName,(error,event)=>{if(error){console.error(`Error in transfer event for ${tokenName}:`,error);return;}const account=WalletService.getCurrentAccount();if(!account)return;// Create transaction object from event\nconst transaction={hash:event.transactionHash,from:event.from,to:event.to,value:event.value,timestamp:new Date(),blockNumber:event.blockNumber,confirmations:1,isIncoming:event.to.toLowerCase()===account.toLowerCase(),status:'confirmed'};// Add to transaction history\nthis.addTransaction(tokenName,transaction);});this.eventSubscriptions[tokenName]=unsubscribe;}}export default new TransactionHistoryService();","map":{"version":3,"names":["WalletService","TokenService","config","handleWalletError","ErrorTypes","AlebrijeError","TransactionHistoryService","constructor","transactions","Map","isLoading","lastFetchTime","eventSubscriptions","initialize","tokenName","has","set","_subscribeToTransferEvents","fetchTransactionHistory","limit","arguments","length","undefined","isConnected","WALLET","account","getCurrentAccount","tokenInfo","getTokenInfo","USER","blockchain","DEFAULT_NETWORK","_fetchEthereumTransactions","_fetchSolanaTransactions","UNKNOWN","Date","error","getTransactionHistory","get","addTransaction","transaction","exists","some","tx","hash","unshift","cleanup","Object","values","forEach","unsubscribe","_config$API_KEYS","tokenAddress","getTokenAddress","apiKey","API_KEYS","etherscan","network","baseUrl","url","response","fetch","data","json","status","Error","message","result","map","from","to","value","formatTokenAmount","timestamp","parseInt","timeStamp","blockNumber","confirmations","isIncoming","toLowerCase","console","_getTransactionsFromEvents","subscribeToTransfers","event","transactionHash"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/transaction-history-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport TokenService from './token-service';\nimport config from '../config';\nimport { handleWalletError, ErrorTypes, AlebrijeError } from '../utils/error-handler';\n\nclass TransactionHistoryService {\n  constructor() {\n    this.transactions = new Map(); // tokenName -> transactions array\n    this.isLoading = false;\n    this.lastFetchTime = null;\n    this.eventSubscriptions = {};\n  }\n  \n  /**\n   * Initialize transaction history for a token\n   * @param {string} tokenName - Name of the token\n   */\n  async initialize(tokenName) {\n    if (!this.transactions.has(tokenName)) {\n      this.transactions.set(tokenName, []);\n    }\n    \n    // Subscribe to token transfer events\n    this._subscribeToTransferEvents(tokenName);\n    \n    // Load initial transaction history\n    return this.fetchTransactionHistory(tokenName);\n  }\n  \n  /**\n   * Fetch transaction history for a token\n   * @param {string} tokenName - Name of the token\n   * @param {number} limit - Maximum number of transactions to fetch\n   * @returns {Promise<Array>} - Array of transactions\n   */\n  async fetchTransactionHistory(tokenName, limit = 50) {\n    if (!WalletService.isConnected()) {\n      throw new AlebrijeError('Wallet not connected', ErrorTypes.WALLET);\n    }\n    \n    const account = WalletService.getCurrentAccount();\n    if (!account) {\n      throw new AlebrijeError('No account selected', ErrorTypes.WALLET);\n    }\n    \n    this.isLoading = true;\n    \n    try {\n      // Get token info\n      const tokenInfo = TokenService.getTokenInfo(tokenName);\n      if (!tokenInfo) {\n        throw new AlebrijeError(`Token ${tokenName} not found`, ErrorTypes.USER);\n      }\n      \n      // Determine which blockchain to use\n      const blockchain = tokenInfo.blockchain || config.DEFAULT_NETWORK.blockchain;\n      \n      // Fetch transactions based on blockchain\n      let transactions = [];\n      \n      if (blockchain === 'ethereum') {\n        transactions = await this._fetchEthereumTransactions(tokenName, account, limit);\n      } else if (blockchain === 'solana') {\n        transactions = await this._fetchSolanaTransactions(tokenName, account, limit);\n      } else {\n        throw new AlebrijeError(`Unsupported blockchain: ${blockchain}`, ErrorTypes.UNKNOWN);\n      }\n      \n      // Update the transactions map\n      this.transactions.set(tokenName, transactions);\n      this.lastFetchTime = new Date();\n      \n      return transactions;\n    } catch (error) {\n      throw handleWalletError(error, `Failed to fetch transaction history for ${tokenName}`);\n    } finally {\n      this.isLoading = false;\n    }\n  }\n  \n  /**\n   * Get cached transaction history for a token\n   * @param {string} tokenName - Name of the token\n   * @returns {Array} - Array of transactions\n   */\n  getTransactionHistory(tokenName) {\n    return this.transactions.get(tokenName) || [];\n  }\n  \n  /**\n   * Add a new transaction to the history\n   * @param {string} tokenName - Name of the token\n   * @param {Object} transaction - Transaction object\n   */\n  addTransaction(tokenName, transaction) {\n    if (!this.transactions.has(tokenName)) {\n      this.transactions.set(tokenName, []);\n    }\n    \n    const transactions = this.transactions.get(tokenName);\n    \n    // Check if transaction already exists\n    const exists = transactions.some(tx => tx.hash === transaction.hash);\n    if (!exists) {\n      transactions.unshift(transaction); // Add to the beginning of the array\n      this.transactions.set(tokenName, transactions);\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    // Unsubscribe from all event subscriptions\n    Object.values(this.eventSubscriptions).forEach(unsubscribe => {\n      if (typeof unsubscribe === 'function') {\n        unsubscribe();\n      }\n    });\n    \n    this.eventSubscriptions = {};\n  }\n  \n  // Private methods\n  \n  /**\n   * Fetch Ethereum transactions\n   * @private\n   */\n  async _fetchEthereumTransactions(tokenName, account, limit) {\n    const tokenAddress = TokenService.getTokenAddress(tokenName);\n    \n    // Use Etherscan API or similar service to fetch transaction history\n    const apiKey = config.API_KEYS?.etherscan;\n    const network = config.DEFAULT_NETWORK.network;\n    const baseUrl = network === 'mainnet' \n      ? 'https://api.etherscan.io/api' \n      : `https://api-${network}.etherscan.io/api`;\n    \n    const url = `${baseUrl}?module=account&action=tokentx&contractaddress=${tokenAddress}&address=${account}&sort=desc&limit=${limit}${apiKey ? `&apikey=${apiKey}` : ''}`;\n    \n    try {\n      const response = await fetch(url);\n      const data = await response.json();\n      \n      if (data.status !== '1') {\n        throw new Error(data.message || 'Failed to fetch transactions');\n      }\n      \n      // Transform the response into our transaction format\n      return data.result.map(tx => ({\n        hash: tx.hash,\n        from: tx.from,\n        to: tx.to,\n        value: TokenService.formatTokenAmount(tx.value, tokenName),\n        timestamp: new Date(parseInt(tx.timeStamp) * 1000),\n        blockNumber: parseInt(tx.blockNumber),\n        confirmations: parseInt(tx.confirmations),\n        isIncoming: tx.to.toLowerCase() === account.toLowerCase(),\n        status: 'confirmed'\n      }));\n    } catch (error) {\n      console.error('Error fetching Ethereum transactions:', error);\n      \n      // If API fails, try to get transactions from events\n      return this._getTransactionsFromEvents(tokenName);\n    }\n  }\n  \n  /**\n   * Fetch Solana transactions\n   * @private\n   */\n  async _fetchSolanaTransactions(tokenName, account, limit) {\n    // Implementation for Solana would go here\n    // This is a placeholder\n    return [];\n  }\n  \n  /**\n   * Get transactions from cached events\n   * @private\n   */\n  _getTransactionsFromEvents(tokenName) {\n    // This is a fallback method if API calls fail\n    return this.transactions.get(tokenName) || [];\n  }\n  \n  /**\n   * Subscribe to token transfer events\n   * @private\n   */\n  _subscribeToTransferEvents(tokenName) {\n    // Unsubscribe from previous subscription if exists\n    if (this.eventSubscriptions[tokenName]) {\n      this.eventSubscriptions[tokenName]();\n    }\n    \n    // Subscribe to new events\n    const unsubscribe = TokenService.subscribeToTransfers(tokenName, (error, event) => {\n      if (error) {\n        console.error(`Error in transfer event for ${tokenName}:`, error);\n        return;\n      }\n      \n      const account = WalletService.getCurrentAccount();\n      if (!account) return;\n      \n      // Create transaction object from event\n      const transaction = {\n        hash: event.transactionHash,\n        from: event.from,\n        to: event.to,\n        value: event.value,\n        timestamp: new Date(),\n        blockNumber: event.blockNumber,\n        confirmations: 1,\n        isIncoming: event.to.toLowerCase() === account.toLowerCase(),\n        status: 'confirmed'\n      };\n      \n      // Add to transaction history\n      this.addTransaction(tokenName, transaction);\n    });\n    \n    this.eventSubscriptions[tokenName] = unsubscribe;\n  }\n}\n\nexport default new TransactionHistoryService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}