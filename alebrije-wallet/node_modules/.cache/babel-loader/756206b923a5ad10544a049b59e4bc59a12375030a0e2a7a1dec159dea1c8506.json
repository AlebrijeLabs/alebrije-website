{"ast":null,"code":"import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction, getAssociatedTokenAddress } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint || clusterApiUrl('devnet'), 'confirmed');\n  }\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(tokenPublicKey, walletPublicKey);\n      try {\n        const accountInfo = await this.connection.getTokenAccountBalance(associatedTokenAddress);\n        return accountInfo.value.uiAmount;\n      } catch (err) {\n        // If account doesn't exist, return 0\n        return 0;\n      }\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw new Error('Failed to get token balance: ' + error.message);\n    }\n  }\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const toPublicKey = new PublicKey(toAddress);\n\n      // Get token decimals\n      const tokenInfo = await this.getTokenInfo(tokenAddress);\n      const decimals = tokenInfo.decimals;\n\n      // Calculate token amounts with decimals\n      const rawAmount = amount * Math.pow(10, decimals);\n\n      // Get or create associated token accounts\n      const fromTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, fromPublicKey);\n      const toTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, toPublicKey);\n\n      // Create transaction\n      const transaction = new Transaction();\n\n      // Check if recipient token account exists\n      const recipientAccount = await this.connection.getAccountInfo(toTokenAccount);\n\n      // If recipient account doesn't exist, add create instruction\n      if (!recipientAccount) {\n        const createAccountInstruction = await createAssociatedTokenAccountInstruction(fromPublicKey,\n        // payer\n        toTokenAccount,\n        // associated token account\n        toPublicKey,\n        // owner\n        tokenPublicKey // mint\n        );\n        transaction.add(createAccountInstruction);\n      }\n\n      // Add transfer instruction\n      const transferInstruction = createTransferInstruction(fromTokenAccount, toTokenAccount, fromPublicKey, rawAmount, [], TOKEN_PROGRAM_ID);\n      transaction.add(transferInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('No compatible wallet found');\n      }\n\n      // Sign and send transaction\n      try {\n        var _confirmation$value;\n        const signed = await walletAdapter.signTransaction(transaction);\n        const signature = await this.connection.sendRawTransaction(signed.serialize());\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');\n        if ((_confirmation$value = confirmation.value) !== null && _confirmation$value !== void 0 && _confirmation$value.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        var _signError$message;\n        if ((_signError$message = signError.message) !== null && _signError$message !== void 0 && _signError$message.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('Token transfer error:', error);\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      if (!tokenInfo.value || !tokenInfo.value.data.parsed) {\n        throw new Error('Invalid token address');\n      }\n      const mintInfo = tokenInfo.value.data.parsed.info;\n\n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: mintInfo.decimals,\n        supply: mintInfo.supply,\n        name: mintInfo.name || 'Unknown Token',\n        symbol: mintInfo.symbol || 'UNKNOWN'\n      };\n\n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw new Error('Failed to get token info: ' + error.message);\n    }\n  }\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(walletPublicKey, {\n        limit\n      });\n\n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n  async transferNativeSOL(fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n\n      // Check balance before transfer\n      const balance = await this.connection.getBalance(fromPublicKey);\n      const transferAmount = amount * LAMPORTS_PER_SOL;\n      const estimatedFee = 5000; // Approximate fee in lamports\n\n      if (balance < transferAmount + estimatedFee) {\n        throw new Error('Insufficient balance for transfer and fees');\n      }\n\n      // Create a simple transfer instruction\n      const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: transferAmount\n      }));\n\n      // Get the latest blockhash\n      const {\n        blockhash\n      } = await this.connection.getLatestBlockhash('finalized');\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('Please connect Phantom or Solflare wallet');\n      }\n      try {\n        var _confirmation$value2;\n        // Sign transaction\n        const signed = await walletAdapter.signTransaction(transaction);\n\n        // Send transaction\n        const signature = await this.connection.sendRawTransaction(signed.serialize(), {\n          skipPreflight: false,\n          preflightCommitment: 'finalized'\n        });\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'finalized');\n        if ((_confirmation$value2 = confirmation.value) !== null && _confirmation$value2 !== void 0 && _confirmation$value2.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        var _signError$message2;\n        console.error('Transaction signing error:', signError);\n        if ((_signError$message2 = signError.message) !== null && _signError$message2 !== void 0 && _signError$message2.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      var _error$message, _error$message2, _error$message3;\n      console.error('SOL transfer error:', error);\n      // Provide more specific error messages\n      if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('insufficient')) {\n        throw new Error('Insufficient balance for transfer and network fees');\n      } else if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('rejected')) {\n        throw new Error('Transaction was rejected by the user');\n      } else if ((_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('blockhash')) {\n        throw new Error('Network error: Please try again');\n      }\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      var _this$tokenInfo$token, _window$solana;\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n\n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(ownerPublicKey, {\n        mint: tokenPublicKey\n      });\n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      const tokenAccount = tokenAccounts.value[0].pubkey;\n\n      // Get token decimals\n      const decimals = ((_this$tokenInfo$token = this.tokenInfo[tokenAddress]) === null || _this$tokenInfo$token === void 0 ? void 0 : _this$tokenInfo$token.decimals) || (await this.getTokenInfo(tokenAddress)).decimals;\n\n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(tokenAccount, tokenPublicKey, ownerPublicKey, amount * Math.pow(10, decimals));\n\n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n\n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n\n      // For Phantom\n      if ((_window$solana = window.solana) !== null && _window$solana !== void 0 && _window$solana.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      } else {\n        throw new Error('No compatible wallet found');\n      }\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\nexport default new TokenService();\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n  const connection = new Connection(clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'), 'confirmed');\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    const transaction = new Transaction().add(SystemProgram.transfer({\n      fromPubkey: wallet.publicKey,\n      toPubkey: burnAddress,\n      lamports: amount * LAMPORTS_PER_SOL\n    }));\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(mint, wallet.publicKey);\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    const burnInstruction = createBurnInstruction(associatedTokenAddress, mint, wallet.publicKey, amount * Math.pow(10, mintInfo.decimals));\n    const transaction = new Transaction().add(burnInstruction);\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n};","map":{"version":3,"names":["WalletService","Connection","PublicKey","Transaction","SystemProgram","LAMPORTS_PER_SOL","createTransferInstruction","TOKEN_PROGRAM_ID","createBurnInstruction","getAssociatedTokenAddress","clusterApiUrl","TokenService","constructor","connection","tokenInfo","initialize","endpoint","getTokenBalance","tokenAddress","walletAddress","Error","tokenPublicKey","walletPublicKey","associatedTokenAddress","accountInfo","getTokenAccountBalance","value","uiAmount","err","error","console","message","transferToken","fromWallet","toAddress","amount","fromPublicKey","toPublicKey","getTokenInfo","decimals","rawAmount","Math","pow","fromTokenAccount","toTokenAccount","transaction","recipientAccount","getAccountInfo","createAccountInstruction","createAssociatedTokenAccountInstruction","add","transferInstruction","recentBlockhash","getRecentBlockhash","blockhash","feePayer","walletAdapter","window","solana","solflare","_confirmation$value","signed","signTransaction","signature","sendRawTransaction","serialize","confirmation","confirmTransaction","JSON","stringify","status","signError","_signError$message","includes","getParsedAccountInfo","data","parsed","mintInfo","info","parsedInfo","address","supply","name","symbol","getAccountTransactions","limit","signatures","getSignaturesForAddress","map","sig","timestamp","blockTime","Date","now","confirmationStatus","type","getTokenTransactions","getNativeBalance","balance","getBalance","transferNativeSOL","transferAmount","estimatedFee","transfer","fromPubkey","toPubkey","lamports","getLatestBlockhash","_confirmation$value2","skipPreflight","preflightCommitment","_signError$message2","_error$message","_error$message2","_error$message3","burnToken","ownerAddress","_this$tokenInfo$token","_window$solana","ownerPublicKey","tokenAccounts","getParsedTokenAccountsByOwner","mint","length","tokenAccount","pubkey","burnInstruction","signedTransaction","isPhantom","burnTokens","wallet","publicKey","process","env","REACT_APP_SOLANA_NETWORK","burnAddress","sendTransaction","getMint"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/token-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction, getAssociatedTokenAddress } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\n\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint || clusterApiUrl('devnet'), 'confirmed');\n  }\n\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        walletPublicKey\n      );\n      \n      try {\n        const accountInfo = await this.connection.getTokenAccountBalance(associatedTokenAddress);\n        return accountInfo.value.uiAmount;\n      } catch (err) {\n        // If account doesn't exist, return 0\n        return 0;\n      }\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw new Error('Failed to get token balance: ' + error.message);\n    }\n  }\n\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const toPublicKey = new PublicKey(toAddress);\n      \n      // Get token decimals\n      const tokenInfo = await this.getTokenInfo(tokenAddress);\n      const decimals = tokenInfo.decimals;\n      \n      // Calculate token amounts with decimals\n      const rawAmount = amount * Math.pow(10, decimals);\n      \n      // Get or create associated token accounts\n      const fromTokenAccount = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        fromPublicKey\n      );\n      \n      const toTokenAccount = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        toPublicKey\n      );\n      \n      // Create transaction\n      const transaction = new Transaction();\n      \n      // Check if recipient token account exists\n      const recipientAccount = await this.connection.getAccountInfo(toTokenAccount);\n      \n      // If recipient account doesn't exist, add create instruction\n      if (!recipientAccount) {\n        const createAccountInstruction = await createAssociatedTokenAccountInstruction(\n          fromPublicKey, // payer\n          toTokenAccount, // associated token account\n          toPublicKey, // owner\n          tokenPublicKey // mint\n        );\n        transaction.add(createAccountInstruction);\n      }\n      \n      // Add transfer instruction\n      const transferInstruction = createTransferInstruction(\n        fromTokenAccount,\n        toTokenAccount,\n        fromPublicKey,\n        rawAmount,\n        [],\n        TOKEN_PROGRAM_ID\n      );\n      \n      transaction.add(transferInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('No compatible wallet found');\n      }\n      \n      // Sign and send transaction\n      try {\n        const signed = await walletAdapter.signTransaction(transaction);\n        const signature = await this.connection.sendRawTransaction(signed.serialize());\n        \n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');\n        \n        if (confirmation.value?.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        \n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        if (signError.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('Token transfer error:', error);\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      \n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      \n      if (!tokenInfo.value || !tokenInfo.value.data.parsed) {\n        throw new Error('Invalid token address');\n      }\n      \n      const mintInfo = tokenInfo.value.data.parsed.info;\n      \n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: mintInfo.decimals,\n        supply: mintInfo.supply,\n        name: mintInfo.name || 'Unknown Token',\n        symbol: mintInfo.symbol || 'UNKNOWN'\n      };\n      \n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      \n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw new Error('Failed to get token info: ' + error.message);\n    }\n  }\n\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(\n        walletPublicKey,\n        { limit }\n      );\n      \n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n\n  async transferNativeSOL(fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Check balance before transfer\n      const balance = await this.connection.getBalance(fromPublicKey);\n      const transferAmount = amount * LAMPORTS_PER_SOL;\n      const estimatedFee = 5000; // Approximate fee in lamports\n      \n      if (balance < transferAmount + estimatedFee) {\n        throw new Error('Insufficient balance for transfer and fees');\n      }\n      \n      // Create a simple transfer instruction\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: fromPublicKey,\n          toPubkey: toPublicKey,\n          lamports: transferAmount\n        })\n      );\n      \n      // Get the latest blockhash\n      const { blockhash } = await this.connection.getLatestBlockhash('finalized');\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('Please connect Phantom or Solflare wallet');\n      }\n      \n      try {\n        // Sign transaction\n        const signed = await walletAdapter.signTransaction(transaction);\n        \n        // Send transaction\n        const signature = await this.connection.sendRawTransaction(signed.serialize(), {\n          skipPreflight: false,\n          preflightCommitment: 'finalized'\n        });\n        \n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'finalized');\n        \n        if (confirmation.value?.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        \n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        console.error('Transaction signing error:', signError);\n        if (signError.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('SOL transfer error:', error);\n      // Provide more specific error messages\n      if (error.message?.includes('insufficient')) {\n        throw new Error('Insufficient balance for transfer and network fees');\n      } else if (error.message?.includes('rejected')) {\n        throw new Error('Transaction was rejected by the user');\n      } else if (error.message?.includes('blockhash')) {\n        throw new Error('Network error: Please try again');\n      }\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n      \n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        ownerPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      \n      const tokenAccount = tokenAccounts.value[0].pubkey;\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(\n        tokenAccount,\n        tokenPublicKey,\n        ownerPublicKey,\n        amount * Math.pow(10, decimals)\n      );\n      \n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new TokenService();\n\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n\n  const connection = new Connection(\n    clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'),\n    'confirmed'\n  );\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    \n    const transaction = new Transaction().add(\n      SystemProgram.transfer({\n        fromPubkey: wallet.publicKey,\n        toPubkey: burnAddress,\n        lamports: amount * LAMPORTS_PER_SOL,\n      })\n    );\n\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(\n      mint,\n      wallet.publicKey\n    );\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    \n    const burnInstruction = createBurnInstruction(\n      associatedTokenAddress,\n      mint,\n      wallet.publicKey,\n      amount * Math.pow(10, mintInfo.decimals)\n    );\n\n    const transaction = new Transaction().add(burnInstruction);\n    \n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}