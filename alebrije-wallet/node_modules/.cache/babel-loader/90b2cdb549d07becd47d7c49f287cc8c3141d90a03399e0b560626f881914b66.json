{"ast":null,"code":"import * as Bytes from '../Bytes.js';\n/** @internal */\nexport function assertSize(bytes, size_) {\n  if (Bytes.size(bytes) > size_) throw new Bytes.SizeOverflowError({\n    givenSize: Bytes.size(bytes),\n    maxSize: size_\n  });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n  if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1) throw new Bytes.SliceOffsetOutOfBoundsError({\n    offset: start,\n    position: 'start',\n    size: Bytes.size(value)\n  });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n  if (typeof start === 'number' && typeof end === 'number' && Bytes.size(value) !== end - start) {\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Bytes.size(value)\n    });\n  }\n}\n/** @internal */\nexport const charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\n/** @internal */\nexport function charCodeToBase16(char) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;\n  if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);\n  if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);\n  return undefined;\n}\n/** @internal */\nexport function pad(bytes) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    dir,\n    size = 32\n  } = options;\n  if (size === 0) return bytes;\n  if (bytes.length > size) throw new Bytes.SizeExceedsPaddingSizeError({\n    size: bytes.length,\n    targetSize: size,\n    type: 'Bytes'\n  });\n  const paddedBytes = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right';\n    paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\n  }\n  return paddedBytes;\n}\n/** @internal */\nexport function trim(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    dir = 'left'\n  } = options;\n  let data = value;\n  let sliceLength = 0;\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;else break;\n  }\n  data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n  return data;\n}","map":{"version":3,"names":["Bytes","assertSize","bytes","size_","size","SizeOverflowError","givenSize","maxSize","assertStartOffset","value","start","SliceOffsetOutOfBoundsError","offset","position","assertEndOffset","end","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","undefined","pad","options","arguments","length","dir","SizeExceedsPaddingSizeError","targetSize","type","paddedBytes","Uint8Array","i","padEnd","trim","data","sliceLength","toString","slice"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/ox/core/internal/bytes.ts"],"sourcesContent":["import * as Bytes from '../Bytes.js'\nimport type * as Errors from '../Errors.js'\n\n/** @internal */\nexport function assertSize(bytes: Bytes.Bytes, size_: number): void {\n  if (Bytes.size(bytes) > size_)\n    throw new Bytes.SizeOverflowError({\n      givenSize: Bytes.size(bytes),\n      maxSize: size_,\n    })\n}\n\n/** @internal */\nexport declare namespace assertSize {\n  type ErrorType =\n    | Bytes.size.ErrorType\n    | Bytes.SizeOverflowError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertStartOffset(\n  value: Bytes.Bytes,\n  start?: number | undefined,\n) {\n  if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: Bytes.size(value),\n    })\n}\n\nexport declare namespace assertStartOffset {\n  export type ErrorType =\n    | Bytes.SliceOffsetOutOfBoundsError\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertEndOffset(\n  value: Bytes.Bytes,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    Bytes.size(value) !== end - start\n  ) {\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Bytes.size(value),\n    })\n  }\n}\n\n/** @internal */\nexport declare namespace assertEndOffset {\n  type ErrorType =\n    | Bytes.SliceOffsetOutOfBoundsError\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport const charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\n/** @internal */\nexport function charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\n/** @internal */\nexport function pad(bytes: Bytes.Bytes, options: pad.Options = {}) {\n  const { dir, size = 32 } = options\n  if (size === 0) return bytes\n  if (bytes.length > size)\n    throw new Bytes.SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'Bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]!\n  }\n  return paddedBytes\n}\n\n/** @internal */\nexport declare namespace pad {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n    size?: number | undefined\n  }\n\n  type ReturnType = Bytes.Bytes\n\n  type ErrorType = Bytes.SizeExceedsPaddingSizeError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function trim(\n  value: Bytes.Bytes,\n  options: trim.Options = {},\n): trim.ReturnType {\n  const { dir = 'left' } = options\n\n  let data = value\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1]!.toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  return data as trim.ReturnType\n}\n\n/** @internal */\nexport declare namespace trim {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n  }\n\n  type ReturnType = Bytes.Bytes\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}