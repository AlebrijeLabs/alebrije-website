{"ast":null,"code":"import * as AbiParameters from '../AbiParameters.js';\nimport * as Address from '../Address.js';\nimport * as Bytes from '../Bytes.js';\nimport * as Errors from '../Errors.js';\nimport * as Hex from '../Hex.js';\nimport { integerRegex } from '../Solidity.js';\n/** @internal */\nexport function decodeParameter(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(cursor, {\n      ...param,\n      type\n    }, {\n      checksumAddress,\n      length,\n      staticPosition\n    });\n  }\n  if (param.type === 'tuple') return decodeTuple(cursor, param, {\n    checksumAddress,\n    staticPosition\n  });\n  if (param.type === 'address') return decodeAddress(cursor, {\n    checksum: checksumAddress\n  });\n  if (param.type === 'bool') return decodeBool(cursor);\n  if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {\n    staticPosition\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);\n  if (param.type === 'string') return decodeString(cursor, {\n    staticPosition\n  });\n  throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nexport function decodeAddress(cursor) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    checksum = false\n  } = options;\n  const value = cursor.readBytes(32);\n  const wrap = address => checksum ? Address.checksum(address) : address;\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\n/** @internal */\nexport function decodeArray(cursor, param, options) {\n  const {\n    checksumAddress,\n    length,\n    staticPosition\n  } = options;\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const startOfData = start + sizeOfLength;\n    // Get the length of the array from the offset.\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData\n      });\n      consumed += consumed_;\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32);\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start\n      });\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed\n    });\n    consumed += consumed_;\n    value.push(data);\n  }\n  return [value, consumed];\n}\n/** @internal */\nexport function decodeBool(cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), {\n    size: 32\n  }), 32];\n}\n/** @internal */\nexport function decodeBytes(cursor, param, _ref) {\n  let {\n    staticPosition\n  } = _ref;\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32);\n      return ['0x', 32];\n    }\n    const data = cursor.readBytes(length);\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [Hex.fromBytes(data), 32];\n  }\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32));\n  return [value, 32];\n}\n/** @internal */\nexport function decodeNumber(cursor, param) {\n  const signed = param.type.startsWith('int');\n  const size = Number.parseInt(param.type.split('int')[1] || '256');\n  const value = cursor.readBytes(32);\n  return [size > 48 ? Bytes.toBigInt(value, {\n    signed\n  }) : Bytes.toNumber(value, {\n    signed\n  }), 32];\n}\n/** @internal */\nexport function decodeTuple(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(_ref2 => {\n    let {\n      name\n    } = _ref2;\n    return !name;\n  });\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset;\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      cursor.setPosition(start + consumed);\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start\n      });\n      consumed += consumed_;\n      value[hasUnnamedChild ? i : component?.name] = data;\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition\n    });\n    value[hasUnnamedChild ? i : component?.name] = data;\n    consumed += consumed_;\n  }\n  return [value, consumed];\n}\n/** @internal */\nexport function decodeString(cursor, _ref3) {\n  let {\n    staticPosition\n  } = _ref3;\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32));\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset;\n  cursor.setPosition(start);\n  const length = Bytes.toNumber(cursor.readBytes(32));\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32);\n    return ['', 32];\n  }\n  const data = cursor.readBytes(length, 32);\n  const value = Bytes.toString(Bytes.trimLeft(data));\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32);\n  return [value, 32];\n}\n/** @internal */\nexport function prepareParameters(_ref4) {\n  let {\n    checksumAddress,\n    parameters,\n    values\n  } = _ref4;\n  const preparedParameters = [];\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(prepareParameter({\n      checksumAddress,\n      parameter: parameters[i],\n      value: values[i]\n    }));\n  }\n  return preparedParameters;\n}\n/** @internal */\nexport function prepareParameter(_ref5) {\n  let {\n    checksumAddress = false,\n    parameter: parameter_,\n    value\n  } = _ref5;\n  const parameter = parameter_;\n  const arrayComponents = getArrayComponents(parameter.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type\n      }\n    });\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value, {\n      checksumAddress,\n      parameter: parameter\n    });\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value, {\n      checksum: checksumAddress\n    });\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value);\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int');\n    const [,, size = '256'] = integerRegex.exec(parameter.type) ?? [];\n    return encodeNumber(value, {\n      signed,\n      size: Number(size)\n    });\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value, {\n      type: parameter.type\n    });\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value);\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type);\n}\n/** @internal */\nexport function encode(preparedParameters) {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) staticSize += 32;else staticSize += Hex.size(encoded);\n  }\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters = [];\n  const dynamicParameters = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) {\n      staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParameters.push(encoded);\n      dynamicSize += Hex.size(encoded);\n    } else {\n      staticParameters.push(encoded);\n    }\n  }\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nexport function encodeAddress(value, options) {\n  const {\n    checksum = false\n  } = options;\n  Address.assert(value, {\n    strict: checksum\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase())\n  };\n}\n/** @internal */\nexport function encodeArray(value, options) {\n  const {\n    checksumAddress,\n    length,\n    parameter\n  } = options;\n  const dynamic = length === null;\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value);\n  if (!dynamic && value.length !== length) throw new AbiParameters.ArrayLengthMismatchError({\n    expectedLength: length,\n    givenLength: value.length,\n    type: `${parameter.type}[${length}]`\n  });\n  let dynamicChild = false;\n  const preparedParameters = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) dynamicChild = true;\n    preparedParameters.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters);\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length\n      };\n    }\n    if (dynamicChild) return {\n      dynamic: true,\n      encoded: data\n    };\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(_ref6 => {\n      let {\n        encoded\n      } = _ref6;\n      return encoded;\n    }))\n  };\n}\n/** @internal */\nexport function encodeBytes(value, _ref7) {\n  let {\n    type\n  } = _ref7;\n  const [, parametersize] = type.split('bytes');\n  const bytesSize = Hex.size(value);\n  if (!parametersize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n    return {\n      dynamic: true,\n      encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, {\n        size: 32\n      })), value_)\n    };\n  }\n  if (bytesSize !== Number.parseInt(parametersize)) throw new AbiParameters.BytesSizeMismatchError({\n    expectedSize: Number.parseInt(parametersize),\n    value\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padRight(value)\n  };\n}\n/** @internal */\nexport function encodeBoolean(value) {\n  if (typeof value !== 'boolean') throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(Hex.fromBoolean(value))\n  };\n}\n/** @internal */\nexport function encodeNumber(value, _ref8) {\n  let {\n    signed,\n    size\n  } = _ref8;\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n    const min = signed ? -max - 1n : 0n;\n    if (value > max || value < min) throw new Hex.IntegerOutOfRangeError({\n      max: max.toString(),\n      min: min.toString(),\n      signed,\n      size: size / 8,\n      value: value.toString()\n    });\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed\n    })\n  };\n}\n/** @internal */\nexport function encodeString(value) {\n  const hexValue = Hex.fromString(value);\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), {\n      size: 32\n    })), ...parts)\n  };\n}\n/** @internal */\nexport function encodeTuple(value, options) {\n  const {\n    checksumAddress,\n    parameter\n  } = options;\n  let dynamic = false;\n  const preparedParameters = [];\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: value[index]\n    });\n    preparedParameters.push(preparedParam);\n    if (preparedParam.dynamic) dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encode(preparedParameters) : Hex.concat(...preparedParameters.map(_ref9 => {\n      let {\n        encoded\n      } = _ref9;\n      return encoded;\n    }))\n  };\n}\n/** @internal */\nexport function getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ?\n  // Return `null` if the array is dynamic.\n  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}\n/** @internal */\nexport function hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["AbiParameters","Address","Bytes","Errors","Hex","integerRegex","decodeParameter","cursor","param","options","checksumAddress","staticPosition","arrayComponents","getArrayComponents","type","length","decodeArray","decodeTuple","decodeAddress","checksum","decodeBool","startsWith","decodeBytes","decodeNumber","decodeString","InvalidTypeError","sizeOfLength","sizeOfOffset","arguments","undefined","value","readBytes","wrap","address","fromBytes","slice","offset","toNumber","start","startOfData","setPosition","dynamicChild","hasDynamicChild","consumed","i","data","consumed_","push","toBoolean","size","_ref","_","split","Number","parseInt","signed","toBigInt","hasUnnamedChild","components","some","_ref2","name","component","_ref3","toString","trimLeft","prepareParameters","_ref4","parameters","values","preparedParameters","prepareParameter","parameter","_ref5","parameter_","encodeArray","encodeTuple","encodeAddress","encodeBoolean","exec","encodeNumber","encodeBytes","encodeString","encode","staticSize","dynamic","encoded","staticParameters","dynamicParameters","dynamicSize","fromNumber","concat","assert","strict","padLeft","toLowerCase","Array","isArray","InvalidArrayError","ArrayLengthMismatchError","expectedLength","givenLength","preparedParam","map","_ref6","_ref7","parametersize","bytesSize","value_","padRight","Math","ceil","BytesSizeMismatchError","expectedSize","BaseError","fromBoolean","_ref8","max","BigInt","min","IntegerOutOfRangeError","hexValue","fromString","partsLength","parts","param_","index","_ref9","matches","match","endsWith"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/ox/core/internal/abiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterKind,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\nimport * as AbiParameters from '../AbiParameters.js'\nimport * as Address from '../Address.js'\nimport * as Bytes from '../Bytes.js'\nimport * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport { integerRegex } from '../Solidity.js'\nimport type * as Cursor from './cursor.js'\nimport type { Compute, IsNarrowable, UnionToIntersection } from './types.js'\n\n/** @internal */\nexport type ParameterToPrimitiveType<\n  abiParameter extends AbiParameter | { name: string; type: unknown },\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParameterToPrimitiveType<abiParameter, abiParameterKind>\n\n/** @internal */\nexport type PreparedParameter = { dynamic: boolean; encoded: Hex.Hex }\n\n/** @internal */\nexport type ToObject<\n  parameters extends readonly AbiParameter[],\n  kind extends AbiParameterKind = AbiParameterKind,\n> = IsNarrowable<parameters, AbiParameters.AbiParameters> extends true\n  ? Compute<\n      UnionToIntersection<\n        {\n          [index in keyof parameters]: parameters[index] extends {\n            name: infer name extends string\n          }\n            ? {\n                [key in name]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n            : {\n                [key in index]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n        }[number]\n      >\n    >\n  : unknown\n\n/** @internal */\nexport type ToPrimitiveTypes<\n  abiParameters extends readonly AbiParameter[],\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParametersToPrimitiveTypes<abiParameters, abiParameterKind>\n\n/** @internal */\nexport type Tuple = ParameterToPrimitiveType<TupleAbiParameter>\n\n/** @internal */\nexport function decodeParameter(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(\n      cursor,\n      { ...param, type },\n      { checksumAddress, length, staticPosition },\n    )\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, {\n      checksumAddress,\n      staticPosition,\n    })\n  if (param.type === 'address')\n    return decodeAddress(cursor, { checksum: checksumAddress })\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new AbiParameters.InvalidTypeError(param.type)\n}\n\nexport declare namespace decodeParameter {\n  type ErrorType =\n    | decodeArray.ErrorType\n    | decodeTuple.ErrorType\n    | decodeAddress.ErrorType\n    | decodeBool.ErrorType\n    | decodeBytes.ErrorType\n    | decodeNumber.ErrorType\n    | decodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\n/** @internal */\nexport function decodeAddress(\n  cursor: Cursor.Cursor,\n  options: { checksum?: boolean | undefined } = {},\n) {\n  const { checksum = false } = options\n  const value = cursor.readBytes(32)\n  const wrap = (address: Hex.Hex) =>\n    checksum ? Address.checksum(address) : address\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32]\n}\n\nexport declare namespace decodeAddress {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeArray(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    staticPosition: number\n  },\n) {\n  const { checksumAddress, length, staticPosition } = options\n\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeArray {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBool(cursor: Cursor.Cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32]\n}\n\nexport declare namespace decodeBool {\n  type ErrorType = Bytes.toBoolean.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBytes(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = Bytes.toNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [Hex.fromBytes(data), 32]\n  }\n\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\nexport declare namespace decodeBytes {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeNumber(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? Bytes.toBigInt(value, { signed })\n      : Bytes.toNumber(value, { signed }),\n    32,\n  ]\n}\n\nexport declare namespace decodeNumber {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport type TupleAbiParameter = AbiParameters.Parameter & {\n  components: readonly AbiParameters.Parameter[]\n}\n\n/** @internal */\nexport function decodeTuple(\n  cursor: Cursor.Cursor,\n  param: TupleAbiParameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]!\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]!\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeTuple {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeString(\n  cursor: Cursor.Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = Bytes.toNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = Bytes.toString(Bytes.trimLeft(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nexport declare namespace decodeString {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toString.ErrorType\n    | Bytes.trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameters<\n  const parameters extends AbiParameters.AbiParameters,\n>({\n  checksumAddress,\n  parameters,\n  values,\n}: {\n  checksumAddress?: boolean | undefined\n  parameters: parameters\n  values: parameters extends AbiParameters.AbiParameters\n    ? ToPrimitiveTypes<parameters>\n    : never\n}) {\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(\n      prepareParameter({\n        checksumAddress,\n        parameter: parameters[i]!,\n        value: values[i],\n      }),\n    )\n  }\n  return preparedParameters\n}\n\n/** @internal */\nexport declare namespace prepareParameters {\n  type ErrorType = prepareParameter.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameter<\n  const parameter extends AbiParameters.Parameter,\n>({\n  checksumAddress = false,\n  parameter: parameter_,\n  value,\n}: {\n  parameter: parameter\n  value: parameter extends AbiParameters.Parameter\n    ? ParameterToPrimitiveType<parameter>\n    : never\n  checksumAddress?: boolean | undefined\n}): PreparedParameter {\n  const parameter = parameter_ as AbiParameters.Parameter\n\n  const arrayComponents = getArrayComponents(parameter.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type,\n      },\n    })\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      checksumAddress,\n      parameter: parameter as TupleAbiParameter,\n    })\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value as unknown as Hex.Hex, {\n      checksum: checksumAddress,\n    })\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value as unknown as boolean)\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(parameter.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex.Hex, { type: parameter.type })\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type)\n}\n\n/** @internal */\nexport declare namespace prepareParameter {\n  type ErrorType =\n    | encodeArray.ErrorType\n    | encodeTuple.ErrorType\n    | encodeAddress.ErrorType\n    | encodeBoolean.ErrorType\n    | encodeBytes.ErrorType\n    | encodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encode(preparedParameters: PreparedParameter[]): Hex.Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) staticSize += 32\n    else staticSize += Hex.size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters: Hex.Hex[] = []\n  const dynamicParameters: Hex.Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) {\n      staticParameters.push(\n        Hex.fromNumber(staticSize + dynamicSize, { size: 32 }),\n      )\n      dynamicParameters.push(encoded)\n      dynamicSize += Hex.size(encoded)\n    } else {\n      staticParameters.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters)\n}\n\n/** @internal */\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeAddress(\n  value: Hex.Hex,\n  options: { checksum: boolean },\n): PreparedParameter {\n  const { checksum = false } = options\n  Address.assert(value, { strict: checksum })\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase() as Hex.Hex),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeAddress {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | Hex.padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeArray<const parameter extends AbiParameters.Parameter>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, length, parameter } = options\n\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiParameters.ArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${parameter.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i],\n    })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParameters.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters)\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded:\n          preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeArray {\n  type ErrorType =\n    | AbiParameters.InvalidArrayError\n    | AbiParameters.ArrayLengthMismatchError\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBytes(\n  value: Hex.Hex,\n  { type }: { type: string },\n): PreparedParameter {\n  const [, parametersize] = type.split('bytes')\n  const bytesSize = Hex.size(value)\n  if (!parametersize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32)\n    return {\n      dynamic: true,\n      encoded: Hex.concat(\n        Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })),\n        value_,\n      ),\n    }\n  }\n  if (bytesSize !== Number.parseInt(parametersize))\n    throw new AbiParameters.BytesSizeMismatchError({\n      expectedSize: Number.parseInt(parametersize),\n      value,\n    })\n  return { dynamic: false, encoded: Hex.padRight(value) }\n}\n\n/** @internal */\nexport declare namespace encodeBytes {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBoolean(value: boolean): PreparedParameter {\n  if (typeof value !== 'boolean')\n    throw new Errors.BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) }\n}\n\n/** @internal */\nexport declare namespace encodeBoolean {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.fromBoolean.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeNumber(\n  value: number,\n  { signed, size }: { signed: boolean; size: number },\n): PreparedParameter {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new Hex.IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeNumber {\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeString(value: string): PreparedParameter {\n  const hexValue = Hex.fromString(value)\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32)\n  const parts: Hex.Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)))\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(\n      Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })),\n      ...parts,\n    ),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeString {\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.slice.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeTuple<\n  const parameter extends AbiParameters.Parameter & {\n    components: readonly AbiParameters.Parameter[]\n  },\n>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, parameter } = options\n\n  let dynamic = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i]!\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParameters.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encode(preparedParameters)\n      : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeTuple {\n  type ErrorType = Hex.concat.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2]! ? Number(matches[2]!) : null, matches[1]!]\n    : undefined\n}\n\n/** @internal */\nexport function hasDynamicChild(param: AbiParameters.Parameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({\n      ...param,\n      type: arrayComponents[1],\n    } as AbiParameters.Parameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}