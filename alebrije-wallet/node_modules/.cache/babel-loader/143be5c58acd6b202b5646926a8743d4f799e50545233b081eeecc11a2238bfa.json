{"ast":null,"code":"import * as Hex from '../Hex.js';\n/** @internal */\nexport function assertSize(hex, size_) {\n  if (Hex.size(hex) > size_) throw new Hex.SizeOverflowError({\n    givenSize: Hex.size(hex),\n    maxSize: size_\n  });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n  if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1) throw new Hex.SliceOffsetOutOfBoundsError({\n    offset: start,\n    position: 'start',\n    size: Hex.size(value)\n  });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n  if (typeof start === 'number' && typeof end === 'number' && Hex.size(value) !== end - start) {\n    throw new Hex.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Hex.size(value)\n    });\n  }\n}\n/** @internal */\nexport function pad(hex_) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    dir,\n    size = 32\n  } = options;\n  if (size === 0) return hex_;\n  const hex = hex_.replace('0x', '');\n  if (hex.length > size * 2) throw new Hex.SizeExceedsPaddingSizeError({\n    size: Math.ceil(hex.length / 2),\n    targetSize: size,\n    type: 'Hex'\n  });\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nexport function trim(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    dir = 'left'\n  } = options;\n  let data = value.replace('0x', '');\n  let sliceLength = 0;\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;else break;\n  }\n  data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n  if (data === '0') return '0x';\n  if (dir === 'right' && data.length % 2 === 1) return `0x${data}0`;\n  return `0x${data}`;\n}","map":{"version":3,"names":["Hex","assertSize","hex","size_","size","SizeOverflowError","givenSize","maxSize","assertStartOffset","value","start","SliceOffsetOutOfBoundsError","offset","position","assertEndOffset","end","pad","hex_","options","arguments","length","undefined","dir","replace","SizeExceedsPaddingSizeError","Math","ceil","targetSize","type","trim","data","sliceLength","i","toString","slice"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/ox/core/internal/hex.ts"],"sourcesContent":["import type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\n\n/** @internal */\nexport function assertSize(hex: Hex.Hex, size_: number): void {\n  if (Hex.size(hex) > size_)\n    throw new Hex.SizeOverflowError({\n      givenSize: Hex.size(hex),\n      maxSize: size_,\n    })\n}\n\n/** @internal */\nexport declare namespace assertSize {\n  type ErrorType =\n    | Hex.size.ErrorType\n    | Hex.SizeOverflowError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertStartOffset(value: Hex.Hex, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1)\n    throw new Hex.SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: Hex.size(value),\n    })\n}\n\nexport declare namespace assertStartOffset {\n  type ErrorType =\n    | Hex.SliceOffsetOutOfBoundsError\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertEndOffset(\n  value: Hex.Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    Hex.size(value) !== end - start\n  ) {\n    throw new Hex.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Hex.size(value),\n    })\n  }\n}\n\nexport declare namespace assertEndOffset {\n  type ErrorType =\n    | Hex.SliceOffsetOutOfBoundsError\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function pad(hex_: Hex.Hex, options: pad.Options = {}) {\n  const { dir, size = 32 } = options\n\n  if (size === 0) return hex_\n\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new Hex.SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'Hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}` as Hex.Hex\n}\n\n/** @internal */\nexport declare namespace pad {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n    size?: number | undefined\n  }\n  type ErrorType = Hex.SizeExceedsPaddingSizeError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function trim(\n  value: Hex.Hex,\n  options: trim.Options = {},\n): trim.ReturnType {\n  const { dir = 'left' } = options\n\n  let data = value.replace('0x', '')\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1]!.toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (data === '0') return '0x'\n  if (dir === 'right' && data.length % 2 === 1) return `0x${data}0`\n  return `0x${data}` as trim.ReturnType\n}\n\n/** @internal */\nexport declare namespace trim {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}