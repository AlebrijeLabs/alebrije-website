{"ast":null,"code":"import { call } from '../actions/public/call.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { localBatchGatewayRequest, localBatchGatewayUrl } from './ens/localBatchGatewayRequest.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [{\n    name: 'sender',\n    type: 'address'\n  }, {\n    name: 'urls',\n    type: 'string[]'\n  }, {\n    name: 'callData',\n    type: 'bytes'\n  }, {\n    name: 'callbackFunction',\n    type: 'bytes4'\n  }, {\n    name: 'extraData',\n    type: 'bytes'\n  }]\n};\nexport async function offchainLookup(client, _ref) {\n  let {\n    blockNumber,\n    blockTag,\n    data,\n    to\n  } = _ref;\n  const {\n    args\n  } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem]\n  });\n  const [sender, urls, callData, callbackSelector, extraData] = args;\n  const {\n    ccipRead\n  } = client;\n  const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function' ? ccipRead.request : ccipRequest;\n  try {\n    if (!isAddressEqual(to, sender)) throw new OffchainLookupSenderMismatchError({\n      sender,\n      to\n    });\n    const result = urls.includes(localBatchGatewayUrl) ? await localBatchGatewayRequest({\n      data: callData,\n      ccipRequest: ccipRequest_\n    }) : await ccipRequest_({\n      data: callData,\n      sender,\n      urls\n    });\n    const {\n      data: data_\n    } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([callbackSelector, encodeAbiParameters([{\n        type: 'bytes'\n      }, {\n        type: 'bytes'\n      }], [result, extraData])]),\n      to\n    });\n    return data_;\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err,\n      data,\n      extraData,\n      sender,\n      urls\n    });\n  }\n}\nexport async function ccipRequest(_ref2) {\n  let {\n    data,\n    sender,\n    urls\n  } = _ref2;\n  let error = new Error('An unknown error occurred.');\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const method = url.includes('{data}') ? 'GET' : 'POST';\n    const body = method === 'POST' ? {\n      data,\n      sender\n    } : undefined;\n    const headers = method === 'POST' ? {\n      'Content-Type': 'application/json'\n    } : {};\n    try {\n      const response = await fetch(url.replace('{sender}', sender.toLowerCase()).replace('{data}', data), {\n        body: JSON.stringify(body),\n        headers,\n        method\n      });\n      let result;\n      if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n        result = (await response.json()).data;\n      } else {\n        result = await response.text();\n      }\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error ? stringify(result.error) : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url\n        });\n        continue;\n      }\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url\n        });\n        continue;\n      }\n      return result;\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: err.message,\n        url\n      });\n    }\n  }\n  throw error;\n}","map":{"version":3,"names":["call","OffchainLookupError","OffchainLookupResponseMalformedError","OffchainLookupSenderMismatchError","HttpRequestError","decodeErrorResult","encodeAbiParameters","isAddressEqual","concat","isHex","localBatchGatewayRequest","localBatchGatewayUrl","stringify","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","offchainLookup","client","_ref","blockNumber","blockTag","data","to","args","abi","sender","urls","callData","callbackSelector","extraData","ccipRead","ccipRequest_","request","ccipRequest","result","includes","data_","err","cause","_ref2","error","Error","i","length","url","method","body","undefined","headers","response","fetch","replace","toLowerCase","JSON","get","startsWith","json","text","ok","details","statusText","status","message"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport {\n  localBatchGatewayRequest,\n  localBatchGatewayUrl,\n} from './ens/localBatchGatewayRequest.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = urls.includes(localBatchGatewayUrl)\n      ? await localBatchGatewayRequest({\n          data: callData,\n          ccipRequest: ccipRequest_,\n        })\n      : await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers: HeadersInit =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender.toLowerCase()).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}