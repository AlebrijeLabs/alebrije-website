{"ast":null,"code":"import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL, sendAndConfirmTransaction, Keypair } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction, getAssociatedTokenAddress } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { Metadata } from '@metaplex-foundation/mpl-token-metadata';\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint || clusterApiUrl('devnet'), 'confirmed');\n  }\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(tokenPublicKey, walletPublicKey);\n      try {\n        const accountInfo = await this.connection.getTokenAccountBalance(associatedTokenAddress);\n        return accountInfo.value.uiAmount;\n      } catch (err) {\n        // If account doesn't exist, return 0\n        return 0;\n      }\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw new Error('Failed to get token balance: ' + error.message);\n    }\n  }\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const toPublicKey = new PublicKey(toAddress);\n\n      // Get token decimals\n      const tokenInfo = await this.getTokenInfo(tokenAddress);\n      const decimals = tokenInfo.decimals;\n\n      // Calculate token amounts with decimals\n      const rawAmount = amount * Math.pow(10, decimals);\n\n      // Get or create associated token accounts\n      const fromTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, fromPublicKey);\n      const toTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, toPublicKey);\n\n      // Create transaction\n      const transaction = new Transaction();\n\n      // Check if recipient token account exists\n      const recipientAccount = await this.connection.getAccountInfo(toTokenAccount);\n\n      // If recipient account doesn't exist, add create instruction\n      if (!recipientAccount) {\n        const createAccountInstruction = await createAssociatedTokenAccountInstruction(fromPublicKey,\n        // payer\n        toTokenAccount,\n        // associated token account\n        toPublicKey,\n        // owner\n        tokenPublicKey // mint\n        );\n        transaction.add(createAccountInstruction);\n      }\n\n      // Add transfer instruction\n      const transferInstruction = createTransferInstruction(fromTokenAccount, toTokenAccount, fromPublicKey, rawAmount, [], TOKEN_PROGRAM_ID);\n      transaction.add(transferInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('No compatible wallet found');\n      }\n\n      // Sign and send transaction\n      try {\n        var _confirmation$value;\n        const signed = await walletAdapter.signTransaction(transaction);\n        const signature = await this.connection.sendRawTransaction(signed.serialize());\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');\n        if ((_confirmation$value = confirmation.value) !== null && _confirmation$value !== void 0 && _confirmation$value.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        var _signError$message;\n        if ((_signError$message = signError.message) !== null && _signError$message !== void 0 && _signError$message.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('Token transfer error:', error);\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) {\n      throw new Error('Token service not initialized');\n    }\n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      const tokenPublicKey = new PublicKey(tokenAddress);\n\n      // Get mint info\n      const mintInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      if (!mintInfo.value || !mintInfo.value.data.parsed) {\n        throw new Error('Invalid token address');\n      }\n      const parsedMintInfo = mintInfo.value.data.parsed.info;\n\n      // For Alebrije token, use predefined metadata\n      if (tokenAddress === 'G8xNrjfTBTMASoUox7TgBn2wq6aGLJ5U78qY5JdEJKhN') {\n        const parsedInfo = {\n          address: tokenAddress,\n          decimals: parsedMintInfo.decimals || 9,\n          supply: parsedMintInfo.supply,\n          name: 'Alebrije Token',\n          symbol: 'ALB',\n          isAlebrije: true\n        };\n\n        // Cache the info\n        this.tokenInfo[tokenAddress] = parsedInfo;\n        console.log('Loaded Alebrije token info:', parsedInfo);\n        return parsedInfo;\n      }\n\n      // For other tokens, use basic info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: parsedMintInfo.decimals,\n        supply: parsedMintInfo.supply,\n        name: 'Unknown Token',\n        symbol: 'UNKNOWN'\n      };\n\n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      console.log('Loaded token info:', parsedInfo);\n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw new Error('Failed to get token info: ' + error.message);\n    }\n  }\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(walletPublicKey, {\n        limit\n      });\n\n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n  async transferNativeSOL(fromWallet, toAddress, amount, walletAdapter) {\n    if (!this.connection) {\n      throw new Error('Connection not initialized');\n    }\n    if (!walletAdapter) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const transferAmount = Math.floor(amount * LAMPORTS_PER_SOL);\n\n      // Check balance\n      const balance = await this.connection.getBalance(fromPublicKey);\n      const minimumBalance = transferAmount + 5000; // Add 5000 lamports for fees\n\n      if (balance < minimumBalance) {\n        throw new Error(`Insufficient balance for transfer and fees. Need ${minimumBalance / LAMPORTS_PER_SOL} SOL but have ${balance / LAMPORTS_PER_SOL} SOL`);\n      }\n\n      // Create instruction\n      const transferInstruction = SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: transferAmount\n      });\n\n      // Get latest blockhash\n      const {\n        blockhash,\n        lastValidBlockHeight\n      } = await this.connection.getLatestBlockhash('confirmed');\n\n      // Create transaction\n      const transaction = new Transaction();\n      transaction.add(transferInstruction);\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n      try {\n        var _confirmation$value2;\n        let signature;\n\n        // Handle transaction differently based on wallet type\n        if (walletAdapter.isSolflare) {\n          // For Solflare, use sendTransaction directly\n          signature = await walletAdapter.sendTransaction(transaction, this.connection);\n        } else {\n          // For other wallets (like Phantom), use sign + send approach\n          const signedTransaction = await walletAdapter.signTransaction(transaction);\n          signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n        }\n        console.log('Transaction sent with signature:', signature);\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction({\n          signature,\n          blockhash,\n          lastValidBlockHeight\n        }, 'confirmed');\n        console.log('Confirmation received:', confirmation);\n        if ((_confirmation$value2 = confirmation.value) !== null && _confirmation$value2 !== void 0 && _confirmation$value2.err) {\n          throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n        }\n\n        // Verify the balance change\n        const newBalance = await this.connection.getBalance(fromPublicKey);\n        const expectedBalance = balance - transferAmount - 5000; // Approximate fee\n\n        if (Math.abs(newBalance - expectedBalance) > 10000) {\n          // Allow for small fee variations\n          console.warn('Balance change verification:', {\n            originalBalance: balance,\n            newBalance,\n            expectedBalance,\n            difference: newBalance - expectedBalance\n          });\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (err) {\n        var _err$message, _err$message2, _err$message3;\n        console.error('Transaction error:', err);\n        if ((_err$message = err.message) !== null && _err$message !== void 0 && _err$message.includes('User rejected')) {\n          throw new Error('Transaction was rejected by user');\n        }\n        if ((_err$message2 = err.message) !== null && _err$message2 !== void 0 && _err$message2.includes('0x1')) {\n          throw new Error('Transaction simulation failed. Please check your balance and try again.');\n        }\n        if ((_err$message3 = err.message) !== null && _err$message3 !== void 0 && _err$message3.includes('blockhash')) {\n          throw new Error('Network error: Please try again (blockhash expired)');\n        }\n\n        // Handle Solflare specific errors\n        if (err.name === 'Ve') {\n          throw new Error('Wallet error: Please try disconnecting and reconnecting your wallet');\n        }\n        throw new Error(`Transaction failed: ${err.message}`);\n      }\n    } catch (error) {\n      console.error('Error transferring SOL:', error);\n      throw error;\n    }\n  }\n  async burnToken(tokenAddress, ownerAddress, amount, walletAdapter) {\n    if (!this.connection) {\n      throw new Error('Connection not initialized');\n    }\n    if (!walletAdapter) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      console.log('Starting token burn:', {\n        tokenAddress,\n        ownerAddress,\n        amount\n      });\n      const mintPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n\n      // Get token mint info first\n      const mintInfo = await this.connection.getParsedAccountInfo(mintPublicKey);\n      if (!mintInfo.value || !mintInfo.value.data.parsed) {\n        throw new Error('Invalid token mint address');\n      }\n      const decimals = mintInfo.value.data.parsed.info.decimals;\n      console.log('Token decimals:', decimals);\n\n      // Get the associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(mintPublicKey, ownerPublicKey);\n      console.log('Associated token account:', associatedTokenAddress.toString());\n\n      // Get token account info\n      const tokenAccountInfo = await this.connection.getParsedAccountInfo(associatedTokenAddress);\n      if (!tokenAccountInfo.value) {\n        throw new Error('Token account not found');\n      }\n\n      // Calculate burn amount with decimals\n      const burnAmount = Math.floor(amount * Math.pow(10, decimals));\n      console.log('Burn amount in raw units:', burnAmount);\n\n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(associatedTokenAddress, mintPublicKey, ownerPublicKey, burnAmount);\n\n      // Create transaction\n      const transaction = new Transaction();\n      transaction.add(burnInstruction);\n\n      // Get latest blockhash\n      const {\n        blockhash,\n        lastValidBlockHeight\n      } = await this.connection.getLatestBlockhash('confirmed');\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = ownerPublicKey;\n      try {\n        var _confirmation$value3;\n        let signature;\n\n        // Handle transaction differently based on wallet type\n        if (walletAdapter.isSolflare) {\n          // For Solflare, use sendTransaction directly\n          signature = await walletAdapter.sendTransaction(transaction, this.connection);\n        } else {\n          // For other wallets (like Phantom), use sign + send approach\n          const signedTransaction = await walletAdapter.signTransaction(transaction);\n          signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n        }\n        console.log('Burn transaction sent:', signature);\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction({\n          signature,\n          blockhash,\n          lastValidBlockHeight\n        }, 'confirmed');\n        console.log('Burn confirmation received:', confirmation);\n        if ((_confirmation$value3 = confirmation.value) !== null && _confirmation$value3 !== void 0 && _confirmation$value3.err) {\n          throw new Error(`Burn failed: ${JSON.stringify(confirmation.value.err)}`);\n        }\n\n        // Verify the burn by checking new balance\n        const newTokenAccount = await this.connection.getParsedAccountInfo(associatedTokenAddress);\n        if (!newTokenAccount.value) {\n          throw new Error('Failed to verify burn: Token account not found');\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (err) {\n        var _err$message4;\n        console.error('Burn transaction error:', err);\n        if ((_err$message4 = err.message) !== null && _err$message4 !== void 0 && _err$message4.includes('User rejected')) {\n          throw new Error('Transaction was rejected by user');\n        }\n        if (err.name === 'Ve') {\n          throw new Error('Wallet error: Please try disconnecting and reconnecting your wallet');\n        }\n        throw err;\n      }\n    } catch (error) {\n      console.error('Error burning tokens:', error);\n      throw error;\n    }\n  }\n}\nexport default new TokenService();\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n  const connection = new Connection(clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'), 'confirmed');\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    const transaction = new Transaction().add(SystemProgram.transfer({\n      fromPubkey: wallet.publicKey,\n      toPubkey: burnAddress,\n      lamports: amount * LAMPORTS_PER_SOL\n    }));\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(mint, wallet.publicKey);\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    const burnInstruction = createBurnInstruction(associatedTokenAddress, mint, wallet.publicKey, amount * Math.pow(10, mintInfo.decimals));\n    const transaction = new Transaction().add(burnInstruction);\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n};","map":{"version":3,"names":["WalletService","Connection","PublicKey","Transaction","SystemProgram","LAMPORTS_PER_SOL","sendAndConfirmTransaction","Keypair","createTransferInstruction","TOKEN_PROGRAM_ID","createBurnInstruction","getAssociatedTokenAddress","clusterApiUrl","Metadata","TokenService","constructor","connection","tokenInfo","initialize","endpoint","getTokenBalance","tokenAddress","walletAddress","Error","tokenPublicKey","walletPublicKey","associatedTokenAddress","accountInfo","getTokenAccountBalance","value","uiAmount","err","error","console","message","transferToken","fromWallet","toAddress","amount","fromPublicKey","toPublicKey","getTokenInfo","decimals","rawAmount","Math","pow","fromTokenAccount","toTokenAccount","transaction","recipientAccount","getAccountInfo","createAccountInstruction","createAssociatedTokenAccountInstruction","add","transferInstruction","recentBlockhash","getRecentBlockhash","blockhash","feePayer","walletAdapter","window","solana","solflare","_confirmation$value","signed","signTransaction","signature","sendRawTransaction","serialize","confirmation","confirmTransaction","JSON","stringify","status","signError","_signError$message","includes","mintInfo","getParsedAccountInfo","data","parsed","parsedMintInfo","info","parsedInfo","address","supply","name","symbol","isAlebrije","log","getAccountTransactions","limit","signatures","getSignaturesForAddress","map","sig","timestamp","blockTime","Date","now","confirmationStatus","type","getTokenTransactions","getNativeBalance","balance","getBalance","transferNativeSOL","transferAmount","floor","minimumBalance","transfer","fromPubkey","toPubkey","lamports","lastValidBlockHeight","getLatestBlockhash","_confirmation$value2","isSolflare","sendTransaction","signedTransaction","newBalance","expectedBalance","abs","warn","originalBalance","difference","_err$message","_err$message2","_err$message3","burnToken","ownerAddress","mintPublicKey","ownerPublicKey","toString","tokenAccountInfo","burnAmount","burnInstruction","_confirmation$value3","newTokenAccount","_err$message4","burnTokens","wallet","publicKey","process","env","REACT_APP_SOLANA_NETWORK","burnAddress","mint","getMint"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/token-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL, sendAndConfirmTransaction, Keypair } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction, getAssociatedTokenAddress } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { Metadata } from '@metaplex-foundation/mpl-token-metadata';\n\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint || clusterApiUrl('devnet'), 'confirmed');\n  }\n\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        walletPublicKey\n      );\n      \n      try {\n        const accountInfo = await this.connection.getTokenAccountBalance(associatedTokenAddress);\n        return accountInfo.value.uiAmount;\n      } catch (err) {\n        // If account doesn't exist, return 0\n        return 0;\n      }\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw new Error('Failed to get token balance: ' + error.message);\n    }\n  }\n\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const toPublicKey = new PublicKey(toAddress);\n      \n      // Get token decimals\n      const tokenInfo = await this.getTokenInfo(tokenAddress);\n      const decimals = tokenInfo.decimals;\n      \n      // Calculate token amounts with decimals\n      const rawAmount = amount * Math.pow(10, decimals);\n      \n      // Get or create associated token accounts\n      const fromTokenAccount = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        fromPublicKey\n      );\n      \n      const toTokenAccount = await getAssociatedTokenAddress(\n        tokenPublicKey,\n        toPublicKey\n      );\n      \n      // Create transaction\n      const transaction = new Transaction();\n      \n      // Check if recipient token account exists\n      const recipientAccount = await this.connection.getAccountInfo(toTokenAccount);\n      \n      // If recipient account doesn't exist, add create instruction\n      if (!recipientAccount) {\n        const createAccountInstruction = await createAssociatedTokenAccountInstruction(\n          fromPublicKey, // payer\n          toTokenAccount, // associated token account\n          toPublicKey, // owner\n          tokenPublicKey // mint\n        );\n        transaction.add(createAccountInstruction);\n      }\n      \n      // Add transfer instruction\n      const transferInstruction = createTransferInstruction(\n        fromTokenAccount,\n        toTokenAccount,\n        fromPublicKey,\n        rawAmount,\n        [],\n        TOKEN_PROGRAM_ID\n      );\n      \n      transaction.add(transferInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('No compatible wallet found');\n      }\n      \n      // Sign and send transaction\n      try {\n        const signed = await walletAdapter.signTransaction(transaction);\n        const signature = await this.connection.sendRawTransaction(signed.serialize());\n        \n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');\n        \n        if (confirmation.value?.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        \n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        if (signError.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('Token transfer error:', error);\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) {\n      throw new Error('Token service not initialized');\n    }\n    \n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      \n      const tokenPublicKey = new PublicKey(tokenAddress);\n      \n      // Get mint info\n      const mintInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      \n      if (!mintInfo.value || !mintInfo.value.data.parsed) {\n        throw new Error('Invalid token address');\n      }\n      \n      const parsedMintInfo = mintInfo.value.data.parsed.info;\n\n      // For Alebrije token, use predefined metadata\n      if (tokenAddress === 'G8xNrjfTBTMASoUox7TgBn2wq6aGLJ5U78qY5JdEJKhN') {\n        const parsedInfo = {\n          address: tokenAddress,\n          decimals: parsedMintInfo.decimals || 9,\n          supply: parsedMintInfo.supply,\n          name: 'Alebrije Token',\n          symbol: 'ALB',\n          isAlebrije: true\n        };\n        \n        // Cache the info\n        this.tokenInfo[tokenAddress] = parsedInfo;\n        \n        console.log('Loaded Alebrije token info:', parsedInfo);\n        return parsedInfo;\n      }\n      \n      // For other tokens, use basic info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: parsedMintInfo.decimals,\n        supply: parsedMintInfo.supply,\n        name: 'Unknown Token',\n        symbol: 'UNKNOWN'\n      };\n      \n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      \n      console.log('Loaded token info:', parsedInfo);\n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw new Error('Failed to get token info: ' + error.message);\n    }\n  }\n\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(\n        walletPublicKey,\n        { limit }\n      );\n      \n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n\n  async transferNativeSOL(fromWallet, toAddress, amount, walletAdapter) {\n    if (!this.connection) {\n      throw new Error('Connection not initialized');\n    }\n    \n    if (!walletAdapter) {\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      const transferAmount = Math.floor(amount * LAMPORTS_PER_SOL);\n\n      // Check balance\n      const balance = await this.connection.getBalance(fromPublicKey);\n      const minimumBalance = transferAmount + 5000; // Add 5000 lamports for fees\n      \n      if (balance < minimumBalance) {\n        throw new Error(`Insufficient balance for transfer and fees. Need ${minimumBalance / LAMPORTS_PER_SOL} SOL but have ${balance / LAMPORTS_PER_SOL} SOL`);\n      }\n\n      // Create instruction\n      const transferInstruction = SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: transferAmount,\n      });\n\n      // Get latest blockhash\n      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');\n\n      // Create transaction\n      const transaction = new Transaction();\n      transaction.add(transferInstruction);\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      try {\n        let signature;\n\n        // Handle transaction differently based on wallet type\n        if (walletAdapter.isSolflare) {\n          // For Solflare, use sendTransaction directly\n          signature = await walletAdapter.sendTransaction(transaction, this.connection);\n        } else {\n          // For other wallets (like Phantom), use sign + send approach\n          const signedTransaction = await walletAdapter.signTransaction(transaction);\n          signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n        }\n\n        console.log('Transaction sent with signature:', signature);\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction({\n          signature,\n          blockhash,\n          lastValidBlockHeight\n        }, 'confirmed');\n\n        console.log('Confirmation received:', confirmation);\n\n        if (confirmation.value?.err) {\n          throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n        }\n\n        // Verify the balance change\n        const newBalance = await this.connection.getBalance(fromPublicKey);\n        const expectedBalance = balance - transferAmount - 5000; // Approximate fee\n        \n        if (Math.abs(newBalance - expectedBalance) > 10000) { // Allow for small fee variations\n          console.warn('Balance change verification:', {\n            originalBalance: balance,\n            newBalance,\n            expectedBalance,\n            difference: newBalance - expectedBalance\n          });\n        }\n\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (err) {\n        console.error('Transaction error:', err);\n        \n        if (err.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by user');\n        }\n        \n        if (err.message?.includes('0x1')) {\n          throw new Error('Transaction simulation failed. Please check your balance and try again.');\n        }\n        \n        if (err.message?.includes('blockhash')) {\n          throw new Error('Network error: Please try again (blockhash expired)');\n        }\n        \n        // Handle Solflare specific errors\n        if (err.name === 'Ve') {\n          throw new Error('Wallet error: Please try disconnecting and reconnecting your wallet');\n        }\n        \n        throw new Error(`Transaction failed: ${err.message}`);\n      }\n    } catch (error) {\n      console.error('Error transferring SOL:', error);\n      throw error;\n    }\n  }\n\n  async burnToken(tokenAddress, ownerAddress, amount, walletAdapter) {\n    if (!this.connection) {\n      throw new Error('Connection not initialized');\n    }\n\n    if (!walletAdapter) {\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      console.log('Starting token burn:', {\n        tokenAddress,\n        ownerAddress,\n        amount\n      });\n\n      const mintPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n\n      // Get token mint info first\n      const mintInfo = await this.connection.getParsedAccountInfo(mintPublicKey);\n      if (!mintInfo.value || !mintInfo.value.data.parsed) {\n        throw new Error('Invalid token mint address');\n      }\n\n      const decimals = mintInfo.value.data.parsed.info.decimals;\n      console.log('Token decimals:', decimals);\n\n      // Get the associated token account\n      const associatedTokenAddress = await getAssociatedTokenAddress(\n        mintPublicKey,\n        ownerPublicKey\n      );\n\n      console.log('Associated token account:', associatedTokenAddress.toString());\n\n      // Get token account info\n      const tokenAccountInfo = await this.connection.getParsedAccountInfo(associatedTokenAddress);\n      if (!tokenAccountInfo.value) {\n        throw new Error('Token account not found');\n      }\n\n      // Calculate burn amount with decimals\n      const burnAmount = Math.floor(amount * Math.pow(10, decimals));\n      console.log('Burn amount in raw units:', burnAmount);\n\n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(\n        associatedTokenAddress,\n        mintPublicKey,\n        ownerPublicKey,\n        burnAmount\n      );\n\n      // Create transaction\n      const transaction = new Transaction();\n      transaction.add(burnInstruction);\n\n      // Get latest blockhash\n      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = ownerPublicKey;\n\n      try {\n        let signature;\n\n        // Handle transaction differently based on wallet type\n        if (walletAdapter.isSolflare) {\n          // For Solflare, use sendTransaction directly\n          signature = await walletAdapter.sendTransaction(transaction, this.connection);\n        } else {\n          // For other wallets (like Phantom), use sign + send approach\n          const signedTransaction = await walletAdapter.signTransaction(transaction);\n          signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n        }\n\n        console.log('Burn transaction sent:', signature);\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction({\n          signature,\n          blockhash,\n          lastValidBlockHeight\n        }, 'confirmed');\n\n        console.log('Burn confirmation received:', confirmation);\n\n        if (confirmation.value?.err) {\n          throw new Error(`Burn failed: ${JSON.stringify(confirmation.value.err)}`);\n        }\n\n        // Verify the burn by checking new balance\n        const newTokenAccount = await this.connection.getParsedAccountInfo(associatedTokenAddress);\n        if (!newTokenAccount.value) {\n          throw new Error('Failed to verify burn: Token account not found');\n        }\n\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (err) {\n        console.error('Burn transaction error:', err);\n        \n        if (err.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by user');\n        }\n        \n        if (err.name === 'Ve') {\n          throw new Error('Wallet error: Please try disconnecting and reconnecting your wallet');\n        }\n        \n        throw err;\n      }\n    } catch (error) {\n      console.error('Error burning tokens:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new TokenService();\n\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n\n  const connection = new Connection(\n    clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'),\n    'confirmed'\n  );\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    \n    const transaction = new Transaction().add(\n      SystemProgram.transfer({\n        fromPubkey: wallet.publicKey,\n        toPubkey: burnAddress,\n        lamports: amount * LAMPORTS_PER_SOL,\n      })\n    );\n\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(\n      mint,\n      wallet.publicKey\n    );\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    \n    const burnInstruction = createBurnInstruction(\n      associatedTokenAddress,\n      mint,\n      wallet.publicKey,\n      amount * Math.pow(10, mintInfo.decimals)\n    );\n\n    const transaction = new Transaction().add(burnInstruction);\n    \n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}