{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES } from '@solana/errors';\n\n// src/add-codec-sentinel.ts\n\n// src/bytes.ts\nvar mergeBytes = byteArrays => {\n  const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n  if (nonEmptyByteArrays.length === 0) {\n    return byteArrays.length ? byteArrays[0] : new Uint8Array();\n  }\n  if (nonEmptyByteArrays.length === 1) {\n    return nonEmptyByteArrays[0];\n  }\n  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  nonEmptyByteArrays.forEach(arr => {\n    result.set(arr, offset);\n    offset += arr.length;\n  });\n  return result;\n};\nvar padBytes = (bytes, length) => {\n  if (bytes.length >= length) return bytes;\n  const paddedBytes = new Uint8Array(length).fill(0);\n  paddedBytes.set(bytes);\n  return paddedBytes;\n};\nvar fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n  const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n  if (slice.length !== bytes.length) return false;\n  return bytes.every((b, i) => b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n  return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n  return Object.freeze({\n    ...encoder,\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, encoder));\n      encoder.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction createDecoder(decoder) {\n  return Object.freeze({\n    ...decoder,\n    decode: function (bytes) {\n      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return decoder.read(bytes, offset)[0];\n    }\n  });\n}\nfunction createCodec(codec) {\n  return Object.freeze({\n    ...codec,\n    decode: function (bytes) {\n      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return codec.read(bytes, offset)[0];\n    },\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, codec));\n      codec.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction isFixedSize(codec) {\n  return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n  if (!isFixedSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n  }\n}\nfunction isVariableSize(codec) {\n  return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n  if (!isVariableSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n  }\n}\nfunction combineCodec(encoder, decoder) {\n  if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n  }\n  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n      decoderFixedSize: decoder.fixedSize,\n      encoderFixedSize: encoder.fixedSize\n    });\n  }\n  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n      decoderMaxSize: decoder.maxSize,\n      encoderMaxSize: encoder.maxSize\n    });\n  }\n  return {\n    ...decoder,\n    ...encoder,\n    decode: decoder.decode,\n    encode: encoder.encode,\n    read: decoder.read,\n    write: encoder.write\n  };\n}\n\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n        encodedBytes: encoderBytes,\n        hexEncodedBytes: hexBytes(encoderBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    bytes.set(encoderBytes, offset);\n    offset += encoderBytes.length;\n    bytes.set(sentinel, offset);\n    offset += sentinel.length;\n    return offset;\n  };\n  if (isFixedSize(encoder)) {\n    return createEncoder({\n      ...encoder,\n      fixedSize: encoder.fixedSize + sentinel.length,\n      write\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    ...(encoder.maxSize != null ? {\n      maxSize: encoder.maxSize + sentinel.length\n    } : {}),\n    getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n    write\n  });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n  const read = (bytes, offset) => {\n    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n    if (sentinelIndex === -1) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n        decodedBytes: candidateBytes,\n        hexDecodedBytes: hexBytes(candidateBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n  };\n  if (isFixedSize(decoder)) {\n    return createDecoder({\n      ...decoder,\n      fixedSize: decoder.fixedSize + sentinel.length,\n      read\n    });\n  }\n  return createDecoder({\n    ...decoder,\n    ...(decoder.maxSize != null ? {\n      maxSize: decoder.maxSize + sentinel.length\n    } : {}),\n    read\n  });\n}\nfunction addCodecSentinel(codec, sentinel) {\n  return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n  return bytes.findIndex((byte, index, arr) => {\n    if (sentinel.length === 1) return byte === sentinel[0];\n    return containsBytes(arr, sentinel, index);\n  });\n}\nfunction hexBytes(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes) {\n  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (bytes.length - offset <= 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n      codecDescription\n    });\n  }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes) {\n  let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  const bytesLength = bytes.length - offset;\n  if (bytesLength < expected) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n      bytesLength,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n  if (offset < 0 || offset > bytesLength) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n      bytesLength,\n      codecDescription,\n      offset\n    });\n  }\n}\n\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    offset = prefix.write(encoderBytes.length, bytes, offset);\n    bytes.set(encoderBytes, offset);\n    return offset + encoderBytes.length;\n  };\n  if (isFixedSize(prefix) && isFixedSize(encoder)) {\n    return createEncoder({\n      ...encoder,\n      fixedSize: prefix.fixedSize + encoder.fixedSize,\n      write\n    });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n  return createEncoder({\n    ...encoder,\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    getSizeFromValue: value => {\n      const encoderSize = getEncodedSize(value, encoder);\n      return getEncodedSize(encoderSize, prefix) + encoderSize;\n    },\n    write\n  });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n  const read = (bytes, offset) => {\n    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n    const size = Number(bigintSize);\n    offset = decoderOffset;\n    if (offset > 0 || bytes.length > size) {\n      bytes = bytes.slice(offset, offset + size);\n    }\n    assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n    return [decoder.decode(bytes), offset + size];\n  };\n  if (isFixedSize(prefix) && isFixedSize(decoder)) {\n    return createDecoder({\n      ...decoder,\n      fixedSize: prefix.fixedSize + decoder.fixedSize,\n      read\n    });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n  return createDecoder({\n    ...decoder,\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    read\n  });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n  return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n  return createEncoder({\n    fixedSize: fixedBytes,\n    write: (value, bytes, offset) => {\n      const variableByteArray = encoder.encode(value);\n      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n      bytes.set(fixedByteArray, offset);\n      return offset + fixedBytes;\n    }\n  });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n  return createDecoder({\n    fixedSize: fixedBytes,\n    read: (bytes, offset) => {\n      assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n      if (offset > 0 || bytes.length > fixedBytes) {\n        bytes = bytes.slice(offset, offset + fixedBytes);\n      }\n      if (isFixedSize(decoder)) {\n        bytes = fixBytes(bytes, decoder.fixedSize);\n      }\n      const [value] = decoder.read(bytes, 0);\n      return [value, offset + fixedBytes];\n    }\n  });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n  return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n      const postOffset = encoder.write(value, bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n      return newPostOffset;\n    }\n  });\n}\nfunction offsetDecoder(decoder, config) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n      const [value, postOffset] = decoder.read(bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n      return [value, newPostOffset];\n    }\n  });\n}\nfunction offsetCodec(codec, config) {\n  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n  if (divisor === 0) return 0;\n  return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n  if (isFixedSize(encoder)) {\n    const fixedSize = resize(encoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeEncoder\"\n      });\n    }\n    return createEncoder({\n      ...encoder,\n      fixedSize\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    getSizeFromValue: value => {\n      const newSize = resize(encoder.getSizeFromValue(value));\n      if (newSize < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n          bytesLength: newSize,\n          codecDescription: \"resizeEncoder\"\n        });\n      }\n      return newSize;\n    }\n  });\n}\nfunction resizeDecoder(decoder, resize) {\n  if (isFixedSize(decoder)) {\n    const fixedSize = resize(decoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeDecoder\"\n      });\n    }\n    return createDecoder({\n      ...decoder,\n      fixedSize\n    });\n  }\n  return decoder;\n}\nfunction resizeCodec(codec, resize) {\n  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    preOffset: _ref => {\n      let {\n        preOffset\n      } = _ref;\n      return preOffset + offset;\n    }\n  });\n}\nfunction padRightEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    postOffset: _ref2 => {\n      let {\n        postOffset\n      } = _ref2;\n      return postOffset + offset;\n    }\n  });\n}\nfunction padLeftDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    preOffset: _ref3 => {\n      let {\n        preOffset\n      } = _ref3;\n      return preOffset + offset;\n    }\n  });\n}\nfunction padRightDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    postOffset: _ref4 => {\n      let {\n        postOffset\n      } = _ref4;\n      return postOffset + offset;\n    }\n  });\n}\nfunction padLeftCodec(codec, offset) {\n  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength) {\n  let targetOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  while (sourceOffset < --sourceLength) {\n    const leftValue = source[sourceOffset];\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n    sourceOffset++;\n  }\n  if (sourceOffset === sourceLength) {\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n  }\n}\nfunction reverseEncoder(encoder) {\n  assertIsFixedSize(encoder);\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, offset) => {\n      const newOffset = encoder.write(value, bytes, offset);\n      copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n      return newOffset;\n    }\n  });\n}\nfunction reverseDecoder(decoder) {\n  assertIsFixedSize(decoder);\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const reversedBytes = bytes.slice();\n      copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n      return decoder.read(reversedBytes, offset);\n    }\n  });\n}\nfunction reverseCodec(codec) {\n  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n  return createEncoder({\n    ...(isVariableSize(encoder) ? {\n      ...encoder,\n      getSizeFromValue: value => encoder.getSizeFromValue(unmap(value))\n    } : encoder),\n    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)\n  });\n}\nfunction transformDecoder(decoder, map) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      return [map(value, bytes, offset), newOffset];\n    }\n  });\n}\nfunction transformCodec(codec, unmap, map) {\n  return createCodec({\n    ...transformEncoder(codec, unmap),\n    read: map ? transformDecoder(codec, map).read : codec.read\n  });\n}\nexport { addCodecSentinel, addCodecSizePrefix, addDecoderSentinel, addDecoderSizePrefix, addEncoderSentinel, addEncoderSizePrefix, assertByteArrayHasEnoughBytesForCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayOffsetIsNotOutOfRange, assertIsFixedSize, assertIsVariableSize, combineCodec, containsBytes, createCodec, createDecoder, createEncoder, fixBytes, fixCodecSize, fixDecoderSize, fixEncoderSize, getEncodedSize, isFixedSize, isVariableSize, mergeBytes, offsetCodec, offsetDecoder, offsetEncoder, padBytes, padLeftCodec, padLeftDecoder, padLeftEncoder, padRightCodec, padRightDecoder, padRightEncoder, resizeCodec, resizeDecoder, resizeEncoder, reverseCodec, reverseDecoder, reverseEncoder, transformCodec, transformDecoder, transformEncoder };\n\n//# sourceMappingURL=index.browser.mjs.map","map":{"version":3,"names":["mergeBytes","byteArrays","nonEmptyByteArrays","filter","arr","length","Uint8Array","totalLength","reduce","total","result","offset","forEach","set","padBytes","bytes","paddedBytes","fill","fixBytes","slice","containsBytes","data","every","b","i","getEncodedSize","value","encoder","fixedSize","getSizeFromValue","createEncoder","Object","freeze","encode","write","createDecoder","decoder","decode","arguments","undefined","read","createCodec","codec","isFixedSize","assertIsFixedSize","SolanaError","SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH","isVariableSize","assertIsVariableSize","SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH","combineCodec","SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH","SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH","decoderFixedSize","encoderFixedSize","maxSize","SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH","decoderMaxSize","encoderMaxSize","addEncoderSentinel","sentinel","encoderBytes","findSentinelIndex","SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL","encodedBytes","hexEncodedBytes","hexBytes","hexSentinel","addDecoderSentinel","candidateBytes","sentinelIndex","SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES","decodedBytes","hexDecodedBytes","preSentinelBytes","addCodecSentinel","findIndex","byte","index","str","toString","padStart","assertByteArrayIsNotEmptyForCodec","codecDescription","SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY","assertByteArrayHasEnoughBytesForCodec","expected","bytesLength","SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH","assertByteArrayOffsetIsNotOutOfRange","SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE","addEncoderSizePrefix","prefix","prefixMaxSize","encoderSize","addDecoderSizePrefix","bigintSize","decoderOffset","size","Number","addCodecSizePrefix","fixEncoderSize","fixedBytes","variableByteArray","fixedByteArray","fixDecoderSize","fixCodecSize","offsetEncoder","config","preOffset","wrapBytes","modulo","newPreOffset","postOffset","newPostOffset","offsetDecoder","offsetCodec","dividend","divisor","resizeEncoder","resize","SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH","newSize","resizeDecoder","resizeCodec","padLeftEncoder","_ref","padRightEncoder","_ref2","padLeftDecoder","_ref3","padRightDecoder","_ref4","padLeftCodec","padRightCodec","copySourceToTargetInReverse","source","target_WILL_MUTATE","sourceOffset","sourceLength","targetOffset","leftValue","reverseEncoder","newOffset","reverseDecoder","reversedBytes","reverseCodec","transformEncoder","unmap","transformDecoder","map","transformCodec"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/bytes.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/codec.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/combine-codec.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/add-codec-sentinel.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/assertions.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/add-codec-size-prefix.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/fix-codec-size.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/offset-codec.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/resize-codec.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/pad-codec.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/reverse-codec.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-core/src/transform-codec.ts"],"sourcesContent":["import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * Note that, if the sentinel is found in the encoded value, an error is thrown.\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until a `Uint8Array` sentinel is found.\n *\n * If the sentinel is not found in the byte array to decode, an error is thrown.\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * Note that, if the sentinel is found in the encoded value\n * or not found in the byte array to decode, an error is thrown.\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the `decoder` by reading the `prefix` encoder prefix.\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Bounds the size of the `codec` using the provided `prefix` codec prefix.\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder.\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder.\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec.\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n */\n\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder.\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder.\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder.\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder.\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec.\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec.\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}