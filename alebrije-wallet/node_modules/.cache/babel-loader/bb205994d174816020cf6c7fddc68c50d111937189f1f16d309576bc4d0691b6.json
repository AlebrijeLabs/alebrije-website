{"ast":null,"code":"import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { getAssociatedTokenAddress, getMint } from '@solana/spl-token';\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint, 'confirmed');\n  }\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get token account info\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(walletPublicKey, {\n        mint: tokenPublicKey\n      });\n\n      // If no token accounts found, balance is 0\n      if (tokenAccounts.value.length === 0) return 0;\n\n      // Get balance from the first token account\n      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;\n      return balance;\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw error;\n    }\n  }\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      var _this$tokenInfo$token, _window$solana;\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n\n      // Calculate tax amounts (5% total)\n      const liquidityTax = amount * 0.03; // 3% for liquidity\n      const marketingTax = amount * 0.01; // 1% for marketing\n      const charityTax = amount * 0.01; // 1% for charity\n      const burnTax = amount * 0.01; // 1% for burn\n\n      // Calculate amount after tax\n      const amountAfterTax = amount - (liquidityTax + marketingTax + charityTax + burnTax);\n\n      // Get token decimals\n      const decimals = ((_this$tokenInfo$token = this.tokenInfo[tokenAddress]) === null || _this$tokenInfo$token === void 0 ? void 0 : _this$tokenInfo$token.decimals) || (await this.getTokenInfo(tokenAddress)).decimals;\n\n      // Create transaction\n      const transaction = new Transaction();\n\n      // Get the token account of the fromWallet address for the token\n      const fromTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(fromPublicKey, {\n        mint: tokenPublicKey\n      });\n\n      // If no token account found, throw error\n      if (fromTokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the sender');\n      }\n      const fromTokenAccount = fromTokenAccounts.value[0].pubkey;\n\n      // Get or create associated token account for recipient\n      let toTokenAccount;\n      try {\n        const toTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(toPublicKey, {\n          mint: tokenPublicKey\n        });\n        if (toTokenAccounts.value.length > 0) {\n          toTokenAccount = toTokenAccounts.value[0].pubkey;\n        } else {\n          // In a real implementation, you would create an associated token account\n          // This is simplified for the example\n          throw new Error('Recipient does not have a token account for this token');\n        }\n      } catch (error) {\n        throw new Error('Error checking recipient token account: ' + error.message);\n      }\n\n      // Create transfer instruction\n      const transferInstruction = createTransferInstruction(fromTokenAccount, toTokenAccount, fromPublicKey, Number(Math.floor(amountAfterTax * Math.pow(10, decimals))), [], TOKEN_PROGRAM_ID);\n\n      // Add transfer instruction to transaction\n      transaction.add(transferInstruction);\n\n      // Add burn instruction for the burn tax\n      if (burnTax > 0) {\n        // Create burn instruction\n        const burnInstruction = createBurnInstruction(fromTokenAccount, tokenPublicKey, fromPublicKey, Number(Math.floor(burnTax * Math.pow(10, decimals))));\n\n        // Add burn instruction to transaction\n        transaction.add(burnInstruction);\n      }\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n\n      // For Phantom\n      if ((_window$solana = window.solana) !== null && _window$solana !== void 0 && _window$solana.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      } else {\n        throw new Error('No compatible wallet found');\n      }\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      return {\n        signature,\n        status: 'confirmed',\n        amountBurned: burnTax\n      };\n    } catch (error) {\n      console.error('Error transferring token:', error);\n      throw error;\n    }\n  }\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      if (!tokenInfo.value) {\n        throw new Error('Token not found');\n      }\n\n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: tokenInfo.value.data.parsed.info.decimals,\n        supply: tokenInfo.value.data.parsed.info.supply,\n        name: tokenInfo.value.data.parsed.info.name || 'Unknown Token',\n        symbol: tokenInfo.value.data.parsed.info.symbol || 'UNKNOWN'\n      };\n\n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw error;\n    }\n  }\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(walletPublicKey, {\n        limit\n      });\n\n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n  async transferNativeSOL(fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n\n      // Check balance before transfer\n      const balance = await this.connection.getBalance(fromPublicKey);\n      const transferAmount = amount * LAMPORTS_PER_SOL;\n      const estimatedFee = 5000; // Approximate fee in lamports\n\n      if (balance < transferAmount + estimatedFee) {\n        throw new Error('Insufficient balance for transfer and fees');\n      }\n\n      // Create a simple transfer instruction\n      const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: transferAmount\n      }));\n\n      // Get the latest blockhash\n      const {\n        blockhash\n      } = await this.connection.getLatestBlockhash('finalized');\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('Please connect Phantom or Solflare wallet');\n      }\n      try {\n        var _confirmation$value;\n        // Sign transaction\n        const signed = await walletAdapter.signTransaction(transaction);\n\n        // Send transaction\n        const signature = await this.connection.sendRawTransaction(signed.serialize(), {\n          skipPreflight: false,\n          preflightCommitment: 'finalized'\n        });\n\n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'finalized');\n        if ((_confirmation$value = confirmation.value) !== null && _confirmation$value !== void 0 && _confirmation$value.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        var _signError$message;\n        console.error('Transaction signing error:', signError);\n        if ((_signError$message = signError.message) !== null && _signError$message !== void 0 && _signError$message.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      var _error$message, _error$message2, _error$message3;\n      console.error('SOL transfer error:', error);\n      // Provide more specific error messages\n      if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('insufficient')) {\n        throw new Error('Insufficient balance for transfer and network fees');\n      } else if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('rejected')) {\n        throw new Error('Transaction was rejected by the user');\n      } else if ((_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('blockhash')) {\n        throw new Error('Network error: Please try again');\n      }\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      var _this$tokenInfo$token2, _window$solana2;\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n\n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(ownerPublicKey, {\n        mint: tokenPublicKey\n      });\n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      const tokenAccount = tokenAccounts.value[0].pubkey;\n\n      // Get token decimals\n      const decimals = ((_this$tokenInfo$token2 = this.tokenInfo[tokenAddress]) === null || _this$tokenInfo$token2 === void 0 ? void 0 : _this$tokenInfo$token2.decimals) || (await this.getTokenInfo(tokenAddress)).decimals;\n\n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(tokenAccount, tokenPublicKey, ownerPublicKey, amount * Math.pow(10, decimals));\n\n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n\n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n\n      // For Phantom\n      if ((_window$solana2 = window.solana) !== null && _window$solana2 !== void 0 && _window$solana2.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      } else {\n        throw new Error('No compatible wallet found');\n      }\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\nexport default new TokenService();\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n  const connection = new Connection(clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'), 'confirmed');\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    const transaction = new Transaction().add(SystemProgram.transfer({\n      fromPubkey: wallet.publicKey,\n      toPubkey: burnAddress,\n      lamports: amount * LAMPORTS_PER_SOL\n    }));\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(mint, wallet.publicKey);\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    const burnInstruction = createBurnInstruction(associatedTokenAddress, mint, wallet.publicKey, amount * Math.pow(10, mintInfo.decimals));\n    const transaction = new Transaction().add(burnInstruction);\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n};","map":{"version":3,"names":["WalletService","Connection","PublicKey","Transaction","SystemProgram","LAMPORTS_PER_SOL","createTransferInstruction","TOKEN_PROGRAM_ID","createBurnInstruction","clusterApiUrl","getAssociatedTokenAddress","getMint","TokenService","constructor","connection","tokenInfo","initialize","endpoint","getTokenBalance","tokenAddress","walletAddress","Error","tokenPublicKey","walletPublicKey","tokenAccounts","getParsedTokenAccountsByOwner","mint","value","length","balance","account","data","parsed","info","tokenAmount","uiAmount","error","console","transferToken","fromWallet","toAddress","amount","_this$tokenInfo$token","_window$solana","toPublicKey","fromPublicKey","liquidityTax","marketingTax","charityTax","burnTax","amountAfterTax","decimals","getTokenInfo","transaction","fromTokenAccounts","fromTokenAccount","pubkey","toTokenAccount","toTokenAccounts","message","transferInstruction","Number","Math","floor","pow","add","burnInstruction","recentBlockhash","getRecentBlockhash","blockhash","feePayer","signedTransaction","window","solana","isPhantom","signTransaction","solflare","signature","sendRawTransaction","serialize","confirmTransaction","status","amountBurned","getParsedAccountInfo","parsedInfo","address","supply","name","symbol","getAccountTransactions","limit","signatures","getSignaturesForAddress","map","sig","timestamp","blockTime","Date","now","confirmationStatus","type","getTokenTransactions","getNativeBalance","getBalance","transferNativeSOL","transferAmount","estimatedFee","transfer","fromPubkey","toPubkey","lamports","getLatestBlockhash","walletAdapter","_confirmation$value","signed","skipPreflight","preflightCommitment","confirmation","err","JSON","stringify","signError","_signError$message","includes","_error$message","_error$message2","_error$message3","burnToken","ownerAddress","_this$tokenInfo$token2","_window$solana2","ownerPublicKey","tokenAccount","burnTokens","wallet","publicKey","process","env","REACT_APP_SOLANA_NETWORK","burnAddress","sendTransaction","associatedTokenAddress","mintInfo"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/token-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction } from '@solana/spl-token';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { getAssociatedTokenAddress, getMint } from '@solana/spl-token';\n\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n  }\n\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint, 'confirmed');\n  }\n\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get token account info\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        walletPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      // If no token accounts found, balance is 0\n      if (tokenAccounts.value.length === 0) return 0;\n      \n      // Get balance from the first token account\n      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;\n      return balance;\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw error;\n    }\n  }\n\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Calculate tax amounts (5% total)\n      const liquidityTax = amount * 0.03; // 3% for liquidity\n      const marketingTax = amount * 0.01; // 1% for marketing\n      const charityTax = amount * 0.01; // 1% for charity\n      const burnTax = amount * 0.01; // 1% for burn\n      \n      // Calculate amount after tax\n      const amountAfterTax = amount - (liquidityTax + marketingTax + charityTax + burnTax);\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create transaction\n      const transaction = new Transaction();\n      \n      // Get the token account of the fromWallet address for the token\n      const fromTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        fromPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      // If no token account found, throw error\n      if (fromTokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the sender');\n      }\n      \n      const fromTokenAccount = fromTokenAccounts.value[0].pubkey;\n      \n      // Get or create associated token account for recipient\n      let toTokenAccount;\n      try {\n        const toTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n          toPublicKey,\n          { mint: tokenPublicKey }\n        );\n        \n        if (toTokenAccounts.value.length > 0) {\n          toTokenAccount = toTokenAccounts.value[0].pubkey;\n        } else {\n          // In a real implementation, you would create an associated token account\n          // This is simplified for the example\n          throw new Error('Recipient does not have a token account for this token');\n        }\n      } catch (error) {\n        throw new Error('Error checking recipient token account: ' + error.message);\n      }\n      \n      // Create transfer instruction\n      const transferInstruction = createTransferInstruction(\n        fromTokenAccount,\n        toTokenAccount,\n        fromPublicKey,\n        Number(Math.floor(amountAfterTax * Math.pow(10, decimals))),\n        [],\n        TOKEN_PROGRAM_ID\n      );\n      \n      // Add transfer instruction to transaction\n      transaction.add(transferInstruction);\n      \n      // Add burn instruction for the burn tax\n      if (burnTax > 0) {\n        // Create burn instruction\n        const burnInstruction = createBurnInstruction(\n          fromTokenAccount,\n          tokenPublicKey,\n          fromPublicKey,\n          Number(Math.floor(burnTax * Math.pow(10, decimals)))\n        );\n        \n        // Add burn instruction to transaction\n        transaction.add(burnInstruction);\n      }\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed',\n        amountBurned: burnTax\n      };\n    } catch (error) {\n      console.error('Error transferring token:', error);\n      throw error;\n    }\n  }\n\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      \n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      \n      if (!tokenInfo.value) {\n        throw new Error('Token not found');\n      }\n      \n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: tokenInfo.value.data.parsed.info.decimals,\n        supply: tokenInfo.value.data.parsed.info.supply,\n        name: tokenInfo.value.data.parsed.info.name || 'Unknown Token',\n        symbol: tokenInfo.value.data.parsed.info.symbol || 'UNKNOWN'\n      };\n      \n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      \n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw error;\n    }\n  }\n\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(\n        walletPublicKey,\n        { limit }\n      );\n      \n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n\n  async transferNativeSOL(fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Check balance before transfer\n      const balance = await this.connection.getBalance(fromPublicKey);\n      const transferAmount = amount * LAMPORTS_PER_SOL;\n      const estimatedFee = 5000; // Approximate fee in lamports\n      \n      if (balance < transferAmount + estimatedFee) {\n        throw new Error('Insufficient balance for transfer and fees');\n      }\n      \n      // Create a simple transfer instruction\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: fromPublicKey,\n          toPubkey: toPublicKey,\n          lamports: transferAmount\n        })\n      );\n      \n      // Get the latest blockhash\n      const { blockhash } = await this.connection.getLatestBlockhash('finalized');\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Get the wallet adapter\n      const walletAdapter = window.solana || window.solflare;\n      if (!walletAdapter) {\n        throw new Error('Please connect Phantom or Solflare wallet');\n      }\n      \n      try {\n        // Sign transaction\n        const signed = await walletAdapter.signTransaction(transaction);\n        \n        // Send transaction\n        const signature = await this.connection.sendRawTransaction(signed.serialize(), {\n          skipPreflight: false,\n          preflightCommitment: 'finalized'\n        });\n        \n        // Wait for confirmation\n        const confirmation = await this.connection.confirmTransaction(signature, 'finalized');\n        \n        if (confirmation.value?.err) {\n          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));\n        }\n        \n        return {\n          signature,\n          status: 'confirmed'\n        };\n      } catch (signError) {\n        console.error('Transaction signing error:', signError);\n        if (signError.message?.includes('User rejected')) {\n          throw new Error('Transaction was rejected by the user');\n        }\n        throw new Error('Failed to sign transaction: ' + signError.message);\n      }\n    } catch (error) {\n      console.error('SOL transfer error:', error);\n      // Provide more specific error messages\n      if (error.message?.includes('insufficient')) {\n        throw new Error('Insufficient balance for transfer and network fees');\n      } else if (error.message?.includes('rejected')) {\n        throw new Error('Transaction was rejected by the user');\n      } else if (error.message?.includes('blockhash')) {\n        throw new Error('Network error: Please try again');\n      }\n      throw new Error('Transfer failed: ' + error.message);\n    }\n  }\n\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n      \n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        ownerPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      \n      const tokenAccount = tokenAccounts.value[0].pubkey;\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(\n        tokenAccount,\n        tokenPublicKey,\n        ownerPublicKey,\n        amount * Math.pow(10, decimals)\n      );\n      \n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new TokenService();\n\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n\n  const connection = new Connection(\n    clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'),\n    'confirmed'\n  );\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    \n    const transaction = new Transaction().add(\n      SystemProgram.transfer({\n        fromPubkey: wallet.publicKey,\n        toPubkey: burnAddress,\n        lamports: amount * LAMPORTS_PER_SOL,\n      })\n    );\n\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(\n      mint,\n      wallet.publicKey\n    );\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    \n    const burnInstruction = createBurnInstruction(\n      associatedTokenAddress,\n      mint,\n      wallet.publicKey,\n      amount * Math.pow(10, mintInfo.decimals)\n    );\n\n    const transaction = new Transaction().add(burnInstruction);\n    \n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}