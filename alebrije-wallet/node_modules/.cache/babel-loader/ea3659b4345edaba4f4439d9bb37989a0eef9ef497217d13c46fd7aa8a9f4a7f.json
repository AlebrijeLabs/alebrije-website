{"ast":null,"code":"import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction } from '@solana/spl-token';\nimport { useWallet } from '../contexts/WalletContext';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { getAssociatedTokenAddress, getMint, getOrCreateAssociatedTokenAccount } from '@solana/spl-token';\nimport MetricsService from './metrics-service';\n\n// Add TokenAccountCache for efficient token account lookups\n/**\n * Simple token account cache to reduce network queries\n */\nconst TokenAccountCache = {\n  _cache: {},\n  _defaultTTL: 5 * 60 * 1000,\n  // 5 minutes\n\n  /**\n   * Get a cached token account info\n   * @param {string} key Cache key in format: mintAddress:ownerAddress\n   * @returns {Object|null} Cached account info or null\n   */\n  get(key) {\n    const entry = this._cache[key];\n    if (!entry) return null;\n\n    // Check if the entry is expired\n    if (Date.now() - entry.lastChecked > entry.ttl) {\n      delete this._cache[key];\n      return null;\n    }\n    return entry;\n  },\n  /**\n   * Set token account info in cache\n   * @param {string} key Cache key\n   * @param {Object} value Value to cache\n   * @param {number} ttl Time to live in ms\n   */\n  set(key, value, ttl = this._defaultTTL) {\n    this._cache[key] = {\n      ...value,\n      ttl\n    };\n  },\n  /**\n   * Clear the entire cache or a specific entry\n   * @param {string} key Optional key to clear\n   */\n  clear(key) {\n    if (key) {\n      delete this._cache[key];\n    } else {\n      this._cache = {};\n    }\n  }\n};\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n    // Default user settings\n    this.settings = {\n      autoCreateTokenAccounts: true,\n      // Default to enabled\n      shouldShowNotifications: true\n    };\n  }\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint, 'confirmed');\n  }\n\n  /**\n   * Update user settings\n   * @param {Object} newSettings Settings to update\n   */\n  updateSettings(newSettings) {\n    this.settings = {\n      ...this.settings,\n      ...newSettings\n    };\n\n    // Track settings changes\n    if (newSettings.autoCreateTokenAccounts !== undefined) {\n      MetricsService.trackSettingChange('autoCreateTokenAccounts', newSettings.autoCreateTokenAccounts);\n    }\n    if (newSettings.shouldShowNotifications !== undefined) {\n      MetricsService.trackSettingChange('shouldShowNotifications', newSettings.shouldShowNotifications);\n    }\n  }\n\n  // Get user settings\n  getSettings() {\n    return this.settings;\n  }\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get token account info\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(walletPublicKey, {\n        mint: tokenPublicKey\n      });\n\n      // If no token accounts found, balance is 0\n      if (tokenAccounts.value.length === 0) return 0;\n\n      // Get balance from the first token account\n      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;\n      return balance;\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw error;\n    }\n  }\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      var _this$tokenInfo$token, _window$solana;\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n\n      // Calculate tax amounts (5% total)\n      const liquidityTax = amount * 0.03; // 3% for liquidity\n      const marketingTax = amount * 0.01; // 1% for marketing\n      const charityTax = amount * 0.01; // 1% for charity\n      const burnTax = amount * 0.01; // 1% for burn\n\n      // Calculate amount after tax\n      const amountAfterTax = amount - (liquidityTax + marketingTax + charityTax + burnTax);\n\n      // Get token decimals\n      const decimals = ((_this$tokenInfo$token = this.tokenInfo[tokenAddress]) === null || _this$tokenInfo$token === void 0 ? void 0 : _this$tokenInfo$token.decimals) || (await this.getTokenInfo(tokenAddress)).decimals;\n\n      // Create transaction\n      const transaction = new Transaction();\n\n      // Get the token account of the fromWallet address for the token\n      const fromTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(fromPublicKey, {\n        mint: tokenPublicKey\n      });\n\n      // If no token account found, throw error\n      if (fromTokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the sender');\n      }\n      const fromTokenAccount = fromTokenAccounts.value[0].pubkey;\n\n      // Check if recipient has a token account for this token\n      let toTokenAccount;\n      let didCreateAccount = false;\n\n      // Use cache to check if recipient has a token account\n      const cacheKey = `${tokenAddress}:${toAddress}`;\n      const cachedAccountInfo = TokenAccountCache.get(cacheKey);\n      if (cachedAccountInfo && cachedAccountInfo.exists) {\n        // Use cached token account\n        toTokenAccount = new PublicKey(cachedAccountInfo.address);\n      } else {\n        // Try to find or create the token account\n        try {\n          // First, check if account already exists\n          const recipientTokenAccount = await getAssociatedTokenAddress(tokenPublicKey, toPublicKey);\n          try {\n            // Try to get the account info (will throw if doesn't exist)\n            await this.connection.getAccountInfo(recipientTokenAccount);\n            toTokenAccount = recipientTokenAccount;\n\n            // Cache the result\n            TokenAccountCache.set(cacheKey, {\n              exists: true,\n              address: toTokenAccount.toString(),\n              lastChecked: Date.now()\n            });\n          } catch (accountError) {\n            // Account doesn't exist, check if auto-creation is enabled\n            if (this.settings.autoCreateTokenAccounts) {\n              var _createAccountIx$inst;\n              // Create the associated token account for the recipient\n              const createAccountIx = await getOrCreateAssociatedTokenAccount(this.connection, fromPublicKey,\n              // fee payer is the sender\n              tokenPublicKey, toPublicKey, false // allowOwnerOffCurve = false (standard wallet)\n              );\n\n              // Extract account address if created or found\n              if (((_createAccountIx$inst = createAccountIx.instructions) === null || _createAccountIx$inst === void 0 ? void 0 : _createAccountIx$inst.length) > 0) {\n                // Account needed to be created\n                didCreateAccount = true;\n                toTokenAccount = createAccountIx.address;\n\n                // Add account creation instructions to transaction\n                transaction.add(...createAccountIx.instructions);\n              } else {\n                // Account already exists (shouldn't happen given our checks above)\n                toTokenAccount = createAccountIx.address;\n              }\n\n              // Cache the new account\n              TokenAccountCache.set(cacheKey, {\n                exists: true,\n                address: toTokenAccount.toString(),\n                lastChecked: Date.now()\n              });\n            } else {\n              // Auto-creation is disabled, throw error\n              throw new Error('Recipient does not have a token account for this token, and automatic account creation is disabled.');\n            }\n          }\n        } catch (error) {\n          if (!this.settings.autoCreateTokenAccounts) {\n            throw new Error('Recipient does not have a token account for this token. Enable automatic token account creation in settings to fix this.');\n          }\n          throw error; // Rethrow other errors\n        }\n      }\n\n      // Create transfer instruction\n      const transferInstruction = createTransferInstruction(fromTokenAccount, toTokenAccount, fromPublicKey, BigInt(Math.floor(amountAfterTax * Math.pow(10, decimals))),\n      // Convert to BigInt for larger amounts\n      [], TOKEN_PROGRAM_ID);\n\n      // Add transfer instruction to transaction\n      transaction.add(transferInstruction);\n\n      // Add burn instruction for the burn tax\n      if (burnTax > 0) {\n        // Create burn instruction\n        const burnInstruction = createBurnInstruction(fromTokenAccount, tokenPublicKey, fromPublicKey, BigInt(Math.floor(burnTax * Math.pow(10, decimals))));\n\n        // Add burn instruction to transaction\n        transaction.add(burnInstruction);\n      }\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n\n      // For Phantom\n      if ((_window$solana = window.solana) !== null && _window$solana !== void 0 && _window$solana.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      } else {\n        throw new Error('No compatible wallet found');\n      }\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n\n      // Track successful token transfer with metrics\n      MetricsService.trackTokenTransfer({\n        tokenMint: tokenAddress,\n        success: true,\n        accountCreated: didCreateAccount\n      });\n\n      // If an account was created, track that specifically\n      if (didCreateAccount) {\n        MetricsService.trackTokenAccountCreation({\n          tokenMint: tokenAddress,\n          success: true\n        });\n      }\n      return {\n        signature,\n        status: 'confirmed',\n        amountBurned: burnTax,\n        accountCreated: didCreateAccount\n      };\n    } catch (error) {\n      console.error('Error transferring token:', error);\n\n      // Track failed token transfer\n      MetricsService.trackTokenTransfer({\n        tokenMint: tokenAddress,\n        success: false,\n        error: error.message\n      });\n      throw error;\n    }\n  }\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      if (!tokenInfo.value) {\n        throw new Error('Token not found');\n      }\n\n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: tokenInfo.value.data.parsed.info.decimals,\n        supply: tokenInfo.value.data.parsed.info.supply,\n        name: tokenInfo.value.data.parsed.info.name || 'Unknown Token',\n        symbol: tokenInfo.value.data.parsed.info.symbol || 'UNKNOWN'\n      };\n\n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw error;\n    }\n  }\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n\n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(walletPublicKey, {\n        limit\n      });\n\n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n  async transferNativeSOL(fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      var _window$solana2;\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n\n      // Create a simple transfer instruction\n      const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: fromPublicKey,\n        toPubkey: toPublicKey,\n        lamports: amount * 1000000000 // Convert SOL to lamports\n      }));\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n\n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n\n      // For Phantom\n      if ((_window$solana2 = window.solana) !== null && _window$solana2 !== void 0 && _window$solana2.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      } else {\n        throw new Error('No compatible wallet found');\n      }\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error transferring SOL:', error);\n      throw error;\n    }\n  }\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    try {\n      var _this$tokenInfo$token2, _window$solana3;\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n\n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(ownerPublicKey, {\n        mint: tokenPublicKey\n      });\n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      const tokenAccount = tokenAccounts.value[0].pubkey;\n\n      // Get token decimals\n      const decimals = ((_this$tokenInfo$token2 = this.tokenInfo[tokenAddress]) === null || _this$tokenInfo$token2 === void 0 ? void 0 : _this$tokenInfo$token2.decimals) || (await this.getTokenInfo(tokenAddress)).decimals;\n\n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(tokenAccount, tokenPublicKey, ownerPublicKey, amount * Math.pow(10, decimals));\n\n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n\n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n\n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n\n      // For Phantom\n      if ((_window$solana3 = window.solana) !== null && _window$solana3 !== void 0 && _window$solana3.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      } else {\n        throw new Error('No compatible wallet found');\n      }\n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n\n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\nexport default new TokenService();\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n  const connection = new Connection(clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'), 'confirmed');\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    const transaction = new Transaction().add(SystemProgram.transfer({\n      fromPubkey: wallet.publicKey,\n      toPubkey: burnAddress,\n      lamports: amount * LAMPORTS_PER_SOL\n    }));\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(mint, wallet.publicKey);\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    const burnInstruction = createBurnInstruction(associatedTokenAddress, mint, wallet.publicKey, amount * Math.pow(10, mintInfo.decimals));\n    const transaction = new Transaction().add(burnInstruction);\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n};","map":{"version":3,"names":["WalletService","Connection","PublicKey","Transaction","SystemProgram","LAMPORTS_PER_SOL","createTransferInstruction","TOKEN_PROGRAM_ID","createBurnInstruction","useWallet","clusterApiUrl","getAssociatedTokenAddress","getMint","getOrCreateAssociatedTokenAccount","MetricsService","TokenAccountCache","_cache","_defaultTTL","get","key","entry","Date","now","lastChecked","ttl","set","value","clear","TokenService","constructor","connection","tokenInfo","settings","autoCreateTokenAccounts","shouldShowNotifications","initialize","endpoint","updateSettings","newSettings","undefined","trackSettingChange","getSettings","getTokenBalance","tokenAddress","walletAddress","Error","tokenPublicKey","walletPublicKey","tokenAccounts","getParsedTokenAccountsByOwner","mint","length","balance","account","data","parsed","info","tokenAmount","uiAmount","error","console","transferToken","fromWallet","toAddress","amount","_this$tokenInfo$token","_window$solana","toPublicKey","fromPublicKey","liquidityTax","marketingTax","charityTax","burnTax","amountAfterTax","decimals","getTokenInfo","transaction","fromTokenAccounts","fromTokenAccount","pubkey","toTokenAccount","didCreateAccount","cacheKey","cachedAccountInfo","exists","address","recipientTokenAccount","getAccountInfo","toString","accountError","_createAccountIx$inst","createAccountIx","instructions","add","transferInstruction","BigInt","Math","floor","pow","burnInstruction","recentBlockhash","getRecentBlockhash","blockhash","feePayer","signedTransaction","window","solana","isPhantom","signTransaction","solflare","signature","sendRawTransaction","serialize","confirmTransaction","trackTokenTransfer","tokenMint","success","accountCreated","trackTokenAccountCreation","status","amountBurned","message","getParsedAccountInfo","parsedInfo","supply","name","symbol","getAccountTransactions","limit","signatures","getSignaturesForAddress","map","sig","timestamp","blockTime","confirmationStatus","type","getTokenTransactions","getNativeBalance","getBalance","transferNativeSOL","_window$solana2","transfer","fromPubkey","toPubkey","lamports","burnToken","ownerAddress","_this$tokenInfo$token2","_window$solana3","ownerPublicKey","tokenAccount","burnTokens","wallet","publicKey","process","env","REACT_APP_SOLANA_NETWORK","burnAddress","sendTransaction","associatedTokenAddress","mintInfo"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/src/services/token-service.js"],"sourcesContent":["import WalletService from './wallet-service';\nimport { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport { createTransferInstruction, TOKEN_PROGRAM_ID, createBurnInstruction } from '@solana/spl-token';\nimport { useWallet } from '../contexts/WalletContext';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { getAssociatedTokenAddress, getMint, getOrCreateAssociatedTokenAccount } from '@solana/spl-token';\nimport MetricsService from './metrics-service';\n\n// Add TokenAccountCache for efficient token account lookups\n/**\n * Simple token account cache to reduce network queries\n */\nconst TokenAccountCache = {\n  _cache: {},\n  _defaultTTL: 5 * 60 * 1000, // 5 minutes\n  \n  /**\n   * Get a cached token account info\n   * @param {string} key Cache key in format: mintAddress:ownerAddress\n   * @returns {Object|null} Cached account info or null\n   */\n  get(key) {\n    const entry = this._cache[key];\n    if (!entry) return null;\n    \n    // Check if the entry is expired\n    if (Date.now() - entry.lastChecked > entry.ttl) {\n      delete this._cache[key];\n      return null;\n    }\n    \n    return entry;\n  },\n  \n  /**\n   * Set token account info in cache\n   * @param {string} key Cache key\n   * @param {Object} value Value to cache\n   * @param {number} ttl Time to live in ms\n   */\n  set(key, value, ttl = this._defaultTTL) {\n    this._cache[key] = {\n      ...value,\n      ttl\n    };\n  },\n  \n  /**\n   * Clear the entire cache or a specific entry\n   * @param {string} key Optional key to clear\n   */\n  clear(key) {\n    if (key) {\n      delete this._cache[key];\n    } else {\n      this._cache = {};\n    }\n  }\n};\n\nclass TokenService {\n  constructor() {\n    this.connection = null;\n    this.tokenInfo = {};\n    // Default user settings\n    this.settings = {\n      autoCreateTokenAccounts: true, // Default to enabled\n      shouldShowNotifications: true\n    };\n  }\n\n  initialize(endpoint) {\n    this.connection = new Connection(endpoint, 'confirmed');\n  }\n\n  /**\n   * Update user settings\n   * @param {Object} newSettings Settings to update\n   */\n  updateSettings(newSettings) {\n    this.settings = {\n      ...this.settings,\n      ...newSettings\n    };\n    \n    // Track settings changes\n    if (newSettings.autoCreateTokenAccounts !== undefined) {\n      MetricsService.trackSettingChange('autoCreateTokenAccounts', newSettings.autoCreateTokenAccounts);\n    }\n    \n    if (newSettings.shouldShowNotifications !== undefined) {\n      MetricsService.trackSettingChange('shouldShowNotifications', newSettings.shouldShowNotifications);\n    }\n  }\n\n  // Get user settings\n  getSettings() {\n    return this.settings;\n  }\n\n  async getTokenBalance(tokenAddress, walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get token account info\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        walletPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      // If no token accounts found, balance is 0\n      if (tokenAccounts.value.length === 0) return 0;\n      \n      // Get balance from the first token account\n      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;\n      return balance;\n    } catch (error) {\n      console.error('Error getting token balance:', error);\n      throw error;\n    }\n  }\n\n  async transferToken(tokenAddress, fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Calculate tax amounts (5% total)\n      const liquidityTax = amount * 0.03; // 3% for liquidity\n      const marketingTax = amount * 0.01; // 1% for marketing\n      const charityTax = amount * 0.01; // 1% for charity\n      const burnTax = amount * 0.01; // 1% for burn\n      \n      // Calculate amount after tax\n      const amountAfterTax = amount - (liquidityTax + marketingTax + charityTax + burnTax);\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create transaction\n      const transaction = new Transaction();\n      \n      // Get the token account of the fromWallet address for the token\n      const fromTokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        fromPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      // If no token account found, throw error\n      if (fromTokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the sender');\n      }\n      \n      const fromTokenAccount = fromTokenAccounts.value[0].pubkey;\n      \n      // Check if recipient has a token account for this token\n      let toTokenAccount;\n      let didCreateAccount = false;\n      \n      // Use cache to check if recipient has a token account\n      const cacheKey = `${tokenAddress}:${toAddress}`;\n      const cachedAccountInfo = TokenAccountCache.get(cacheKey);\n      \n      if (cachedAccountInfo && cachedAccountInfo.exists) {\n        // Use cached token account\n        toTokenAccount = new PublicKey(cachedAccountInfo.address);\n      } else {\n        // Try to find or create the token account\n        try {\n          // First, check if account already exists\n          const recipientTokenAccount = await getAssociatedTokenAddress(\n            tokenPublicKey,\n            toPublicKey\n          );\n          \n          try {\n            // Try to get the account info (will throw if doesn't exist)\n            await this.connection.getAccountInfo(recipientTokenAccount);\n            toTokenAccount = recipientTokenAccount;\n            \n            // Cache the result\n            TokenAccountCache.set(cacheKey, {\n              exists: true,\n              address: toTokenAccount.toString(),\n              lastChecked: Date.now()\n            });\n          } catch (accountError) {\n            // Account doesn't exist, check if auto-creation is enabled\n            if (this.settings.autoCreateTokenAccounts) {\n              // Create the associated token account for the recipient\n              const createAccountIx = await getOrCreateAssociatedTokenAccount(\n                this.connection,\n                fromPublicKey, // fee payer is the sender\n                tokenPublicKey,\n                toPublicKey,\n                false // allowOwnerOffCurve = false (standard wallet)\n              );\n              \n              // Extract account address if created or found\n              if (createAccountIx.instructions?.length > 0) {\n                // Account needed to be created\n                didCreateAccount = true;\n                toTokenAccount = createAccountIx.address;\n                \n                // Add account creation instructions to transaction\n                transaction.add(...createAccountIx.instructions);\n              } else {\n                // Account already exists (shouldn't happen given our checks above)\n                toTokenAccount = createAccountIx.address;\n              }\n              \n              // Cache the new account\n              TokenAccountCache.set(cacheKey, {\n                exists: true,\n                address: toTokenAccount.toString(),\n                lastChecked: Date.now()\n              });\n            } else {\n              // Auto-creation is disabled, throw error\n              throw new Error('Recipient does not have a token account for this token, and automatic account creation is disabled.');\n            }\n          }\n        } catch (error) {\n          if (!this.settings.autoCreateTokenAccounts) {\n            throw new Error('Recipient does not have a token account for this token. Enable automatic token account creation in settings to fix this.');\n          }\n          throw error; // Rethrow other errors\n        }\n      }\n      \n      // Create transfer instruction\n      const transferInstruction = createTransferInstruction(\n        fromTokenAccount,\n        toTokenAccount,\n        fromPublicKey,\n        BigInt(Math.floor(amountAfterTax * Math.pow(10, decimals))), // Convert to BigInt for larger amounts\n        [],\n        TOKEN_PROGRAM_ID\n      );\n      \n      // Add transfer instruction to transaction\n      transaction.add(transferInstruction);\n      \n      // Add burn instruction for the burn tax\n      if (burnTax > 0) {\n        // Create burn instruction\n        const burnInstruction = createBurnInstruction(\n          fromTokenAccount,\n          tokenPublicKey,\n          fromPublicKey,\n          BigInt(Math.floor(burnTax * Math.pow(10, decimals)))\n        );\n        \n        // Add burn instruction to transaction\n        transaction.add(burnInstruction);\n      }\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      // Track successful token transfer with metrics\n      MetricsService.trackTokenTransfer({\n        tokenMint: tokenAddress,\n        success: true,\n        accountCreated: didCreateAccount\n      });\n      \n      // If an account was created, track that specifically\n      if (didCreateAccount) {\n        MetricsService.trackTokenAccountCreation({\n          tokenMint: tokenAddress,\n          success: true\n        });\n      }\n      \n      return {\n        signature,\n        status: 'confirmed',\n        amountBurned: burnTax,\n        accountCreated: didCreateAccount\n      };\n    } catch (error) {\n      console.error('Error transferring token:', error);\n      \n      // Track failed token transfer\n      MetricsService.trackTokenTransfer({\n        tokenMint: tokenAddress,\n        success: false,\n        error: error.message\n      });\n      \n      throw error;\n    }\n  }\n\n  async getTokenInfo(tokenAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      // If we already have the info cached, return it\n      if (this.tokenInfo[tokenAddress]) {\n        return this.tokenInfo[tokenAddress];\n      }\n      \n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const tokenInfo = await this.connection.getParsedAccountInfo(tokenPublicKey);\n      \n      if (!tokenInfo.value) {\n        throw new Error('Token not found');\n      }\n      \n      // Parse token info\n      const parsedInfo = {\n        address: tokenAddress,\n        decimals: tokenInfo.value.data.parsed.info.decimals,\n        supply: tokenInfo.value.data.parsed.info.supply,\n        name: tokenInfo.value.data.parsed.info.name || 'Unknown Token',\n        symbol: tokenInfo.value.data.parsed.info.symbol || 'UNKNOWN'\n      };\n      \n      // Cache the info\n      this.tokenInfo[tokenAddress] = parsedInfo;\n      \n      return parsedInfo;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      throw error;\n    }\n  }\n\n  async getAccountTransactions(walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      \n      // Get recent transactions for the account\n      const signatures = await this.connection.getSignaturesForAddress(\n        walletPublicKey,\n        { limit }\n      );\n      \n      // Return simplified transaction data\n      return signatures.map(sig => ({\n        signature: sig.signature,\n        timestamp: sig.blockTime || Date.now() / 1000,\n        status: sig.confirmationStatus || 'confirmed',\n        type: 'unknown',\n        symbol: 'SOL',\n        decimals: 9,\n        amount: 0 // We don't parse the amount here for simplicity\n      }));\n    } catch (error) {\n      console.error('Error getting account transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getTokenTransactions(tokenAddress, walletAddress, limit = 10) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!tokenAddress) throw new Error('Token address is required');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      // Just return empty array for now to avoid errors\n      return [];\n    } catch (error) {\n      console.error('Error getting token transactions:', error);\n      return []; // Return empty array instead of throwing\n    }\n  }\n\n  async getNativeBalance(walletAddress) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    if (!walletAddress) throw new Error('Wallet address is required');\n    \n    try {\n      const walletPublicKey = new PublicKey(walletAddress);\n      const balance = await this.connection.getBalance(walletPublicKey);\n      return balance / 1000000000; // Convert lamports to SOL\n    } catch (error) {\n      console.error('Error getting native balance:', error);\n      throw error;\n    }\n  }\n\n  async transferNativeSOL(fromWallet, toAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const toPublicKey = new PublicKey(toAddress);\n      const fromPublicKey = new PublicKey(fromWallet);\n      \n      // Create a simple transfer instruction\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: fromPublicKey,\n          toPubkey: toPublicKey,\n          lamports: amount * 1000000000 // Convert SOL to lamports\n        })\n      );\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = fromPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error transferring SOL:', error);\n      throw error;\n    }\n  }\n\n  async burnToken(tokenAddress, ownerAddress, amount) {\n    if (!this.connection) throw new Error('Token service not initialized');\n    \n    try {\n      const tokenPublicKey = new PublicKey(tokenAddress);\n      const ownerPublicKey = new PublicKey(ownerAddress);\n      \n      // Get the token account of the owner\n      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(\n        ownerPublicKey,\n        { mint: tokenPublicKey }\n      );\n      \n      if (tokenAccounts.value.length === 0) {\n        throw new Error('No token account found for the owner');\n      }\n      \n      const tokenAccount = tokenAccounts.value[0].pubkey;\n      \n      // Get token decimals\n      const decimals = this.tokenInfo[tokenAddress]?.decimals || \n                      (await this.getTokenInfo(tokenAddress)).decimals;\n      \n      // Create burn instruction\n      const burnInstruction = createBurnInstruction(\n        tokenAccount,\n        tokenPublicKey,\n        ownerPublicKey,\n        amount * Math.pow(10, decimals)\n      );\n      \n      // Create transaction and add the burn instruction\n      const transaction = new Transaction().add(burnInstruction);\n      \n      // Set recent blockhash and fee payer\n      transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;\n      transaction.feePayer = ownerPublicKey;\n      \n      // Sign transaction using the wallet adapter\n      let signedTransaction;\n      \n      // For Phantom\n      if (window.solana?.isPhantom) {\n        signedTransaction = await window.solana.signTransaction(transaction);\n      }\n      // For Solflare\n      else if (window.solflare) {\n        signedTransaction = await window.solflare.signTransaction(transaction);\n      }\n      else {\n        throw new Error('No compatible wallet found');\n      }\n      \n      const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n      \n      // Wait for confirmation\n      await this.connection.confirmTransaction(signature);\n      \n      return {\n        signature,\n        status: 'confirmed'\n      };\n    } catch (error) {\n      console.error('Error burning token:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new TokenService();\n\nexport const burnTokens = async (wallet, tokenAddress, amount) => {\n  if (!wallet.publicKey) {\n    throw new Error('Wallet not connected');\n  }\n\n  const connection = new Connection(\n    clusterApiUrl(process.env.REACT_APP_SOLANA_NETWORK || 'devnet'),\n    'confirmed'\n  );\n\n  // For SOL burning (send to a dead address)\n  if (tokenAddress === 'native') {\n    // Burn address (a known unusable address)\n    const burnAddress = new PublicKey('1111111111111111111111111111111111111111111');\n    \n    const transaction = new Transaction().add(\n      SystemProgram.transfer({\n        fromPubkey: wallet.publicKey,\n        toPubkey: burnAddress,\n        lamports: amount * LAMPORTS_PER_SOL,\n      })\n    );\n\n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  } else {\n    // For SPL tokens\n    const mint = new PublicKey(tokenAddress);\n    const associatedTokenAddress = await getAssociatedTokenAddress(\n      mint,\n      wallet.publicKey\n    );\n\n    // Get mint info to get decimals\n    const mintInfo = await getMint(connection, mint);\n    \n    const burnInstruction = createBurnInstruction(\n      associatedTokenAddress,\n      mint,\n      wallet.publicKey,\n      amount * Math.pow(10, mintInfo.decimals)\n    );\n\n    const transaction = new Transaction().add(burnInstruction);\n    \n    const signature = await wallet.sendTransaction(transaction, connection);\n    await connection.confirmTransaction(signature, 'confirmed');\n    return signature;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}