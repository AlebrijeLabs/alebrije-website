{"ast":null,"code":"import destr from 'destr';\nimport { n as normalizeBaseKey, a as normalizeKey, b as asyncCall, f as filterKeyByDepth, c as filterKeyByBase, s as serializeRaw, d as stringify, e as deserializeRaw, j as joinKeys } from './shared/unstorage.mNKHTF5Y.mjs';\nexport { p as prefixStorage } from './shared/unstorage.mNKHTF5Y.mjs';\nfunction defineDriver(factory) {\n  return factory;\n}\nconst DRIVER_NAME = \"memory\";\nconst memory = defineDriver(() => {\n  const data = /* @__PURE__ */new Map();\n  return {\n    name: DRIVER_NAME,\n    getInstance: () => data,\n    hasItem(key) {\n      return data.has(key);\n    },\n    getItem(key) {\n      return data.get(key) ?? null;\n    },\n    getItemRaw(key) {\n      return data.get(key) ?? null;\n    },\n    setItem(key, value) {\n      data.set(key, value);\n    },\n    setItemRaw(key, value) {\n      data.set(key, value);\n    },\n    removeItem(key) {\n      data.delete(key);\n    },\n    getKeys() {\n      return [...data.keys()];\n    },\n    clear() {\n      data.clear();\n    },\n    dispose() {\n      data.clear();\n    }\n  };\n});\nfunction createStorage() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const context = {\n    mounts: {\n      \"\": options.driver || memory()\n    },\n    mountpoints: [\"\"],\n    watching: false,\n    watchListeners: [],\n    unwatch: {}\n  };\n  const getMount = key => {\n    for (const base of context.mountpoints) {\n      if (key.startsWith(base)) {\n        return {\n          base,\n          relativeKey: key.slice(base.length),\n          driver: context.mounts[base]\n        };\n      }\n    }\n    return {\n      base: \"\",\n      relativeKey: key,\n      driver: context.mounts[\"\"]\n    };\n  };\n  const getMounts = (base, includeParent) => {\n    return context.mountpoints.filter(mountpoint => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)).map(mountpoint => ({\n      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,\n      mountpoint,\n      driver: context.mounts[mountpoint]\n    }));\n  };\n  const onChange = (event, key) => {\n    if (!context.watching) {\n      return;\n    }\n    key = normalizeKey(key);\n    for (const listener of context.watchListeners) {\n      listener(event, key);\n    }\n  };\n  const startWatch = async () => {\n    if (context.watching) {\n      return;\n    }\n    context.watching = true;\n    for (const mountpoint in context.mounts) {\n      context.unwatch[mountpoint] = await watch(context.mounts[mountpoint], onChange, mountpoint);\n    }\n  };\n  const stopWatch = async () => {\n    if (!context.watching) {\n      return;\n    }\n    for (const mountpoint in context.unwatch) {\n      await context.unwatch[mountpoint]();\n    }\n    context.unwatch = {};\n    context.watching = false;\n  };\n  const runBatch = (items, commonOptions, cb) => {\n    const batches = /* @__PURE__ */new Map();\n    const getBatch = mount => {\n      let batch = batches.get(mount.base);\n      if (!batch) {\n        batch = {\n          driver: mount.driver,\n          base: mount.base,\n          items: []\n        };\n        batches.set(mount.base, batch);\n      }\n      return batch;\n    };\n    for (const item of items) {\n      const isStringItem = typeof item === \"string\";\n      const key = normalizeKey(isStringItem ? item : item.key);\n      const value = isStringItem ? void 0 : item.value;\n      const options2 = isStringItem || !item.options ? commonOptions : {\n        ...commonOptions,\n        ...item.options\n      };\n      const mount = getMount(key);\n      getBatch(mount).items.push({\n        key,\n        value,\n        relativeKey: mount.relativeKey,\n        options: options2\n      });\n    }\n    return Promise.all([...batches.values()].map(batch => cb(batch))).then(r => r.flat());\n  };\n  const storage = {\n    // Item\n    hasItem(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      return asyncCall(driver.hasItem, relativeKey, opts);\n    },\n    getItem(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      return asyncCall(driver.getItem, relativeKey, opts).then(value => destr(value));\n    },\n    getItems(items) {\n      let commonOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return runBatch(items, commonOptions, batch => {\n        if (batch.driver.getItems) {\n          return asyncCall(batch.driver.getItems, batch.items.map(item => ({\n            key: item.relativeKey,\n            options: item.options\n          })), commonOptions).then(r => r.map(item => ({\n            key: joinKeys(batch.base, item.key),\n            value: destr(item.value)\n          })));\n        }\n        return Promise.all(batch.items.map(item => {\n          return asyncCall(batch.driver.getItem, item.relativeKey, item.options).then(value => ({\n            key: item.key,\n            value: destr(value)\n          }));\n        }));\n      });\n    },\n    getItemRaw(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (driver.getItemRaw) {\n        return asyncCall(driver.getItemRaw, relativeKey, opts);\n      }\n      return asyncCall(driver.getItem, relativeKey, opts).then(value => deserializeRaw(value));\n    },\n    async setItem(key, value) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (value === void 0) {\n        return storage.removeItem(key);\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (!driver.setItem) {\n        return;\n      }\n      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async setItems(items, commonOptions) {\n      await runBatch(items, commonOptions, async batch => {\n        if (batch.driver.setItems) {\n          return asyncCall(batch.driver.setItems, batch.items.map(item => ({\n            key: item.relativeKey,\n            value: stringify(item.value),\n            options: item.options\n          })), commonOptions);\n        }\n        if (!batch.driver.setItem) {\n          return;\n        }\n        await Promise.all(batch.items.map(item => {\n          return asyncCall(batch.driver.setItem, item.relativeKey, stringify(item.value), item.options);\n        }));\n      });\n    },\n    async setItemRaw(key, value) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (value === void 0) {\n        return storage.removeItem(key, opts);\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (driver.setItemRaw) {\n        await asyncCall(driver.setItemRaw, relativeKey, value, opts);\n      } else if (driver.setItem) {\n        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);\n      } else {\n        return;\n      }\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async removeItem(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof opts === \"boolean\") {\n        opts = {\n          removeMeta: opts\n        };\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (!driver.removeItem) {\n        return;\n      }\n      await asyncCall(driver.removeItem, relativeKey, opts);\n      if (opts.removeMeta || opts.removeMata) {\n        await asyncCall(driver.removeItem, relativeKey + \"$\", opts);\n      }\n      if (!driver.watch) {\n        onChange(\"remove\", key);\n      }\n    },\n    // Meta\n    async getMeta(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof opts === \"boolean\") {\n        opts = {\n          nativeOnly: opts\n        };\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      const meta = /* @__PURE__ */Object.create(null);\n      if (driver.getMeta) {\n        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));\n      }\n      if (!opts.nativeOnly) {\n        const value = await asyncCall(driver.getItem, relativeKey + \"$\", opts).then(value_ => destr(value_));\n        if (value && typeof value === \"object\") {\n          if (typeof value.atime === \"string\") {\n            value.atime = new Date(value.atime);\n          }\n          if (typeof value.mtime === \"string\") {\n            value.mtime = new Date(value.mtime);\n          }\n          Object.assign(meta, value);\n        }\n      }\n      return meta;\n    },\n    setMeta(key, value) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.setItem(key + \"$\", value, opts);\n    },\n    removeMeta(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.removeItem(key + \"$\", opts);\n    },\n    // Keys\n    async getKeys(base) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      base = normalizeBaseKey(base);\n      const mounts = getMounts(base, true);\n      let maskedMounts = [];\n      const allKeys = [];\n      let allMountsSupportMaxDepth = true;\n      for (const mount of mounts) {\n        if (!mount.driver.flags?.maxDepth) {\n          allMountsSupportMaxDepth = false;\n        }\n        const rawKeys = await asyncCall(mount.driver.getKeys, mount.relativeBase, opts);\n        for (const key of rawKeys) {\n          const fullKey = mount.mountpoint + normalizeKey(key);\n          if (!maskedMounts.some(p => fullKey.startsWith(p))) {\n            allKeys.push(fullKey);\n          }\n        }\n        maskedMounts = [mount.mountpoint, ...maskedMounts.filter(p => !p.startsWith(mount.mountpoint))];\n      }\n      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;\n      return allKeys.filter(key => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base));\n    },\n    // Utils\n    async clear(base) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      base = normalizeBaseKey(base);\n      await Promise.all(getMounts(base, false).map(async m => {\n        if (m.driver.clear) {\n          return asyncCall(m.driver.clear, m.relativeBase, opts);\n        }\n        if (m.driver.removeItem) {\n          const keys = await m.driver.getKeys(m.relativeBase || \"\", opts);\n          return Promise.all(keys.map(key => m.driver.removeItem(key, opts)));\n        }\n      }));\n    },\n    async dispose() {\n      await Promise.all(Object.values(context.mounts).map(driver => dispose(driver)));\n    },\n    async watch(callback) {\n      await startWatch();\n      context.watchListeners.push(callback);\n      return async () => {\n        context.watchListeners = context.watchListeners.filter(listener => listener !== callback);\n        if (context.watchListeners.length === 0) {\n          await stopWatch();\n        }\n      };\n    },\n    async unwatch() {\n      context.watchListeners = [];\n      await stopWatch();\n    },\n    // Mount\n    mount(base, driver) {\n      base = normalizeBaseKey(base);\n      if (base && context.mounts[base]) {\n        throw new Error(`already mounted at ${base}`);\n      }\n      if (base) {\n        context.mountpoints.push(base);\n        context.mountpoints.sort((a, b) => b.length - a.length);\n      }\n      context.mounts[base] = driver;\n      if (context.watching) {\n        Promise.resolve(watch(driver, onChange, base)).then(unwatcher => {\n          context.unwatch[base] = unwatcher;\n        }).catch(console.error);\n      }\n      return storage;\n    },\n    async unmount(base) {\n      let _dispose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      base = normalizeBaseKey(base);\n      if (!base || !context.mounts[base]) {\n        return;\n      }\n      if (context.watching && base in context.unwatch) {\n        context.unwatch[base]?.();\n        delete context.unwatch[base];\n      }\n      if (_dispose) {\n        await dispose(context.mounts[base]);\n      }\n      context.mountpoints = context.mountpoints.filter(key => key !== base);\n      delete context.mounts[base];\n    },\n    getMount() {\n      let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      key = normalizeKey(key) + \":\";\n      const m = getMount(key);\n      return {\n        driver: m.driver,\n        base: m.base\n      };\n    },\n    getMounts() {\n      let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      base = normalizeKey(base);\n      const mounts = getMounts(base, opts.parents);\n      return mounts.map(m => ({\n        driver: m.driver,\n        base: m.mountpoint\n      }));\n    },\n    // Aliases\n    keys: function (base) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return storage.getKeys(base, opts);\n    },\n    get: function (key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return storage.getItem(key, opts);\n    },\n    set: function (key, value) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return storage.setItem(key, value, opts);\n    },\n    has: function (key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return storage.hasItem(key, opts);\n    },\n    del: function (key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return storage.removeItem(key, opts);\n    },\n    remove: function (key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return storage.removeItem(key, opts);\n    }\n  };\n  return storage;\n}\nasync function snapshot(storage, base) {\n  base = normalizeBaseKey(base);\n  const keys = await storage.getKeys(base);\n  const snapshot2 = {};\n  await Promise.all(keys.map(async key => {\n    snapshot2[key.slice(base.length)] = await storage.getItem(key);\n  }));\n  return snapshot2;\n}\nasync function restoreSnapshot(driver, snapshot2) {\n  let base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  base = normalizeBaseKey(base);\n  await Promise.all(Object.entries(snapshot2).map(e => driver.setItem(base + e[0], e[1])));\n}\nfunction watch(driver, onChange, base) {\n  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {};\n}\nasync function dispose(driver) {\n  if (typeof driver.dispose === \"function\") {\n    await asyncCall(driver.dispose);\n  }\n}\nconst builtinDrivers = {\n  \"azure-app-configuration\": \"unstorage/drivers/azure-app-configuration\",\n  \"azureAppConfiguration\": \"unstorage/drivers/azure-app-configuration\",\n  \"azure-cosmos\": \"unstorage/drivers/azure-cosmos\",\n  \"azureCosmos\": \"unstorage/drivers/azure-cosmos\",\n  \"azure-key-vault\": \"unstorage/drivers/azure-key-vault\",\n  \"azureKeyVault\": \"unstorage/drivers/azure-key-vault\",\n  \"azure-storage-blob\": \"unstorage/drivers/azure-storage-blob\",\n  \"azureStorageBlob\": \"unstorage/drivers/azure-storage-blob\",\n  \"azure-storage-table\": \"unstorage/drivers/azure-storage-table\",\n  \"azureStorageTable\": \"unstorage/drivers/azure-storage-table\",\n  \"capacitor-preferences\": \"unstorage/drivers/capacitor-preferences\",\n  \"capacitorPreferences\": \"unstorage/drivers/capacitor-preferences\",\n  \"cloudflare-kv-binding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  \"cloudflareKVBinding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  \"cloudflare-kv-http\": \"unstorage/drivers/cloudflare-kv-http\",\n  \"cloudflareKVHttp\": \"unstorage/drivers/cloudflare-kv-http\",\n  \"cloudflare-r2-binding\": \"unstorage/drivers/cloudflare-r2-binding\",\n  \"cloudflareR2Binding\": \"unstorage/drivers/cloudflare-r2-binding\",\n  \"db0\": \"unstorage/drivers/db0\",\n  \"deno-kv-node\": \"unstorage/drivers/deno-kv-node\",\n  \"denoKVNode\": \"unstorage/drivers/deno-kv-node\",\n  \"deno-kv\": \"unstorage/drivers/deno-kv\",\n  \"denoKV\": \"unstorage/drivers/deno-kv\",\n  \"fs-lite\": \"unstorage/drivers/fs-lite\",\n  \"fsLite\": \"unstorage/drivers/fs-lite\",\n  \"fs\": \"unstorage/drivers/fs\",\n  \"github\": \"unstorage/drivers/github\",\n  \"http\": \"unstorage/drivers/http\",\n  \"indexedb\": \"unstorage/drivers/indexedb\",\n  \"localstorage\": \"unstorage/drivers/localstorage\",\n  \"lru-cache\": \"unstorage/drivers/lru-cache\",\n  \"lruCache\": \"unstorage/drivers/lru-cache\",\n  \"memory\": \"unstorage/drivers/memory\",\n  \"mongodb\": \"unstorage/drivers/mongodb\",\n  \"netlify-blobs\": \"unstorage/drivers/netlify-blobs\",\n  \"netlifyBlobs\": \"unstorage/drivers/netlify-blobs\",\n  \"null\": \"unstorage/drivers/null\",\n  \"overlay\": \"unstorage/drivers/overlay\",\n  \"planetscale\": \"unstorage/drivers/planetscale\",\n  \"redis\": \"unstorage/drivers/redis\",\n  \"s3\": \"unstorage/drivers/s3\",\n  \"session-storage\": \"unstorage/drivers/session-storage\",\n  \"sessionStorage\": \"unstorage/drivers/session-storage\",\n  \"uploadthing\": \"unstorage/drivers/uploadthing\",\n  \"upstash\": \"unstorage/drivers/upstash\",\n  \"vercel-blob\": \"unstorage/drivers/vercel-blob\",\n  \"vercelBlob\": \"unstorage/drivers/vercel-blob\",\n  \"vercel-kv\": \"unstorage/drivers/vercel-kv\",\n  \"vercelKV\": \"unstorage/drivers/vercel-kv\"\n};\nexport { builtinDrivers, createStorage, defineDriver, filterKeyByBase, filterKeyByDepth, joinKeys, normalizeBaseKey, normalizeKey, restoreSnapshot, snapshot };","map":{"version":3,"names":["destr","n","normalizeBaseKey","a","normalizeKey","b","asyncCall","f","filterKeyByDepth","c","filterKeyByBase","s","serializeRaw","d","stringify","e","deserializeRaw","j","joinKeys","p","prefixStorage","defineDriver","factory","DRIVER_NAME","memory","data","Map","name","getInstance","hasItem","key","has","getItem","get","getItemRaw","setItem","value","set","setItemRaw","removeItem","delete","getKeys","keys","clear","dispose","createStorage","options","arguments","length","undefined","context","mounts","driver","mountpoints","watching","watchListeners","unwatch","getMount","base","startsWith","relativeKey","slice","getMounts","includeParent","filter","mountpoint","map","relativeBase","onChange","event","listener","startWatch","watch","stopWatch","runBatch","items","commonOptions","cb","batches","getBatch","mount","batch","item","isStringItem","options2","push","Promise","all","values","then","r","flat","storage","opts","getItems","setItems","removeMeta","removeMata","getMeta","nativeOnly","meta","Object","create","assign","value_","atime","Date","mtime","setMeta","maskedMounts","allKeys","allMountsSupportMaxDepth","flags","maxDepth","rawKeys","fullKey","some","shouldFilterByDepth","m","callback","Error","sort","resolve","unwatcher","catch","console","error","unmount","_dispose","parents","del","remove","snapshot","snapshot2","restoreSnapshot","entries","builtinDrivers"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/unstorage/dist/index.mjs"],"sourcesContent":["import destr from 'destr';\nimport { n as normalizeBaseKey, a as normalizeKey, b as asyncCall, f as filterKeyByDepth, c as filterKeyByBase, s as serializeRaw, d as stringify, e as deserializeRaw, j as joinKeys } from './shared/unstorage.mNKHTF5Y.mjs';\nexport { p as prefixStorage } from './shared/unstorage.mNKHTF5Y.mjs';\n\nfunction defineDriver(factory) {\n  return factory;\n}\n\nconst DRIVER_NAME = \"memory\";\nconst memory = defineDriver(() => {\n  const data = /* @__PURE__ */ new Map();\n  return {\n    name: DRIVER_NAME,\n    getInstance: () => data,\n    hasItem(key) {\n      return data.has(key);\n    },\n    getItem(key) {\n      return data.get(key) ?? null;\n    },\n    getItemRaw(key) {\n      return data.get(key) ?? null;\n    },\n    setItem(key, value) {\n      data.set(key, value);\n    },\n    setItemRaw(key, value) {\n      data.set(key, value);\n    },\n    removeItem(key) {\n      data.delete(key);\n    },\n    getKeys() {\n      return [...data.keys()];\n    },\n    clear() {\n      data.clear();\n    },\n    dispose() {\n      data.clear();\n    }\n  };\n});\n\nfunction createStorage(options = {}) {\n  const context = {\n    mounts: { \"\": options.driver || memory() },\n    mountpoints: [\"\"],\n    watching: false,\n    watchListeners: [],\n    unwatch: {}\n  };\n  const getMount = (key) => {\n    for (const base of context.mountpoints) {\n      if (key.startsWith(base)) {\n        return {\n          base,\n          relativeKey: key.slice(base.length),\n          driver: context.mounts[base]\n        };\n      }\n    }\n    return {\n      base: \"\",\n      relativeKey: key,\n      driver: context.mounts[\"\"]\n    };\n  };\n  const getMounts = (base, includeParent) => {\n    return context.mountpoints.filter(\n      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)\n    ).map((mountpoint) => ({\n      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,\n      mountpoint,\n      driver: context.mounts[mountpoint]\n    }));\n  };\n  const onChange = (event, key) => {\n    if (!context.watching) {\n      return;\n    }\n    key = normalizeKey(key);\n    for (const listener of context.watchListeners) {\n      listener(event, key);\n    }\n  };\n  const startWatch = async () => {\n    if (context.watching) {\n      return;\n    }\n    context.watching = true;\n    for (const mountpoint in context.mounts) {\n      context.unwatch[mountpoint] = await watch(\n        context.mounts[mountpoint],\n        onChange,\n        mountpoint\n      );\n    }\n  };\n  const stopWatch = async () => {\n    if (!context.watching) {\n      return;\n    }\n    for (const mountpoint in context.unwatch) {\n      await context.unwatch[mountpoint]();\n    }\n    context.unwatch = {};\n    context.watching = false;\n  };\n  const runBatch = (items, commonOptions, cb) => {\n    const batches = /* @__PURE__ */ new Map();\n    const getBatch = (mount) => {\n      let batch = batches.get(mount.base);\n      if (!batch) {\n        batch = {\n          driver: mount.driver,\n          base: mount.base,\n          items: []\n        };\n        batches.set(mount.base, batch);\n      }\n      return batch;\n    };\n    for (const item of items) {\n      const isStringItem = typeof item === \"string\";\n      const key = normalizeKey(isStringItem ? item : item.key);\n      const value = isStringItem ? void 0 : item.value;\n      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };\n      const mount = getMount(key);\n      getBatch(mount).items.push({\n        key,\n        value,\n        relativeKey: mount.relativeKey,\n        options: options2\n      });\n    }\n    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(\n      (r) => r.flat()\n    );\n  };\n  const storage = {\n    // Item\n    hasItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.hasItem, relativeKey, opts);\n    },\n    getItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value) => destr(value)\n      );\n    },\n    getItems(items, commonOptions = {}) {\n      return runBatch(items, commonOptions, (batch) => {\n        if (batch.driver.getItems) {\n          return asyncCall(\n            batch.driver.getItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              options: item.options\n            })),\n            commonOptions\n          ).then(\n            (r) => r.map((item) => ({\n              key: joinKeys(batch.base, item.key),\n              value: destr(item.value)\n            }))\n          );\n        }\n        return Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.getItem,\n              item.relativeKey,\n              item.options\n            ).then((value) => ({\n              key: item.key,\n              value: destr(value)\n            }));\n          })\n        );\n      });\n    },\n    getItemRaw(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.getItemRaw) {\n        return asyncCall(driver.getItemRaw, relativeKey, opts);\n      }\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value) => deserializeRaw(value)\n      );\n    },\n    async setItem(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.setItem) {\n        return;\n      }\n      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async setItems(items, commonOptions) {\n      await runBatch(items, commonOptions, async (batch) => {\n        if (batch.driver.setItems) {\n          return asyncCall(\n            batch.driver.setItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              value: stringify(item.value),\n              options: item.options\n            })),\n            commonOptions\n          );\n        }\n        if (!batch.driver.setItem) {\n          return;\n        }\n        await Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.setItem,\n              item.relativeKey,\n              stringify(item.value),\n              item.options\n            );\n          })\n        );\n      });\n    },\n    async setItemRaw(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key, opts);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.setItemRaw) {\n        await asyncCall(driver.setItemRaw, relativeKey, value, opts);\n      } else if (driver.setItem) {\n        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);\n      } else {\n        return;\n      }\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async removeItem(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { removeMeta: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.removeItem) {\n        return;\n      }\n      await asyncCall(driver.removeItem, relativeKey, opts);\n      if (opts.removeMeta || opts.removeMata) {\n        await asyncCall(driver.removeItem, relativeKey + \"$\", opts);\n      }\n      if (!driver.watch) {\n        onChange(\"remove\", key);\n      }\n    },\n    // Meta\n    async getMeta(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { nativeOnly: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      const meta = /* @__PURE__ */ Object.create(null);\n      if (driver.getMeta) {\n        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));\n      }\n      if (!opts.nativeOnly) {\n        const value = await asyncCall(\n          driver.getItem,\n          relativeKey + \"$\",\n          opts\n        ).then((value_) => destr(value_));\n        if (value && typeof value === \"object\") {\n          if (typeof value.atime === \"string\") {\n            value.atime = new Date(value.atime);\n          }\n          if (typeof value.mtime === \"string\") {\n            value.mtime = new Date(value.mtime);\n          }\n          Object.assign(meta, value);\n        }\n      }\n      return meta;\n    },\n    setMeta(key, value, opts = {}) {\n      return this.setItem(key + \"$\", value, opts);\n    },\n    removeMeta(key, opts = {}) {\n      return this.removeItem(key + \"$\", opts);\n    },\n    // Keys\n    async getKeys(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      const mounts = getMounts(base, true);\n      let maskedMounts = [];\n      const allKeys = [];\n      let allMountsSupportMaxDepth = true;\n      for (const mount of mounts) {\n        if (!mount.driver.flags?.maxDepth) {\n          allMountsSupportMaxDepth = false;\n        }\n        const rawKeys = await asyncCall(\n          mount.driver.getKeys,\n          mount.relativeBase,\n          opts\n        );\n        for (const key of rawKeys) {\n          const fullKey = mount.mountpoint + normalizeKey(key);\n          if (!maskedMounts.some((p) => fullKey.startsWith(p))) {\n            allKeys.push(fullKey);\n          }\n        }\n        maskedMounts = [\n          mount.mountpoint,\n          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))\n        ];\n      }\n      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;\n      return allKeys.filter(\n        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)\n      );\n    },\n    // Utils\n    async clear(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      await Promise.all(\n        getMounts(base, false).map(async (m) => {\n          if (m.driver.clear) {\n            return asyncCall(m.driver.clear, m.relativeBase, opts);\n          }\n          if (m.driver.removeItem) {\n            const keys = await m.driver.getKeys(m.relativeBase || \"\", opts);\n            return Promise.all(\n              keys.map((key) => m.driver.removeItem(key, opts))\n            );\n          }\n        })\n      );\n    },\n    async dispose() {\n      await Promise.all(\n        Object.values(context.mounts).map((driver) => dispose(driver))\n      );\n    },\n    async watch(callback) {\n      await startWatch();\n      context.watchListeners.push(callback);\n      return async () => {\n        context.watchListeners = context.watchListeners.filter(\n          (listener) => listener !== callback\n        );\n        if (context.watchListeners.length === 0) {\n          await stopWatch();\n        }\n      };\n    },\n    async unwatch() {\n      context.watchListeners = [];\n      await stopWatch();\n    },\n    // Mount\n    mount(base, driver) {\n      base = normalizeBaseKey(base);\n      if (base && context.mounts[base]) {\n        throw new Error(`already mounted at ${base}`);\n      }\n      if (base) {\n        context.mountpoints.push(base);\n        context.mountpoints.sort((a, b) => b.length - a.length);\n      }\n      context.mounts[base] = driver;\n      if (context.watching) {\n        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {\n          context.unwatch[base] = unwatcher;\n        }).catch(console.error);\n      }\n      return storage;\n    },\n    async unmount(base, _dispose = true) {\n      base = normalizeBaseKey(base);\n      if (!base || !context.mounts[base]) {\n        return;\n      }\n      if (context.watching && base in context.unwatch) {\n        context.unwatch[base]?.();\n        delete context.unwatch[base];\n      }\n      if (_dispose) {\n        await dispose(context.mounts[base]);\n      }\n      context.mountpoints = context.mountpoints.filter((key) => key !== base);\n      delete context.mounts[base];\n    },\n    getMount(key = \"\") {\n      key = normalizeKey(key) + \":\";\n      const m = getMount(key);\n      return {\n        driver: m.driver,\n        base: m.base\n      };\n    },\n    getMounts(base = \"\", opts = {}) {\n      base = normalizeKey(base);\n      const mounts = getMounts(base, opts.parents);\n      return mounts.map((m) => ({\n        driver: m.driver,\n        base: m.mountpoint\n      }));\n    },\n    // Aliases\n    keys: (base, opts = {}) => storage.getKeys(base, opts),\n    get: (key, opts = {}) => storage.getItem(key, opts),\n    set: (key, value, opts = {}) => storage.setItem(key, value, opts),\n    has: (key, opts = {}) => storage.hasItem(key, opts),\n    del: (key, opts = {}) => storage.removeItem(key, opts),\n    remove: (key, opts = {}) => storage.removeItem(key, opts)\n  };\n  return storage;\n}\nasync function snapshot(storage, base) {\n  base = normalizeBaseKey(base);\n  const keys = await storage.getKeys(base);\n  const snapshot2 = {};\n  await Promise.all(\n    keys.map(async (key) => {\n      snapshot2[key.slice(base.length)] = await storage.getItem(key);\n    })\n  );\n  return snapshot2;\n}\nasync function restoreSnapshot(driver, snapshot2, base = \"\") {\n  base = normalizeBaseKey(base);\n  await Promise.all(\n    Object.entries(snapshot2).map((e) => driver.setItem(base + e[0], e[1]))\n  );\n}\nfunction watch(driver, onChange, base) {\n  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {\n  };\n}\nasync function dispose(driver) {\n  if (typeof driver.dispose === \"function\") {\n    await asyncCall(driver.dispose);\n  }\n}\n\nconst builtinDrivers = {\n  \"azure-app-configuration\": \"unstorage/drivers/azure-app-configuration\",\n  \"azureAppConfiguration\": \"unstorage/drivers/azure-app-configuration\",\n  \"azure-cosmos\": \"unstorage/drivers/azure-cosmos\",\n  \"azureCosmos\": \"unstorage/drivers/azure-cosmos\",\n  \"azure-key-vault\": \"unstorage/drivers/azure-key-vault\",\n  \"azureKeyVault\": \"unstorage/drivers/azure-key-vault\",\n  \"azure-storage-blob\": \"unstorage/drivers/azure-storage-blob\",\n  \"azureStorageBlob\": \"unstorage/drivers/azure-storage-blob\",\n  \"azure-storage-table\": \"unstorage/drivers/azure-storage-table\",\n  \"azureStorageTable\": \"unstorage/drivers/azure-storage-table\",\n  \"capacitor-preferences\": \"unstorage/drivers/capacitor-preferences\",\n  \"capacitorPreferences\": \"unstorage/drivers/capacitor-preferences\",\n  \"cloudflare-kv-binding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  \"cloudflareKVBinding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  \"cloudflare-kv-http\": \"unstorage/drivers/cloudflare-kv-http\",\n  \"cloudflareKVHttp\": \"unstorage/drivers/cloudflare-kv-http\",\n  \"cloudflare-r2-binding\": \"unstorage/drivers/cloudflare-r2-binding\",\n  \"cloudflareR2Binding\": \"unstorage/drivers/cloudflare-r2-binding\",\n  \"db0\": \"unstorage/drivers/db0\",\n  \"deno-kv-node\": \"unstorage/drivers/deno-kv-node\",\n  \"denoKVNode\": \"unstorage/drivers/deno-kv-node\",\n  \"deno-kv\": \"unstorage/drivers/deno-kv\",\n  \"denoKV\": \"unstorage/drivers/deno-kv\",\n  \"fs-lite\": \"unstorage/drivers/fs-lite\",\n  \"fsLite\": \"unstorage/drivers/fs-lite\",\n  \"fs\": \"unstorage/drivers/fs\",\n  \"github\": \"unstorage/drivers/github\",\n  \"http\": \"unstorage/drivers/http\",\n  \"indexedb\": \"unstorage/drivers/indexedb\",\n  \"localstorage\": \"unstorage/drivers/localstorage\",\n  \"lru-cache\": \"unstorage/drivers/lru-cache\",\n  \"lruCache\": \"unstorage/drivers/lru-cache\",\n  \"memory\": \"unstorage/drivers/memory\",\n  \"mongodb\": \"unstorage/drivers/mongodb\",\n  \"netlify-blobs\": \"unstorage/drivers/netlify-blobs\",\n  \"netlifyBlobs\": \"unstorage/drivers/netlify-blobs\",\n  \"null\": \"unstorage/drivers/null\",\n  \"overlay\": \"unstorage/drivers/overlay\",\n  \"planetscale\": \"unstorage/drivers/planetscale\",\n  \"redis\": \"unstorage/drivers/redis\",\n  \"s3\": \"unstorage/drivers/s3\",\n  \"session-storage\": \"unstorage/drivers/session-storage\",\n  \"sessionStorage\": \"unstorage/drivers/session-storage\",\n  \"uploadthing\": \"unstorage/drivers/uploadthing\",\n  \"upstash\": \"unstorage/drivers/upstash\",\n  \"vercel-blob\": \"unstorage/drivers/vercel-blob\",\n  \"vercelBlob\": \"unstorage/drivers/vercel-blob\",\n  \"vercel-kv\": \"unstorage/drivers/vercel-kv\",\n  \"vercelKV\": \"unstorage/drivers/vercel-kv\"\n};\n\nexport { builtinDrivers, createStorage, defineDriver, filterKeyByBase, filterKeyByDepth, joinKeys, normalizeBaseKey, normalizeKey, restoreSnapshot, snapshot };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}