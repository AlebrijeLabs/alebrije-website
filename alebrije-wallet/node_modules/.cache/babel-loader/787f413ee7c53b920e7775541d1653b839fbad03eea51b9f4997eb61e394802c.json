{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nimport { LocalTracer } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\nconst DEFAULT_LOG_TYPE = \"transport\";\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nclass Transport {\n  constructor() {\n    var _this = this;\n    let {\n      context,\n      logType\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n    /**\n     * Send data to the device using the higher level API.\n     *\n     * @param {number} cla - The instruction class for the command.\n     * @param {number} ins - The instruction code for the command.\n     * @param {number} p1 - The first parameter for the instruction.\n     * @param {number} p2 - The second parameter for the instruction.\n     * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n     * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n     * @param {Object} options - Contains optional options for the exchange function\n     *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n     */\n    this.send = function (cla_1, ins_1, p1_1, p2_1) {\n      for (var _len = arguments.length, args_1 = new Array(_len > 4 ? _len - 4 : 0), _key2 = 4; _key2 < _len; _key2++) {\n        args_1[_key2 - 4] = arguments[_key2];\n      }\n      return __awaiter(_this, [cla_1, ins_1, p1_1, p2_1, ...args_1], void 0, function (cla, ins, p1, p2) {\n        var _this2 = this;\n        let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Buffer.alloc(0);\n        let statusList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [StatusCodes.OK];\n        let {\n          abortTimeoutMs\n        } = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n        return function* () {\n          const tracer = _this2.tracer.withUpdatedContext({\n            function: \"send\"\n          });\n          if (data.length >= 256) {\n            tracer.trace(\"data.length exceeded 256 bytes limit\", {\n              dataLength: data.length\n            });\n            throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n          }\n          tracer.trace(\"Starting an exchange\", {\n            abortTimeoutMs\n          });\n          const response = yield _this2.exchange(\n          // The size of the data is added in 1 byte just before `data`\n          Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]), {\n            abortTimeoutMs\n          });\n          tracer.trace(\"Received response from exchange\");\n          const sw = response.readUInt16BE(response.length - 2);\n          if (!statusList.some(s => s === sw)) {\n            throw new TransportStatusError(sw);\n          }\n          return response;\n        }();\n      });\n    };\n    this._appAPIlock = null;\n    this.tracer = new LocalTracer(logType !== null && logType !== void 0 ? logType : DEFAULT_LOG_TYPE, context);\n  }\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(_apdu) {\n    let {\n      abortTimeoutMs: _abortTimeoutMs\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    throw new Error(\"exchange not implemented\");\n  }\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus, observer) {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n    const main = () => __awaiter(this, void 0, void 0, function* () {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = yield this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    });\n    main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));\n    return {\n      unsubscribe\n    };\n  }\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key) {}\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close() {\n    return Promise.resolve();\n  }\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName, cb) {\n    this._events.on(eventName, cb);\n  }\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName, cb) {\n    this._events.removeListener(eventName, cb);\n  }\n  emit(event) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    this._events.emit(event, ...args);\n  }\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n  }\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create() {\n    let openTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;\n    let listenTimeout = arguments.length > 1 ? arguments[1] : undefined;\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout ? setTimeout(() => {\n        sub.unsubscribe();\n        reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n      }, listenTimeout) : null;\n    });\n  }\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  exchangeAtomicImpl(f) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tracer = this.tracer.withUpdatedContext({\n        function: \"exchangeAtomicImpl\",\n        unresponsiveTimeout: this.unresponsiveTimeout\n      });\n      if (this.exchangeBusyPromise) {\n        tracer.trace(\"Atomic exchange is already busy\");\n        throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n      }\n      // Sets the atomic guard\n      let resolveBusy;\n      const busyPromise = new Promise(r => {\n        resolveBusy = r;\n      });\n      this.exchangeBusyPromise = busyPromise;\n      // The device unresponsiveness handler\n      let unresponsiveReached = false;\n      const timeout = setTimeout(() => {\n        tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n          unresponsiveTimeout: this.unresponsiveTimeout\n        });\n        unresponsiveReached = true;\n        this.emit(\"unresponsive\");\n      }, this.unresponsiveTimeout);\n      try {\n        const res = yield f();\n        if (unresponsiveReached) {\n          tracer.trace(\"Device was unresponsive, emitting responsive\");\n          this.emit(\"responsive\");\n        }\n        return res;\n      } finally {\n        tracer.trace(\"Finalize, clearing busy guard\");\n        clearTimeout(timeout);\n        if (resolveBusy) resolveBusy();\n        this.exchangeBusyPromise = null;\n      }\n    });\n  }\n  decorateAppAPIMethods(self, methods, scrambleKey) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n    var _this3 = this;\n    return function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return __awaiter(_this3, void 0, void 0, function* () {\n        const {\n          _appAPIlock\n        } = this;\n        if (_appAPIlock) {\n          return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n        }\n        try {\n          this._appAPIlock = methodName;\n          this.setScrambleKey(scrambleKey);\n          return yield f.apply(ctx, args);\n        } finally {\n          this._appAPIlock = null;\n        }\n      });\n    };\n  }\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context) {\n    this.tracer = this.tracer.withContext(context);\n  }\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd) {\n    this.tracer.updateContext(contextToAdd);\n  }\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext() {\n    return this.tracer.getContext();\n  }\n}\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";\nexport default Transport;","map":{"version":3,"names":["EventEmitter","TransportRaceCondition","TransportError","StatusCodes","getAltStatusMessage","TransportStatusError","LocalTracer","DEFAULT_LOG_TYPE","Transport","constructor","_this","context","logType","arguments","length","undefined","exchangeTimeout","unresponsiveTimeout","deviceModel","_events","send","cla_1","ins_1","p1_1","p2_1","_len","args_1","Array","_key2","__awaiter","cla","ins","p1","p2","_this2","data","Buffer","alloc","statusList","OK","abortTimeoutMs","tracer","withUpdatedContext","function","trace","dataLength","response","exchange","concat","from","sw","readUInt16BE","some","s","_appAPIlock","_apdu","_abortTimeoutMs","Error","exchangeBulk","apdus","observer","unsubscribed","unsubscribe","main","apdu","r","status","next","then","complete","e","error","setScrambleKey","_key","close","Promise","resolve","on","eventName","cb","off","removeListener","emit","event","_len2","args","_key3","setDebugMode","console","warn","setExchangeTimeout","setExchangeUnresponsiveTimeout","create","openTimeout","listenTimeout","reject","found","sub","listen","listenTimeoutId","clearTimeout","open","descriptor","ErrorMessage_NoDeviceFound","setTimeout","ErrorMessage_ListenTimeout","exchangeAtomicImpl","f","exchangeBusyPromise","resolveBusy","busyPromise","unresponsiveReached","timeout","res","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","ctx","_this3","_len3","_key4","apply","setTraceContext","withContext","updateTraceContext","contextToAdd","updateContext","getTraceContext","getContext"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@ledgerhq/hw-transport/src/Transport.ts"],"sourcesContent":["import EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\nimport { LocalTracer, TraceContext, LogType } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n\nconst DEFAULT_LOG_TYPE = \"transport\";\n\n/**\n */\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\n/**\n */\nexport type Device = any; // Should be a union type of all possible Device object's shape\n\nexport type DescriptorEventType = \"add\" | \"remove\";\n/**\n * A \"descriptor\" is a parameter that is specific to the implementation, and can be an ID, file path, or URL.\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport interface DescriptorEvent<Descriptor> {\n  type: DescriptorEventType;\n  descriptor: Descriptor;\n  deviceModel?: DeviceModel | null | undefined;\n  device?: Device;\n}\n\n/**\n * Observer generic type, following the Observer pattern\n */\nexport type Observer<EventType, EventError = unknown> = Readonly<{\n  next: (event: EventType) => unknown;\n  error: (e: EventError) => unknown;\n  complete: () => unknown;\n}>;\n\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n  exchangeTimeout = 30000;\n  unresponsiveTimeout = 15000;\n  deviceModel: DeviceModel | null | undefined = null;\n  tracer: LocalTracer;\n\n  constructor({ context, logType }: { context?: TraceContext; logType?: LogType } = {}) {\n    this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);\n  }\n\n  /**\n   * Check if the transport is supported on the current platform/browser.\n   * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.\n   */\n  static readonly isSupported: () => Promise<boolean>;\n\n  /**\n   * List all available descriptors for the transport.\n   * For a better granularity, checkout `listen()`.\n   *\n   * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static readonly list: () => Promise<Array<any>>;\n\n  /**\n   * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.\n   * A DescriptorEvent is an object containing a \"descriptor\" and a \"type\" field. The \"type\" field can be \"add\" or \"remove\", and the \"descriptor\" field can be passed to the \"open\" method.\n   * The \"listen\" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.\n   * @param {Observer<DescriptorEvent<any>>} observer - An object with \"next\", \"error\", and \"complete\" functions, following the observer pattern.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop listening to descriptors.\n   * @example\n  const sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n  })\n   */\n  static readonly listen: (observer: Observer<DescriptorEvent<any>>) => Subscription;\n\n  /**\n   * Attempt to create a Transport instance with a specific descriptor.\n   * @param {any} descriptor - The descriptor to open the transport with.\n   * @param {number} timeout - An optional timeout for the transport connection.\n   * @param {TraceContext} context Optional tracing/log context\n   * @returns {Promise<Transport>} A promise that resolves with a Transport instance.\n   * @example\n  TransportFoo.open(descriptor).then(transport => ...)\n   */\n  static readonly open: (\n    descriptor?: any,\n    timeoutMs?: number,\n    context?: TraceContext,\n  ) => Promise<Transport>;\n\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(\n    _apdu: Buffer,\n    { abortTimeoutMs: _abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus: Buffer[], observer: Observer<Buffer>): Subscription {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n\n    const main = async () => {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = await this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    };\n\n    main().then(\n      () => !unsubscribed && observer.complete(),\n      e => !unsubscribed && observer.error(e),\n    );\n\n    return { unsubscribe };\n  }\n\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: any): void {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\",\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number): void {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number): void {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * Send data to the device using the higher level API.\n   *\n   * @param {number} cla - The instruction class for the command.\n   * @param {number} ins - The instruction code for the command.\n   * @param {number} p1 - The first parameter for the instruction.\n   * @param {number} p2 - The second parameter for the instruction.\n   * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n   * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK],\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n\n    if (data.length >= 256) {\n      tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\",\n      );\n    }\n\n    tracer.trace(\"Starting an exchange\", { abortTimeoutMs });\n    const response = await this.exchange(\n      // The size of the data is added in 1 byte just before `data`\n      Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]),\n      { abortTimeoutMs },\n    );\n    tracer.trace(\"Received response from exchange\");\n    const sw = response.readUInt16BE(response.length - 2);\n\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout?: number): Promise<Transport> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  // Blocks other exchange to happen concurrently\n  exchangeBusyPromise: Promise<void> | null | undefined;\n\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  async exchangeAtomicImpl<Output>(f: () => Promise<Output>): Promise<Output> {\n    const tracer = this.tracer.withUpdatedContext({\n      function: \"exchangeAtomicImpl\",\n      unresponsiveTimeout: this.unresponsiveTimeout,\n    });\n\n    if (this.exchangeBusyPromise) {\n      tracer.trace(\"Atomic exchange is already busy\");\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\",\n      );\n    }\n\n    // Sets the atomic guard\n    let resolveBusy;\n    const busyPromise: Promise<void> = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n\n    // The device unresponsiveness handler\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n        unresponsiveTimeout: this.unresponsiveTimeout,\n      });\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n\n    try {\n      const res = await f();\n\n      if (unresponsiveReached) {\n        tracer.trace(\"Device was unresponsive, emitting responsive\");\n        this.emit(\"responsive\");\n      }\n\n      return res;\n    } finally {\n      tracer.trace(\"Finalize, clearing busy guard\");\n\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  }\n\n  decorateAppAPIMethods(self: Record<string, any>, methods: Array<string>, scrambleKey: string) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  _appAPIlock: string | null = null;\n\n  decorateAppAPIMethod<R, A extends any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: any,\n    scrambleKey: string,\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"),\n        );\n      }\n\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context?: TraceContext) {\n    this.tracer = this.tracer.withContext(context);\n  }\n\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd: TraceContext) {\n    this.tracer.updateContext(contextToAdd);\n  }\n\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext(): TraceContext | undefined {\n    return this.tracer.getContext();\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,YAAY,MAAM,QAAQ;AAEjC,SACEC,sBAAsB,EACtBC,cAAc,EACdC,WAAW,EACXC,mBAAmB,EACnBC,oBAAoB,QACf,kBAAkB;AACzB,SAASC,WAAW,QAA+B,gBAAgB;AACnE,SAASJ,cAAc,EAAEG,oBAAoB,EAAEF,WAAW,EAAEC,mBAAmB;AAE/E,MAAMG,gBAAgB,GAAG,WAAW;AAoCpC;;;;;AAKA,MAAqBC,SAAS;EAM5BC,YAAA,EAAoF;IAAA,IAAAC,KAAA;IAAA,IAAxE;MAAEC,OAAO;MAAEC;IAAO,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAoD,EAAE;IALpF,KAAAG,eAAe,GAAG,KAAK;IACvB,KAAAC,mBAAmB,GAAG,KAAK;IAC3B,KAAAC,WAAW,GAAmC,IAAI;IAoIlD,KAAAC,OAAO,GAAG,IAAInB,YAAY,EAAE;IA+C5B;;;;;;;;;;;;;;IAcA,KAAAoB,IAAI,GAAG,UAAAC,KAAA,EAAAC,KAAA,EAAAC,IAAA,EAAAC,IAAA;MAAA,SAAAC,IAAA,GAAAZ,SAAA,CAAAC,MAAA,EAAAY,MAAA,OAAAC,KAAA,CAAAF,IAAA,OAAAA,IAAA,WAAAG,KAAA,MAAAA,KAAA,GAAAH,IAAA,EAAAG,KAAA;QAAAF,MAAA,CAAAE,KAAA,QAAAf,SAAA,CAAAe,KAAA;MAAA;MAAA,OAQcC,SAAA,CAAAnB,KAAA,GAAAW,KAAA,EAAAC,KAAA,EAAAC,IAAA,EAAAC,IAAA,KAAAE,MAAA,qBAPnBI,GAAW,EACXC,GAAW,EACXC,EAAU,EACVC,EAAU;QAAA,IAAAC,MAAA;QAAA,IACVC,IAAA,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAeuB,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;QAAA,IAC9BC,UAAA,GAAAzB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA4B,CAACV,WAAW,CAACoC,EAAE,CAAC;QAAA,IAC5C;UAAEC;QAAc,IAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAkC,EAAE;QAAA;UAEpD,MAAM4B,MAAM,GAAGP,MAAI,CAACO,MAAM,CAACC,kBAAkB,CAAC;YAAEC,QAAQ,EAAE;UAAM,CAAE,CAAC;UAEnE,IAAIR,IAAI,CAACrB,MAAM,IAAI,GAAG,EAAE;YACtB2B,MAAM,CAACG,KAAK,CAAC,sCAAsC,EAAE;cAAEC,UAAU,EAAEV,IAAI,CAACrB;YAAM,CAAE,CAAC;YACjF,MAAM,IAAIZ,cAAc,CACtB,2CAA2C,GAAGiC,IAAI,CAACrB,MAAM,EACzD,kBAAkB,CACnB;UACH;UAEA2B,MAAM,CAACG,KAAK,CAAC,sBAAsB,EAAE;YAAEJ;UAAc,CAAE,CAAC;UACxD,MAAMM,QAAQ,GAAG,MAAMZ,MAAI,CAACa,QAAQ;UAClC;UACAX,MAAM,CAACY,MAAM,CAAC,CAACZ,MAAM,CAACa,IAAI,CAAC,CAACnB,GAAG,EAAEC,GAAG,EAAEC,EAAE,EAAEC,EAAE,CAAC,CAAC,EAAEG,MAAM,CAACa,IAAI,CAAC,CAACd,IAAI,CAACrB,MAAM,CAAC,CAAC,EAAEqB,IAAI,CAAC,CAAC,EAClF;YAAEK;UAAc,CAAE,CACnB;UACDC,MAAM,CAACG,KAAK,CAAC,iCAAiC,CAAC;UAC/C,MAAMM,EAAE,GAAGJ,QAAQ,CAACK,YAAY,CAACL,QAAQ,CAAChC,MAAM,GAAG,CAAC,CAAC;UAErD,IAAI,CAACwB,UAAU,CAACc,IAAI,CAACC,CAAC,IAAIA,CAAC,KAAKH,EAAE,CAAC,EAAE;YACnC,MAAM,IAAI7C,oBAAoB,CAAC6C,EAAE,CAAC;UACpC;UAEA,OAAOJ,QAAQ;QACjB,CAAC;MAAA;IAAA;IAyGD,KAAAQ,WAAW,GAAkB,IAAI;IAvU/B,IAAI,CAACb,MAAM,GAAG,IAAInC,WAAW,CAACM,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAIL,gBAAgB,EAAEI,OAAO,CAAC;EACrE;EAsDA;;;;;;;;;EASAoC,QAAQA,CACNQ,KAAa,EACwD;IAAA,IAArE;MAAEf,cAAc,EAAEgB;IAAe,IAAA3C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAkC,EAAE;IAErE,MAAM,IAAI4C,KAAK,CAAC,0BAA0B,CAAC;EAC7C;EAEA;;;;;;;EAOAC,YAAYA,CAACC,KAAe,EAAEC,QAA0B;IACtD,IAAIC,YAAY,GAAG,KAAK;IACxB,MAAMC,WAAW,GAAGA,CAAA,KAAK;MACvBD,YAAY,GAAG,IAAI;IACrB,CAAC;IAED,MAAME,IAAI,GAAGA,CAAA,KAAWlC,SAAA;MACtB,IAAIgC,YAAY,EAAE;MAClB,KAAK,MAAMG,IAAI,IAAIL,KAAK,EAAE;QACxB,MAAMM,CAAC,GAAG,MAAM,IAAI,CAAClB,QAAQ,CAACiB,IAAI,CAAC;QACnC,IAAIH,YAAY,EAAE;QAClB,MAAMK,MAAM,GAAGD,CAAC,CAACd,YAAY,CAACc,CAAC,CAACnD,MAAM,GAAG,CAAC,CAAC;QAC3C,IAAIoD,MAAM,KAAK/D,WAAW,CAACoC,EAAE,EAAE;UAC7B,MAAM,IAAIlC,oBAAoB,CAAC6D,MAAM,CAAC;QACxC;QACAN,QAAQ,CAACO,IAAI,CAACF,CAAC,CAAC;MAClB;IACF,CAAC;IAEDF,IAAI,EAAE,CAACK,IAAI,CACT,MAAM,CAACP,YAAY,IAAID,QAAQ,CAACS,QAAQ,EAAE,EAC1CC,CAAC,IAAI,CAACT,YAAY,IAAID,QAAQ,CAACW,KAAK,CAACD,CAAC,CAAC,CACxC;IAED,OAAO;MAAER;IAAW,CAAE;EACxB;EAEA;;;;;;;;EAQAU,cAAcA,CAACC,IAAY,GAAG;EAE9B;;;;;;;;;EASAC,KAAKA,CAAA;IACH,OAAOC,OAAO,CAACC,OAAO,EAAE;EAC1B;EAIA;;;;;;;EAOAC,EAAEA,CAACC,SAAiB,EAAEC,EAAgC;IACpD,IAAI,CAAC5D,OAAO,CAAC0D,EAAE,CAACC,SAAS,EAAEC,EAAE,CAAC;EAChC;EAEA;;;EAGAC,GAAGA,CAACF,SAAiB,EAAEC,EAAgC;IACrD,IAAI,CAAC5D,OAAO,CAAC8D,cAAc,CAACH,SAAS,EAAEC,EAAE,CAAC;EAC5C;EAEAG,IAAIA,CAACC,KAAa,EAAc;IAAA,SAAAC,KAAA,GAAAvE,SAAA,CAAAC,MAAA,EAATuE,IAAS,OAAA1D,KAAA,CAAAyD,KAAA,OAAAA,KAAA,WAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;MAATD,IAAS,CAAAC,KAAA,QAAAzE,SAAA,CAAAyE,KAAA;IAAA;IAC9B,IAAI,CAACnE,OAAO,CAAC+D,IAAI,CAACC,KAAK,EAAE,GAAGE,IAAI,CAAC;EACnC;EAEA;;;EAGAE,YAAYA,CAAA;IACVC,OAAO,CAACC,IAAI,CACV,8FAA8F,CAC/F;EACH;EAEA;;;EAGAC,kBAAkBA,CAAC1E,eAAuB;IACxC,IAAI,CAACA,eAAe,GAAGA,eAAe;EACxC;EAEA;;;EAGA2E,8BAA8BA,CAAC1E,mBAA2B;IACxD,IAAI,CAACA,mBAAmB,GAAGA,mBAAmB;EAChD;EAmDA;;;;;;;EAOA,OAAO2E,MAAMA,CAAA,EAA2C;IAAA,IAA1CC,WAAW,GAAAhF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAAA,IAAEiF,aAAsB,GAAAjF,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IACtD,OAAO,IAAI4D,OAAO,CAAC,CAACC,OAAO,EAAEmB,MAAM,KAAI;MACrC,IAAIC,KAAK,GAAG,KAAK;MACjB,MAAMC,GAAG,GAAG,IAAI,CAACC,MAAM,CAAC;QACtB/B,IAAI,EAAEG,CAAC,IAAG;UACR0B,KAAK,GAAG,IAAI;UACZ,IAAIC,GAAG,EAAEA,GAAG,CAACnC,WAAW,EAAE;UAC1B,IAAIqC,eAAe,EAAEC,YAAY,CAACD,eAAe,CAAC;UAClD,IAAI,CAACE,IAAI,CAAC/B,CAAC,CAACgC,UAAU,EAAET,WAAW,CAAC,CAACzB,IAAI,CAACQ,OAAO,EAAEmB,MAAM,CAAC;QAC5D,CAAC;QACDxB,KAAK,EAAED,CAAC,IAAG;UACT,IAAI6B,eAAe,EAAEC,YAAY,CAACD,eAAe,CAAC;UAClDJ,MAAM,CAACzB,CAAC,CAAC;QACX,CAAC;QACDD,QAAQ,EAAEA,CAAA,KAAK;UACb,IAAI8B,eAAe,EAAEC,YAAY,CAACD,eAAe,CAAC;UAElD,IAAI,CAACH,KAAK,EAAE;YACVD,MAAM,CAAC,IAAI7F,cAAc,CAAC,IAAI,CAACqG,0BAA0B,EAAE,eAAe,CAAC,CAAC;UAC9E;QACF;OACD,CAAC;MACF,MAAMJ,eAAe,GAAGL,aAAa,GACjCU,UAAU,CAAC,MAAK;QACdP,GAAG,CAACnC,WAAW,EAAE;QACjBiC,MAAM,CAAC,IAAI7F,cAAc,CAAC,IAAI,CAACuG,0BAA0B,EAAE,eAAe,CAAC,CAAC;MAC9E,CAAC,EAAEX,aAAa,CAAC,GACjB,IAAI;IACV,CAAC,CAAC;EACJ;EAKA;;;;;;;;EAQMY,kBAAkBA,CAASC,CAAwB;;MACvD,MAAMlE,MAAM,GAAG,IAAI,CAACA,MAAM,CAACC,kBAAkB,CAAC;QAC5CC,QAAQ,EAAE,oBAAoB;QAC9B1B,mBAAmB,EAAE,IAAI,CAACA;OAC3B,CAAC;MAEF,IAAI,IAAI,CAAC2F,mBAAmB,EAAE;QAC5BnE,MAAM,CAACG,KAAK,CAAC,iCAAiC,CAAC;QAC/C,MAAM,IAAI3C,sBAAsB,CAC9B,+EAA+E,CAChF;MACH;MAEA;MACA,IAAI4G,WAAW;MACf,MAAMC,WAAW,GAAkB,IAAInC,OAAO,CAACV,CAAC,IAAG;QACjD4C,WAAW,GAAG5C,CAAC;MACjB,CAAC,CAAC;MACF,IAAI,CAAC2C,mBAAmB,GAAGE,WAAW;MAEtC;MACA,IAAIC,mBAAmB,GAAG,KAAK;MAC/B,MAAMC,OAAO,GAAGR,UAAU,CAAC,MAAK;QAC9B/D,MAAM,CAACG,KAAK,CAAC,0DAA0D,EAAE;UACvE3B,mBAAmB,EAAE,IAAI,CAACA;SAC3B,CAAC;QACF8F,mBAAmB,GAAG,IAAI;QAC1B,IAAI,CAAC7B,IAAI,CAAC,cAAc,CAAC;MAC3B,CAAC,EAAE,IAAI,CAACjE,mBAAmB,CAAC;MAE5B,IAAI;QACF,MAAMgG,GAAG,GAAG,MAAMN,CAAC,EAAE;QAErB,IAAII,mBAAmB,EAAE;UACvBtE,MAAM,CAACG,KAAK,CAAC,8CAA8C,CAAC;UAC5D,IAAI,CAACsC,IAAI,CAAC,YAAY,CAAC;QACzB;QAEA,OAAO+B,GAAG;MACZ,CAAC,SAAS;QACRxE,MAAM,CAACG,KAAK,CAAC,+BAA+B,CAAC;QAE7CwD,YAAY,CAACY,OAAO,CAAC;QACrB,IAAIH,WAAW,EAAEA,WAAW,EAAE;QAC9B,IAAI,CAACD,mBAAmB,GAAG,IAAI;MACjC;IACF,CAAC;;EAEDM,qBAAqBA,CAACC,IAAyB,EAAEC,OAAsB,EAAEC,WAAmB;IAC1F,KAAK,MAAMC,UAAU,IAAIF,OAAO,EAAE;MAChCD,IAAI,CAACG,UAAU,CAAC,GAAG,IAAI,CAACC,oBAAoB,CAACD,UAAU,EAAEH,IAAI,CAACG,UAAU,CAAC,EAAEH,IAAI,EAAEE,WAAW,CAAC;IAC/F;EACF;EAIAE,oBAAoBA,CAClBD,UAAkB,EAClBX,CAA6B,EAC7Ba,GAAQ,EACRH,WAAmB;IAAA,IAAAI,MAAA;IAEnB,OAAO;MAAA,SAAAC,KAAA,GAAA7G,SAAA,CAAAC,MAAA,EAAUuE,IAAI,OAAA1D,KAAA,CAAA+F,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJtC,IAAI,CAAAsC,KAAA,IAAA9G,SAAA,CAAA8G,KAAA;MAAA;MAAA,OAAI9F,SAAA,CAAA4F,MAAA;QACvB,MAAM;UAAEnE;QAAW,CAAE,GAAG,IAAI;QAE5B,IAAIA,WAAW,EAAE;UACf,OAAOqB,OAAO,CAACoB,MAAM,CACnB,IAAI7F,cAAc,CAAC,8BAA8B,GAAGoD,WAAW,GAAG,GAAG,EAAE,iBAAiB,CAAC,CAC1F;QACH;QAEA,IAAI;UACF,IAAI,CAACA,WAAW,GAAGgE,UAAU;UAC7B,IAAI,CAAC9C,cAAc,CAAC6C,WAAW,CAAC;UAChC,OAAO,MAAMV,CAAC,CAACiB,KAAK,CAACJ,GAAG,EAAEnC,IAAI,CAAC;QACjC,CAAC,SAAS;UACR,IAAI,CAAC/B,WAAW,GAAG,IAAI;QACzB;MACF,CAAC;IAAA;EACH;EAEA;;;;;;;;EAQAuE,eAAeA,CAAClH,OAAsB;IACpC,IAAI,CAAC8B,MAAM,GAAG,IAAI,CAACA,MAAM,CAACqF,WAAW,CAACnH,OAAO,CAAC;EAChD;EAEA;;;;;;;EAOAoH,kBAAkBA,CAACC,YAA0B;IAC3C,IAAI,CAACvF,MAAM,CAACwF,aAAa,CAACD,YAAY,CAAC;EACzC;EAEA;;;EAGAE,eAAeA,CAAA;IACb,OAAO,IAAI,CAACzF,MAAM,CAAC0F,UAAU,EAAE;EACjC;;AAEO3H,SAAA,CAAAiG,0BAA0B,GAAG,kCAAkC;AAC/DjG,SAAA,CAAA+F,0BAA0B,GAAG,wBAAwB;eAxYzC/F,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}