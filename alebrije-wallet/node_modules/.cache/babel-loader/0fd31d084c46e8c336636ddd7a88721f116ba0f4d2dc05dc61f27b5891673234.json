{"ast":null,"code":"import { createEncoder, getEncodedSize, createDecoder, combineCodec, assertByteArrayHasEnoughBytesForCodec, transformEncoder, transformDecoder, containsBytes, isFixedSize, assertIsFixedSize, fixEncoderSize, fixDecoderSize } from '@solana/codecs-core';\nimport { getU32Encoder, getU32Decoder, getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SolanaError, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__INVALID_CONSTANT, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE } from '@solana/errors';\n\n// src/array.ts\nfunction assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {\n  if (expected !== actual) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n      actual,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction maxCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : Math.max(all, size), 0);\n}\nfunction sumCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);\n}\nfunction getFixedSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : null;\n}\nfunction getMaxSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n\n// src/array.ts\nfunction getArrayEncoder(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const size = config.size ?? getU32Encoder();\n  const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize !== null ? {\n      fixedSize\n    } : {\n      getSizeFromValue: array => {\n        const prefixSize = typeof size === \"object\" ? getEncodedSize(array.length, size) : 0;\n        return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n      },\n      maxSize\n    }),\n    write: (array, bytes, offset) => {\n      if (typeof size === \"number\") {\n        assertValidNumberOfItemsForCodec(\"array\", size, array.length);\n      }\n      if (typeof size === \"object\") {\n        offset = size.write(array.length, bytes, offset);\n      }\n      array.forEach(value => {\n        offset = item.write(value, bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getArrayDecoder(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const size = config.size ?? getU32Decoder();\n  const itemSize = getFixedSize(item);\n  const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize !== null ? {\n      fixedSize\n    } : {\n      maxSize\n    }),\n    read: (bytes, offset) => {\n      const array = [];\n      if (typeof size === \"object\" && bytes.slice(offset).length === 0) {\n        return [array, offset];\n      }\n      if (size === \"remainder\") {\n        while (offset < bytes.length) {\n          const [value, newOffset2] = item.read(bytes, offset);\n          offset = newOffset2;\n          array.push(value);\n        }\n        return [array, offset];\n      }\n      const [resolvedSize, newOffset] = typeof size === \"number\" ? [size, offset] : size.read(bytes, offset);\n      offset = newOffset;\n      for (let i = 0; i < resolvedSize; i += 1) {\n        const [value, newOffset2] = item.read(bytes, offset);\n        offset = newOffset2;\n        array.push(value);\n      }\n      return [array, offset];\n    }\n  });\n}\nfunction getArrayCodec(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return combineCodec(getArrayEncoder(item, config), getArrayDecoder(item, config));\n}\nfunction computeArrayLikeCodecSize(size, itemSize) {\n  if (typeof size !== \"number\") return null;\n  if (size === 0) return 0;\n  return itemSize === null ? null : itemSize * size;\n}\nfunction getBitArrayEncoder(size) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const parsedConfig = typeof config === \"boolean\" ? {\n    backward: config\n  } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createEncoder({\n    fixedSize: size,\n    write(value, bytes, offset) {\n      const bytesToAdd = [];\n      for (let i = 0; i < size; i += 1) {\n        let byte = 0;\n        for (let j = 0; j < 8; j += 1) {\n          const feature = Number(value[i * 8 + j] ?? 0);\n          byte |= feature << (backward ? j : 7 - j);\n        }\n        if (backward) {\n          bytesToAdd.unshift(byte);\n        } else {\n          bytesToAdd.push(byte);\n        }\n      }\n      bytes.set(bytesToAdd, offset);\n      return size;\n    }\n  });\n}\nfunction getBitArrayDecoder(size) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const parsedConfig = typeof config === \"boolean\" ? {\n    backward: config\n  } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createDecoder({\n    fixedSize: size,\n    read(bytes, offset) {\n      assertByteArrayHasEnoughBytesForCodec(\"bitArray\", size, bytes, offset);\n      const booleans = [];\n      let slice = bytes.slice(offset, offset + size);\n      slice = backward ? slice.reverse() : slice;\n      slice.forEach(byte => {\n        for (let i = 0; i < 8; i += 1) {\n          if (backward) {\n            booleans.push(Boolean(byte & 1));\n            byte >>= 1;\n          } else {\n            booleans.push(Boolean(byte & 128));\n            byte <<= 1;\n          }\n        }\n      });\n      return [booleans, offset + size];\n    }\n  });\n}\nfunction getBitArrayCodec(size) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\nfunction getBooleanEncoder() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return transformEncoder(config.size ?? getU8Encoder(), value => value ? 1 : 0);\n}\nfunction getBooleanDecoder() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return transformDecoder(config.size ?? getU8Decoder(), value => Number(value) === 1);\n}\nfunction getBooleanCodec() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\nfunction getBytesEncoder() {\n  return createEncoder({\n    getSizeFromValue: value => value.length,\n    write: (value, bytes, offset) => {\n      bytes.set(value, offset);\n      return offset + value.length;\n    }\n  });\n}\nfunction getBytesDecoder() {\n  return createDecoder({\n    read: (bytes, offset) => {\n      const slice = bytes.slice(offset);\n      return [slice, offset + slice.length];\n    }\n  });\n}\nfunction getBytesCodec() {\n  return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nfunction getConstantEncoder(constant) {\n  return createEncoder({\n    fixedSize: constant.length,\n    write: (_, bytes, offset) => {\n      bytes.set(constant, offset);\n      return offset + constant.length;\n    }\n  });\n}\nfunction getConstantDecoder(constant) {\n  return createDecoder({\n    fixedSize: constant.length,\n    read: (bytes, offset) => {\n      const base16 = getBase16Decoder();\n      if (!containsBytes(bytes, constant, offset)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n          constant,\n          data: bytes,\n          hexConstant: base16.decode(constant),\n          hexData: base16.decode(bytes),\n          offset\n        });\n      }\n      return [void 0, offset + constant.length];\n    }\n  });\n}\nfunction getConstantCodec(constant) {\n  return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\nfunction getTupleEncoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize === null ? {\n      getSizeFromValue: value => items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : {\n      fixedSize\n    }),\n    write: (value, bytes, offset) => {\n      assertValidNumberOfItemsForCodec(\"tuple\", items.length, value.length);\n      items.forEach((item, index) => {\n        offset = item.write(value[index], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getTupleDecoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize === null ? {\n      maxSize\n    } : {\n      fixedSize\n    }),\n    read: (bytes, offset) => {\n      const values = [];\n      items.forEach(item => {\n        const [newValue, newOffset] = item.read(bytes, offset);\n        values.push(newValue);\n        offset = newOffset;\n      });\n      return [values, offset];\n    }\n  });\n}\nfunction getTupleCodec(items) {\n  return combineCodec(getTupleEncoder(items), getTupleDecoder(items));\n}\nfunction getUnionEncoder(variants, getIndexFromValue) {\n  const fixedSize = getUnionFixedSize(variants);\n  const write = (variant, bytes, offset) => {\n    const index = getIndexFromValue(variant);\n    assertValidVariantIndex(variants, index);\n    return variants[index].write(variant, bytes, offset);\n  };\n  if (fixedSize !== null) {\n    return createEncoder({\n      fixedSize,\n      write\n    });\n  }\n  const maxSize = getUnionMaxSize(variants);\n  return createEncoder({\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    getSizeFromValue: variant => {\n      const index = getIndexFromValue(variant);\n      assertValidVariantIndex(variants, index);\n      return getEncodedSize(variant, variants[index]);\n    },\n    write\n  });\n}\nfunction getUnionDecoder(variants, getIndexFromBytes) {\n  const fixedSize = getUnionFixedSize(variants);\n  const read = (bytes, offset) => {\n    const index = getIndexFromBytes(bytes, offset);\n    assertValidVariantIndex(variants, index);\n    return variants[index].read(bytes, offset);\n  };\n  if (fixedSize !== null) {\n    return createDecoder({\n      fixedSize,\n      read\n    });\n  }\n  const maxSize = getUnionMaxSize(variants);\n  return createDecoder({\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    read\n  });\n}\nfunction getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {\n  return combineCodec(getUnionEncoder(variants, getIndexFromValue), getUnionDecoder(variants, getIndexFromBytes));\n}\nfunction assertValidVariantIndex(variants, index) {\n  if (typeof variants[index] === \"undefined\") {\n    throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n      maxRange: variants.length - 1,\n      minRange: 0,\n      variant: index\n    });\n  }\n}\nfunction getUnionFixedSize(variants) {\n  if (variants.length === 0) return 0;\n  if (!isFixedSize(variants[0])) return null;\n  const variantSize = variants[0].fixedSize;\n  const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n  return sameSizedVariants ? variantSize : null;\n}\nfunction getUnionMaxSize(variants) {\n  return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n\n// src/discriminated-union.ts\nfunction getDiscriminatedUnionEncoder(variants) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const discriminatorProperty = config.discriminator ?? \"__kind\";\n  const prefix = config.size ?? getU8Encoder();\n  return getUnionEncoder(variants.map((_ref, index) => {\n    let [, variant] = _ref;\n    return transformEncoder(getTupleEncoder([prefix, variant]), value => [index, value]);\n  }), value => getVariantDiscriminator(variants, value[discriminatorProperty]));\n}\nfunction getDiscriminatedUnionDecoder(variants) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const discriminatorProperty = config.discriminator ?? \"__kind\";\n  const prefix = config.size ?? getU8Decoder();\n  return getUnionDecoder(variants.map(_ref2 => {\n    let [discriminator, variant] = _ref2;\n    return transformDecoder(getTupleDecoder([prefix, variant]), _ref3 => {\n      let [, value] = _ref3;\n      return {\n        [discriminatorProperty]: discriminator,\n        ...value\n      };\n    });\n  }), (bytes, offset) => Number(prefix.read(bytes, offset)[0]));\n}\nfunction getDiscriminatedUnionCodec(variants) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return combineCodec(getDiscriminatedUnionEncoder(variants, config), getDiscriminatedUnionDecoder(variants, config));\n}\nfunction getVariantDiscriminator(variants, discriminatorValue) {\n  const discriminator = variants.findIndex(_ref4 => {\n    let [key] = _ref4;\n    return discriminatorValue === key;\n  });\n  if (discriminator < 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n      value: discriminatorValue,\n      variants: variants.map(_ref5 => {\n        let [key] = _ref5;\n        return key;\n      })\n    });\n  }\n  return discriminator;\n}\nvar getDataEnumEncoder = getDiscriminatedUnionEncoder;\nvar getDataEnumDecoder = getDiscriminatedUnionDecoder;\nvar getDataEnumCodec = getDiscriminatedUnionCodec;\n\n// src/enum-helpers.ts\nfunction getEnumStats(constructor) {\n  const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === \"number\"))].sort();\n  const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));\n  const enumKeys = Object.keys(enumRecord);\n  const enumValues = Object.values(enumRecord);\n  const stringValues = [... /* @__PURE__ */new Set([...enumKeys, ...enumValues.filter(v => typeof v === \"string\")])];\n  return {\n    enumKeys,\n    enumRecord,\n    enumValues,\n    numericalValues,\n    stringValues\n  };\n}\nfunction getEnumIndexFromVariant(_ref6) {\n  let {\n    enumKeys,\n    enumValues,\n    variant\n  } = _ref6;\n  const valueIndex = findLastIndex(enumValues, value => value === variant);\n  if (valueIndex >= 0) return valueIndex;\n  return enumKeys.findIndex(key => key === variant);\n}\nfunction getEnumIndexFromDiscriminator(_ref7) {\n  let {\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators\n  } = _ref7;\n  if (!useValuesAsDiscriminators) {\n    return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n  }\n  return findLastIndex(enumValues, value => value === discriminator);\n}\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n  while (l--) {\n    if (predicate(array[l], l, array)) return l;\n  }\n  return -1;\n}\nfunction formatNumericalValues(values) {\n  if (values.length === 0) return \"\";\n  let range = [values[0], values[0]];\n  const ranges = [];\n  for (let index = 1; index < values.length; index++) {\n    const value = values[index];\n    if (range[1] + 1 === value) {\n      range[1] = value;\n    } else {\n      ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n      range = [value, value];\n    }\n  }\n  ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n  return ranges.join(\", \");\n}\n\n// src/enum.ts\nfunction getEnumEncoder(constructor) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const prefix = config.size ?? getU8Encoder();\n  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n  const {\n    enumKeys,\n    enumValues,\n    numericalValues,\n    stringValues\n  } = getEnumStats(constructor);\n  if (useValuesAsDiscriminators && enumValues.some(value => typeof value === \"string\")) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n      stringValues: enumValues.filter(v => typeof v === \"string\")\n    });\n  }\n  return transformEncoder(prefix, variant => {\n    const index = getEnumIndexFromVariant({\n      enumKeys,\n      enumValues,\n      variant\n    });\n    if (index < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n        formattedNumericalValues: formatNumericalValues(numericalValues),\n        numericalValues,\n        stringValues,\n        variant\n      });\n    }\n    return useValuesAsDiscriminators ? enumValues[index] : index;\n  });\n}\nfunction getEnumDecoder(constructor) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const prefix = config.size ?? getU8Decoder();\n  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n  const {\n    enumKeys,\n    enumValues,\n    numericalValues\n  } = getEnumStats(constructor);\n  if (useValuesAsDiscriminators && enumValues.some(value => typeof value === \"string\")) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n      stringValues: enumValues.filter(v => typeof v === \"string\")\n    });\n  }\n  return transformDecoder(prefix, value => {\n    const discriminator = Number(value);\n    const index = getEnumIndexFromDiscriminator({\n      discriminator,\n      enumKeys,\n      enumValues,\n      useValuesAsDiscriminators\n    });\n    if (index < 0) {\n      const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n        discriminator,\n        formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n        validDiscriminators\n      });\n    }\n    return enumValues[index];\n  });\n}\nfunction getEnumCodec(constructor) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\nvar getScalarEnumEncoder = getEnumEncoder;\nvar getScalarEnumDecoder = getEnumDecoder;\nvar getScalarEnumCodec = getEnumCodec;\nfunction getHiddenPrefixEncoder(encoder, prefixedEncoders) {\n  return transformEncoder(getTupleEncoder([...prefixedEncoders, encoder]), value => [...prefixedEncoders.map(() => void 0), value]);\n}\nfunction getHiddenPrefixDecoder(decoder, prefixedDecoders) {\n  return transformDecoder(getTupleDecoder([...prefixedDecoders, decoder]), tuple => tuple[tuple.length - 1]);\n}\nfunction getHiddenPrefixCodec(codec, prefixedCodecs) {\n  return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\nfunction getHiddenSuffixEncoder(encoder, suffixedEncoders) {\n  return transformEncoder(getTupleEncoder([encoder, ...suffixedEncoders]), value => [value, ...suffixedEncoders.map(() => void 0)]);\n}\nfunction getHiddenSuffixDecoder(decoder, suffixedDecoders) {\n  return transformDecoder(getTupleDecoder([decoder, ...suffixedDecoders]), tuple => tuple[0]);\n}\nfunction getHiddenSuffixCodec(codec, suffixedCodecs) {\n  return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\nfunction getMapEncoder(key, value) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return transformEncoder(getArrayEncoder(getTupleEncoder([key, value]), config), map => [...map.entries()]);\n}\nfunction getMapDecoder(key, value) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return transformDecoder(getArrayDecoder(getTupleDecoder([key, value]), config), entries => new Map(entries));\n}\nfunction getMapCodec(key, value) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return combineCodec(getMapEncoder(key, value, config), getMapDecoder(key, value, config));\n}\nfunction getUnitEncoder() {\n  return createEncoder({\n    fixedSize: 0,\n    write: (_value, _bytes, offset) => offset\n  });\n}\nfunction getUnitDecoder() {\n  return createDecoder({\n    fixedSize: 0,\n    read: (_bytes, offset) => [void 0, offset]\n  });\n}\nfunction getUnitCodec() {\n  return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n\n// src/nullable.ts\nfunction getNullableEncoder(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformEncoder(getUnitEncoder(), _boolean => void 0);\n    }\n    return getBooleanEncoder({\n      size: config.prefix ?? getU8Encoder()\n    });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitEncoder();\n    }\n    return getConstantEncoder(config.noneValue);\n  })();\n  return getUnionEncoder([transformEncoder(getTupleEncoder([prefix, noneValue]), _value => [false, void 0]), transformEncoder(getTupleEncoder([prefix, item]), value => [true, value])], variant => Number(variant !== null));\n}\nfunction getNullableDecoder(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformDecoder(getUnitDecoder(), () => false);\n    }\n    return getBooleanDecoder({\n      size: config.prefix ?? getU8Decoder()\n    });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitDecoder();\n    }\n    return getConstantDecoder(config.noneValue);\n  })();\n  return getUnionDecoder([transformDecoder(getTupleDecoder([prefix, noneValue]), () => null), transformDecoder(getTupleDecoder([prefix, item]), _ref8 => {\n    let [, value] = _ref8;\n    return value;\n  })], (bytes, offset) => {\n    if (config.prefix === null && !config.noneValue) {\n      return Number(offset < bytes.length);\n    }\n    if (config.prefix === null && config.noneValue != null) {\n      const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n      return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n    }\n    return Number(prefix.read(bytes, offset)[0]);\n  });\n}\nfunction getNullableCodec(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return combineCodec(getNullableEncoder(item, config), getNullableDecoder(item, config));\n}\nfunction getSetEncoder(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return transformEncoder(getArrayEncoder(item, config), set => [...set]);\n}\nfunction getSetDecoder(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return transformDecoder(getArrayDecoder(item, config), entries => new Set(entries));\n}\nfunction getSetCodec(item) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return combineCodec(getSetEncoder(item, config), getSetDecoder(item, config));\n}\nfunction getStructEncoder(fields) {\n  const fieldCodecs = fields.map(_ref9 => {\n    let [, codec] = _ref9;\n    return codec;\n  });\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize === null ? {\n      getSizeFromValue: value => fields.map(_ref10 => {\n        let [key, codec] = _ref10;\n        return getEncodedSize(value[key], codec);\n      }).reduce((all, one) => all + one, 0),\n      maxSize\n    } : {\n      fixedSize\n    }),\n    write: (struct, bytes, offset) => {\n      fields.forEach(_ref11 => {\n        let [key, codec] = _ref11;\n        offset = codec.write(struct[key], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getStructDecoder(fields) {\n  const fieldCodecs = fields.map(_ref12 => {\n    let [, codec] = _ref12;\n    return codec;\n  });\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize === null ? {\n      maxSize\n    } : {\n      fixedSize\n    }),\n    read: (bytes, offset) => {\n      const struct = {};\n      fields.forEach(_ref13 => {\n        let [key, codec] = _ref13;\n        const [value, newOffset] = codec.read(bytes, offset);\n        offset = newOffset;\n        struct[key] = value;\n      });\n      return [struct, offset];\n    }\n  });\n}\nfunction getStructCodec(fields) {\n  return combineCodec(getStructEncoder(fields), getStructDecoder(fields));\n}\nexport { assertValidNumberOfItemsForCodec, getArrayCodec, getArrayDecoder, getArrayEncoder, getBitArrayCodec, getBitArrayDecoder, getBitArrayEncoder, getBooleanCodec, getBooleanDecoder, getBooleanEncoder, getBytesCodec, getBytesDecoder, getBytesEncoder, getConstantCodec, getConstantDecoder, getConstantEncoder, getDataEnumCodec, getDataEnumDecoder, getDataEnumEncoder, getDiscriminatedUnionCodec, getDiscriminatedUnionDecoder, getDiscriminatedUnionEncoder, getEnumCodec, getEnumDecoder, getEnumEncoder, getHiddenPrefixCodec, getHiddenPrefixDecoder, getHiddenPrefixEncoder, getHiddenSuffixCodec, getHiddenSuffixDecoder, getHiddenSuffixEncoder, getMapCodec, getMapDecoder, getMapEncoder, getNullableCodec, getNullableDecoder, getNullableEncoder, getScalarEnumCodec, getScalarEnumDecoder, getScalarEnumEncoder, getSetCodec, getSetDecoder, getSetEncoder, getStructCodec, getStructDecoder, getStructEncoder, getTupleCodec, getTupleDecoder, getTupleEncoder, getUnionCodec, getUnionDecoder, getUnionEncoder, getUnitCodec, getUnitDecoder, getUnitEncoder };\n\n//# sourceMappingURL=index.browser.mjs.map","map":{"version":3,"names":["assertValidNumberOfItemsForCodec","codecDescription","expected","actual","SolanaError","SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS","maxCodecSizes","sizes","reduce","all","size","Math","max","sumCodecSizes","getFixedSize","codec","isFixedSize","fixedSize","getMaxSize","maxSize","getArrayEncoder","item","config","arguments","length","undefined","getU32Encoder","computeArrayLikeCodecSize","createEncoder","getSizeFromValue","array","prefixSize","getEncodedSize","value","write","bytes","offset","forEach","getArrayDecoder","getU32Decoder","itemSize","createDecoder","read","slice","newOffset2","push","resolvedSize","newOffset","i","getArrayCodec","combineCodec","getBitArrayEncoder","parsedConfig","backward","bytesToAdd","byte","j","feature","Number","unshift","set","getBitArrayDecoder","assertByteArrayHasEnoughBytesForCodec","booleans","reverse","Boolean","getBitArrayCodec","getBooleanEncoder","transformEncoder","getU8Encoder","getBooleanDecoder","transformDecoder","getU8Decoder","getBooleanCodec","getBytesEncoder","getBytesDecoder","getBytesCodec","getBase16Decoder","str","toString","padStart","getConstantEncoder","constant","_","getConstantDecoder","base16","containsBytes","SOLANA_ERROR__CODECS__INVALID_CONSTANT","data","hexConstant","decode","hexData","getConstantCodec","getTupleEncoder","items","map","index","one","getTupleDecoder","values","newValue","getTupleCodec","getUnionEncoder","variants","getIndexFromValue","getUnionFixedSize","variant","assertValidVariantIndex","getUnionMaxSize","getUnionDecoder","getIndexFromBytes","getUnionCodec","SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE","maxRange","minRange","variantSize","sameSizedVariants","every","getDiscriminatedUnionEncoder","discriminatorProperty","discriminator","prefix","_ref","getVariantDiscriminator","getDiscriminatedUnionDecoder","_ref2","_ref3","getDiscriminatedUnionCodec","discriminatorValue","findIndex","_ref4","key","SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT","_ref5","getDataEnumEncoder","getDataEnumDecoder","getDataEnumCodec","getEnumStats","constructor","numericalValues","Set","Object","filter","v","sort","enumRecord","fromEntries","entries","enumKeys","keys","enumValues","stringValues","getEnumIndexFromVariant","_ref6","valueIndex","findLastIndex","getEnumIndexFromDiscriminator","_ref7","useValuesAsDiscriminators","predicate","l","formatNumericalValues","range","ranges","join","getEnumEncoder","some","SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS","SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT","formattedNumericalValues","getEnumDecoder","validDiscriminators","Array","SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE","formattedValidDiscriminators","getEnumCodec","getScalarEnumEncoder","getScalarEnumDecoder","getScalarEnumCodec","getHiddenPrefixEncoder","encoder","prefixedEncoders","getHiddenPrefixDecoder","decoder","prefixedDecoders","tuple","getHiddenPrefixCodec","prefixedCodecs","getHiddenSuffixEncoder","suffixedEncoders","getHiddenSuffixDecoder","suffixedDecoders","getHiddenSuffixCodec","suffixedCodecs","getMapEncoder","getMapDecoder","Map","getMapCodec","getUnitEncoder","_value","_bytes","getUnitDecoder","getUnitCodec","getNullableEncoder","_boolean","noneValue","assertIsFixedSize","fixEncoderSize","getNullableDecoder","fixDecoderSize","_ref8","zeroValue","Uint8Array","fill","getNullableCodec","getSetEncoder","getSetDecoder","getSetCodec","getStructEncoder","fields","fieldCodecs","_ref9","_ref10","struct","_ref11","getStructDecoder","_ref12","_ref13","getStructCodec"],"sources":["/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/assertions.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/utils.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/array.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/bit-array.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/boolean.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/bytes.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-strings/src/base16.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/constant.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/tuple.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/union.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/discriminated-union.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/enum-helpers.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/enum.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/hidden-prefix.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/hidden-suffix.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/map.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/unit.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/nullable.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/set.ts","/Users/rastavo/alebrije-project/alebrije-wallet/node_modules/@solana/codecs-data-structures/src/struct.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type — i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Represents all the size options for array-like codecs\n * — i.e. `array`, `map` and `set`.\n *\n * It can be one of the following:\n * - a {@link NumberCodec} that prefixes its content with its size.\n * - a fixed number of items.\n * - or `'remainder'` to infer the number of items by dividing\n *   the rest of the byte array by the fixed size of its item.\n *   Note that this option is only available for fixed-size items.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/** Defines the configs for array codecs. */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Decodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an array of items.\n *\n * @param item - The codec to use for the array's items.\n * @param config - A set of config for the codec.\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/** Defines the config for bitArray codecs. */\nexport type BitArrayCodecConfig = {\n    /**\n     * Whether to read the bits in reverse order.\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Encodes an array of booleans into bits.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the encoder.\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Decodes bits into an array of booleans.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the decoder.\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * An array of boolean codec that converts booleans to bits and vice versa.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the codec.\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/** Defines the config for boolean codecs. */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec to delegate to.\n     * @defaultValue u8 size.\n     */\n    size?: TSize;\n};\n\n/**\n * Encodes booleans.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Decodes booleans.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Creates a boolean codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Encodes byte arrays as provided.\n *\n * To control the size of the encoded byte array, you can use\n * the `fixEncoderSize` or `addEncoderSizePrefix` functions.\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Decodes byte arrays as-is.\n *\n * To control the size of the decoded byte array, you can use\n * the `fixDecoderSize` or `addDecoderSizePrefix` functions.\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Creates a sized bytes codec.\n *\n * To control the size of the encoded and decoded byte arrays,\n * you can use the `fixCodecSize` or `addCodecSizePrefix` functions.\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Creates a void encoder that always sets the provided byte array when encoding.\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Creates a void decoder that reads the next bytes and fails if they do not match the provided constant.\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Creates a void codec that always sets the provided byte array\n * when encoding and, when decoding, asserts that the next\n * bytes match the provided byte array.\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a tuple-like array.\n *\n * @param items - The encoders to use for each item in the tuple.\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a tuple-like array.\n *\n * @param items - The decoders to use for each item in the tuple.\n */\n\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a tuple-like array.\n *\n * @param items - The codecs to use for each item in the tuple.\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Creates a union encoder from the provided array of encoder.\n *\n * @param variants - The variant encoders of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    });\n}\n\n/**\n * Creates a union decoder from the provided array of decoder.\n *\n * @param variants - The variant decoders of the union.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Creates a union codec from the provided array of codec.\n *\n * @param variants - The variant codecs of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants, getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Codec, combineCodec, Decoder, Encoder, transformDecoder, transformEncoder } from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Defines a discriminated union using discriminated union types.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariant<WebPageEvent, '__kind', 'click'>;\n * // -> { __kind: 'click', x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariantContent<WebPageEvent, '__kind', 'click'>;\n * // -> { x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/** Defines the config for discriminated union codecs. */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`.\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec to use for the enum discriminator prefixing the variant.\n     * @defaultValue u8 prefix.\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\n/**\n * Creates a discriminated union encoder.\n *\n * @param variants - The variant encoders of the discriminated union.\n * @param config - A set of config for the encoder.\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    );\n}\n\n/**\n * Creates a discriminated union decoder.\n *\n * @param variants - The variant decoders of the discriminated union.\n * @param config - A set of config for the decoder.\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    );\n}\n\n/**\n * Creates a discriminated union codec.\n *\n * @param variants - The variant codecs of the discriminated union.\n * @param config - A set of config for the codec.\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n    GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n        GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config),\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    );\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n\n/** @deprecated Use `getDiscriminatedUnionEncoder` instead. */\nexport const getDataEnumEncoder = getDiscriminatedUnionEncoder;\n\n/** @deprecated Use `getDiscriminatedUnionDecoder` instead. */\nexport const getDataEnumDecoder = getDiscriminatedUnionDecoder;\n\n/** @deprecated Use `getDiscriminatedUnionCodec` instead. */\nexport const getDataEnumCodec = getDiscriminatedUnionCodec;\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [\n        ...new Set(Object.values(constructor).filter(v => typeof v === 'number') as number[]),\n    ].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/** Defines the config for enum codecs. */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator.\n     * @defaultValue u8 discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * When set to `true`, numeric values will be used as discriminantors and\n     * an error will be thrown if a string value is found on the enum.\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Creates an enum encoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the encoder.\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Creates an enum decoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the decoder.\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Creates an enum codec.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the codec.\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n\n/** @deprecated Use `getEnumEncoder` instead. */\nexport const getScalarEnumEncoder = getEnumEncoder;\n\n/** @deprecated Use `getEnumDecoder` instead. */\nexport const getScalarEnumDecoder = getEnumDecoder;\n\n/** @deprecated Use `getEnumCodec` instead. */\nexport const getScalarEnumCodec = getEnumCodec;\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Prefixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Prefixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Prefixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Suffixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Suffixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Suffixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/** Defines the config for Map codecs. */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Creates a encoder for a map.\n *\n * @param key - The encoder to use for the map's keys.\n * @param value - The encoder to use for the map's values.\n * @param config - A set of config for the encoder.\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Creates a decoder for a map.\n *\n * @param key - The decoder to use for the map's keys.\n * @param value - The decoder to use for the map's values.\n * @param config - A set of config for the decoder.\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Creates a codec for a map.\n *\n * @param key - The codec to use for the map's keys.\n * @param value - The codec to use for the map's values.\n * @param config - A set of config for the codec.\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Creates a void encoder.\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Creates a void decoder.\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Creates a void codec.\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/** Defines the config for nullable codecs. */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Defines how the `None` (or `null`) value should be represented.\n     *\n     * By default, no none value is used. This means a `null` value will be\n     * represented by the absence of the item.\n     *\n     * When `'zeroes'` is provided, a `null` value will skip the bytes that would\n     * have been used for the item. Note that this returns a fixed-size codec\n     * and thus will only work if the item codec is of fixed size.\n     *\n     * When a custom byte array is provided, a `null` value will be represented\n     * by the provided byte array. Note that this returns a variable-size codec\n     * since the byte array representing `null` does not need to match the size\n     * of the item codec.\n     *\n     * @defaultValue No none value is used.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The codec to use for the boolean prefix, if any.\n     *\n     * By default a `u8` number is used as a prefix to determine if the value is `null`.\n     * The value `0` is encoded for `null` and `1` if the value is present.\n     * This can be set to any number codec to customize the prefix.\n     *\n     * When `null` is provided, no prefix is used and the `noneValue` is used to\n     * determine if the value is `null`. If no `noneValue` is provided, then the\n     * absence of any bytes is used to determine if the value is `null`.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/** Defines the config for set codecs. */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the set.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Decodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Creates a codec for an set of items.\n *\n * @param item - The codec to use for the set's items.\n * @param config - A set of config for the codec.\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype Fields<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a custom object.\n *\n * @param fields - The name and encoder of each field.\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a custom object.\n *\n * @param fields - The name and decoder of each field.\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a custom object.\n *\n * @param fields - The name and codec of each field.\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}